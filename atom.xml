<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yulingtianxia&#39;s blog</title>
  <subtitle>玉令天下的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yulingtianxia.com/"/>
  <updated>2018-05-30T18:45:02.794Z</updated>
  <id>http://yulingtianxia.com/</id>
  
  <author>
    <name>杨萧玉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MessageThrottle Performance Benchmark and Optimization</title>
    <link href="http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/"/>
    <id>http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/</id>
    <published>2018-05-30T18:01:50.000Z</published>
    <updated>2018-05-30T18:45:02.794Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，所以相比直接调用方法，会有一些性能上的损耗。本篇文章记录了对其性能进行测试的结果，并通过使用 &lt;code&gt;NSMapTable&lt;/code&gt; 改进存储结构和缓存来对性能进行大幅度的优化。&lt;/p&gt;
&lt;p&gt;这是你从未体验过的船新版本。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 最初的实现原理可以参考 &lt;a href=&quot;http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/&quot;&gt;Objective-C Message Throttle and Debounce&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Benchmark&quot;&gt;&lt;a href=&quot;#Benchmark&quot; class=&quot;headerlink&quot; title=&quot;Benchmark&quot;&gt;&lt;/a&gt;Benchmark&lt;/h2&gt;&lt;p&gt;Xcode 自带的单元测试框架可以很方便的测量一个方法的执行效率，&lt;code&gt;measureBlock&lt;/code&gt; 里的代码会被执行十次，测试结束后会得到每次执行耗时，以及平均数和方差。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)testPerformanceExample &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// This is an example of a performance test case.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; *date = [&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; date];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; measureBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Put the code you want to measure the time of here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;; i ++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.sstub foo:date];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;性能损耗大多发生在消息转发流程上的处理，为了能够校准基线，需要让每次消息发送都执行。MessageThrottle 1.2.0 刚刚支持了让某些条件下消息永远执行的特性：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setUp &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; setUp];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Put setup code here. This method is called before the invocation of each test method in the class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.sstub = [SuperStub &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MTRule *rule = [self.sstub &lt;span class=&quot;string&quot;&gt;mt_limitSelector:&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;oncePerDuration:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;usingMode:&lt;/span&gt;MTPerformModeDebounce];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rule.alwaysInvokeBlock =  ^(MTRule *rule, NSDate *date) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; YES; &lt;span class=&quot;comment&quot;&gt;// 让消息永远都执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过调整 &lt;code&gt;foo:&lt;/code&gt; 方法的耗时来得到调用不同耗时函数的测试结果。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;selector-tag&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:(NSDate&lt;/span&gt; *)&lt;span class=&quot;selector-tag&quot;&gt;arg&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-attr&quot;&gt;[NSThread sleepForTimeInterval:0.0001]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终得到一组数据，测试机器为 iPhone 8 plus。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;执行模式\被调用方法耗时&lt;/th&gt;
&lt;th&gt;0.0001&lt;/th&gt;
&lt;th&gt;0.001&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不使用 MT&lt;/td&gt;
&lt;td&gt;0.118(baseline)&lt;/td&gt;
&lt;td&gt;1.17(baseline)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MT 立即执行&lt;/td&gt;
&lt;td&gt;0.135(14.4%worse)&lt;/td&gt;
&lt;td&gt;1.33(13.8%worse)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MT debounce 0.01s&lt;/td&gt;
&lt;td&gt;0.0281(76.2%better)&lt;/td&gt;
&lt;td&gt;0.0279(97.6%better)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;测试的基准数据为不使用 MessageThottle，直接调用方法。&lt;/li&gt;
&lt;li&gt;使用 MessageThottle 后，消息转发流程会带来多余的耗时会导致性能下降，而且被调用方法耗时越少，性能下降得越明显（比较两列数据）。&lt;/li&gt;
&lt;li&gt;如果加了消息限频，会忽略掉一部分调用，这样当出现大量频繁调用时，方法真正执行的次数很少，性能反而大大提升了（第三行数据）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Optimization&quot;&gt;&lt;a href=&quot;#Optimization&quot; class=&quot;headerlink&quot; title=&quot;Optimization&quot;&gt;&lt;/a&gt;Optimization&lt;/h2&gt;&lt;p&gt;通过性能优化，将消息转发流程产生的耗时降低了将近 50%。并加强了线程安全。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;执行模式\被调用方法耗时&lt;/th&gt;
&lt;th&gt;0.0001&lt;/th&gt;
&lt;th&gt;0.001&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不使用 MT&lt;/td&gt;
&lt;td&gt;0.118(baseline)&lt;/td&gt;
&lt;td&gt;1.17(baseline)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MT 立即执行&lt;/td&gt;
&lt;td&gt;0.135(14.4%worse)&lt;/td&gt;
&lt;td&gt;1.33(13.8%worse)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能优化后&lt;/td&gt;
&lt;td&gt;0.126(6.88%worse)&lt;/td&gt;
&lt;td&gt;1.25(6.93%worse)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;为了方便管理和查看所有的 &lt;code&gt;MTRule&lt;/code&gt;，使用了 &lt;code&gt;MTEngine&lt;/code&gt; 单例进行中心化的管理。获取一个 &lt;code&gt;MTRule&lt;/code&gt; 之前，需要先用 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;selector&lt;/code&gt; 生成一个描述字符串，然后用这个字符串作为 Key 在 &lt;code&gt;MTEngine&lt;/code&gt; 的字典里查询对应的 &lt;code&gt;MTRule&lt;/code&gt; 对象。每次应用和废除规则、消息发送时都要频繁从 &lt;code&gt;MTEngine&lt;/code&gt; 获取 &lt;code&gt;MTRule&lt;/code&gt; 对象，由此也产生了大量开销。这里的性能瓶颈主要有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成描述字符串造成的开销。&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;MTEngine&lt;/code&gt; 加锁的字典获取 &lt;code&gt;MTRule&lt;/code&gt; 的等待开销。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用和废除规则的时候，这两点开销并不明显。但当所有应用规则的消息发送都要经过这两步的时候，这俨然成了拥堵的重灾区。当然治理方案也是相对的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;改进 &lt;code&gt;MTEngine&lt;/code&gt; 中字典的存储结构，使用 &lt;code&gt;NSMapTable&lt;/code&gt; 替换 &lt;code&gt;NSMutableDictionary&lt;/code&gt;。因为 &lt;code&gt;NSMapTable&lt;/code&gt; 支持将任意指针作为 Key 且无需持有，可以将 &lt;code&gt;target&lt;/code&gt; 作为 Key，Value 为这个 &lt;code&gt;target&lt;/code&gt; 对应的 &lt;code&gt;selector&lt;/code&gt; 集合。&lt;code&gt;MTEngine&lt;/code&gt; 不再持有 &lt;code&gt;MTRule&lt;/code&gt; 对象，而只是存储了所有应用规则的 &lt;code&gt;target&lt;/code&gt; 及其 &lt;code&gt;selector&lt;/code&gt;。而 &lt;code&gt;MTRule&lt;/code&gt; 对象改为由其 &lt;code&gt;target&lt;/code&gt; 通过 AssociatedObject 的方式持有，可以很方便通过 &lt;code&gt;selector&lt;/code&gt; 存取。当 &lt;code&gt;target&lt;/code&gt; 销毁后，它关联的 &lt;code&gt;MTRule&lt;/code&gt; 对象也会被销毁，&lt;code&gt;NSMapTable&lt;/code&gt; 也会自动移除那些键或值为 &lt;code&gt;nil&lt;/code&gt; 的数据。下面是 &lt;code&gt;MTEngine&lt;/code&gt; 封装了 &lt;code&gt;NSMapTable&lt;/code&gt; 字典对应的便捷方法。&lt;/p&gt;
 &lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_targetSELs = [&lt;span class=&quot;built_in&quot;&gt;NSMapTable&lt;/span&gt; weakToStrongObjectsMapTable];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//添加 target-selector 记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)addSelector:(SEL)selector onTarget:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt; *selectors = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs objectForKey:target];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!selectors) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        selectors = [&lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt; set];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [selectors addObject:&lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs setObject:selectors forKey:target];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//移除 target-selector 记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)removeSelector:(SEL)selector onTarget:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt; *selectors = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs objectForKey:target];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!selectors) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        selectors = [&lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt; set];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [selectors removeObject:&lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs setObject:selectors forKey:target];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//是否存在 target-selector 记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)containsSelector:(SEL)selector onTarget:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs objectForKey:target] containsObject:&lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//是否存在 target-selector 记录，未指定具体 target，但 target 的类型为 cls 即可&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)containsSelector:(SEL)selector onTargetsOfClass:(Class)cls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; target &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs keyEnumerator] allObjects]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!mt_object_isClass(target) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [target isMemberOfClass:cls] &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.targetSELs objectForKey:target] containsObject:&lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个 &lt;code&gt;MTRule&lt;/code&gt; 有自己独立的递归锁，这样避免了在 &lt;code&gt;forwardInvocation&lt;/code&gt; 里千军万马过独木桥的拥堵，且不妨碍递归调用的场景。存取 &lt;code&gt;MTEngine&lt;/code&gt; 的字典依然使用普通的互斥锁。这两个锁都使用性能较好的 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 实现。&lt;/p&gt;
 &lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 初始化递归锁&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pthread_mutexattr_t attr&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       pthread_mutexattr_init(&amp;amp;attr)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       pthread_mutexattr_settype(&amp;amp;attr, PTHREAD_MUTEX_RECURSIVE)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       pthread_mutex_t mutex = mtDealloc.invokeLock&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       pthread_mutex_init(&amp;amp;mutex, &amp;amp;attr)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       objc_setAssociatedObject(rule.target, rule.selector, mtDealloc, OBJC_ASSOCIATION_RETAIN)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // 消息转发时保证线程安全&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  static void mt_forwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL originalSelector = invocation.selector&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL fixedOriginalSelector = mt_aliasForSelector(originalSelector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (![assignSlf respondsToSelector:fixedOriginalSelector]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mt_executeOrigForwardInvocation(assignSlf, selector, invocation)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MTDealloc *mtDealloc = objc_getAssociatedObject(invocation.target, selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_t mutex = mtDealloc.invokeLock&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mt_handleInvocation(invocation, fixedOriginalSelector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;MTEngine&lt;/code&gt; 中字典的存储结构的改进不仅提高了性能，还让设计思路更清晰。在添加或废除规则的时候，旧方案需要遍历所有的 &lt;code&gt;MTRule&lt;/code&gt; 对象，然后通过检查 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;selector&lt;/code&gt; 来判断规则是否相互干扰；新方案直接存储了 &lt;code&gt;target&lt;/code&gt; 和对应的 &lt;code&gt;selector&lt;/code&gt; 数组，声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSMapTable&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSMutableSet&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; *&amp;gt; *targetSELs;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的存储方式可以更高效地找到某个对象或类的某个方法是否被限频了，增删规则也更快。&lt;/p&gt;
&lt;p&gt;在 Hook 某个方法的时候，会给它生成一个新的方法名，这就又涉及到字符串拼接的开销。解决方案是使用缓存来映射两个 &lt;code&gt;SEL&lt;/code&gt; 指针，又要用到 &lt;code&gt;NSMapTable&lt;/code&gt; 大显神威了。这又将节省 6% 左右的 CPU 耗时！需要注意的是创建 &lt;code&gt;NSMapTable&lt;/code&gt; 时的选项，以及存取时的类型强转：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化 NSMapTable 缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_aliasSelectorCache = [&lt;span class=&quot;built_in&quot;&gt;NSMapTable&lt;/span&gt; mapTableWithKeyOptions:&lt;span class=&quot;built_in&quot;&gt;NSPointerFunctionsOpaqueMemory&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;NSMapTableObjectPointerPersonality&lt;/span&gt; valueOptions:&lt;span class=&quot;built_in&quot;&gt;NSPointerFunctionsOpaqueMemory&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;NSMapTableObjectPointerPersonality&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在方法内部使用缓存优化性能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; SEL mt_aliasForSelector(SEL selector)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;alias_selector_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL aliasSelector = (__bridge &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)[MTEngine.defaultEngine.aliasSelectorCache objectForKey:(__bridge &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)selector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!aliasSelector) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *selectorName = &lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        aliasSelector = &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;([&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;__mt_%@&quot;&lt;/span&gt;, selectorName]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [MTEngine.defaultEngine.aliasSelectorCache setObject:(__bridge &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)aliasSelector forKey:(__bridge &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)selector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;alias_selector_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; aliasSelector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可能有人会担心直接缓存 &lt;code&gt;SEL&lt;/code&gt; 指针会不会命中率很低。因为所有名字相同的方法都拥有同一个唯一的 &lt;code&gt;SEL&lt;/code&gt;，所以可以很快速地用直接指针地址判等。可以参考&lt;a href=&quot;https://stackoverflow.com/questions/11051528/understanding-uniqueness-of-selectors-in-objective-c?utm_medium=organic&amp;amp;utm_source=google_rich_qa&amp;amp;utm_campaign=google_rich_qa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;更新 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 到最新版即可获取到更快更强更安全的 Objective 消息节流限频功能，一行代码搞定频繁调用的问题。&lt;/p&gt;
&lt;p&gt;新版本在废除消息的时候，也增强了对合法性和安全性的检查。（说白了就是改 bug）&lt;/p&gt;
&lt;p&gt;理论上我的另一个组件 &lt;a href=&quot;https://github.com/yulingtianxia/BlockTracker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockTracker&lt;/a&gt; 也可以按照本文的方案优化性能了，嘿嘿，有时间搞下。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot;&gt;MessageThrottle&lt;/a&gt; 是我开发的Objective-C 节流限频组件，其原理基于 Hook 消息转发流程，所以相比直接调用方法，会有一些性能上的损耗。本篇文章记录了对其性能进行测试的结果，并通过使用 &lt;code&gt;NSMapTable&lt;/code&gt; 改进存储结构和缓存来对性能进行大幅度的优化。&lt;/p&gt;
&lt;p&gt;这是你从未体验过的船新版本。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Colorful Rounded Rect Dash Border</title>
    <link href="http://yulingtianxia.com/blog/2018/04/30/Colorful-Rounded-Rect-Dash-Border/"/>
    <id>http://yulingtianxia.com/blog/2018/04/30/Colorful-Rounded-Rect-Dash-Border/</id>
    <published>2018-04-30T09:25:44.000Z</published>
    <updated>2018-04-30T09:21:47.810Z</updated>
    
    <content type="html">&lt;p&gt;产品经理要求做个能展示进度的分段彩色外环，大概长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/YXYDashLayer/blob/master/Assets/YXYDashLayer.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;花了两天左右来实现和优化，记录下踩坑经历。&lt;/p&gt;
&lt;p&gt;组件已经开源，取个名字叫 &lt;code&gt;YXYDashLayer&lt;/code&gt; 吧：&lt;a href=&quot;https://github.com/yulingtianxia/YXYDashLayer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/YXYDashLayer&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;接口设计&quot;&gt;&lt;a href=&quot;#接口设计&quot; class=&quot;headerlink&quot; title=&quot;接口设计&quot;&gt;&lt;/a&gt;接口设计&lt;/h2&gt;&lt;p&gt;因为考虑到要做成稍微通用一些的组件，最底层的 &lt;code&gt;YXYMaskDashLayer&lt;/code&gt; 接口设计如下。其他类的属性也都是对它的封装。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 分段的间隙&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; dashGap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 线宽&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; dashWidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 矩形的圆角半径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; dashCornerRadius;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 分段总数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; totalCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 需要显示哪些分段的 index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *&amp;gt; *showIndexes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 刷新整个Layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)refresh;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 仅刷新 Dash 的 totalCount、dashGap 和 showIndexes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)refreshDash;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为有些属性改变后并不需要重新绘制 path，为了实现更好的性能，所以还提供了一个只刷新 dash 数据的接口 &lt;code&gt;refreshDash&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;具体使用的例子可以运行 Demo 程序。&lt;/p&gt;
&lt;h2 id=&quot;思路很重要&quot;&gt;&lt;a href=&quot;#思路很重要&quot; class=&quot;headerlink&quot; title=&quot;思路很重要&quot;&gt;&lt;/a&gt;思路很重要&lt;/h2&gt;&lt;p&gt;之前的样式是个圆形的分段外环，而且是纯色的，看了下以前的代码，是按照弧度均分后，从顶部开始按顺时针一段一段 path 组合起来的。用 &lt;code&gt;UIBezierPath&lt;/code&gt; 的 &lt;code&gt;+ bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise:&lt;/code&gt; 方法即可画出来。&lt;/p&gt;
&lt;p&gt;然而现在改成了圆角矩形的，要按照周长均分来画分段，实现方式完全不同。因为圆形只是圆角矩形的一种特殊情况，所以需要另一种更通用的实现方式。因为借鉴了圆形分段一段段画的思想，最开始想到的也是一段段画圆角矩形，需要把整个圆角矩形划分成 9 个区域（四个四分之一圆弧，四条直线，顶部直线需要分成两块），还要对圆角和直线部分的边界处理，涉及到大量的计算。我刚开始要这么干的时候，觉得这么做有点笨，肯定有更简单的方案。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CAShapeLayer&lt;/code&gt; 的 &lt;code&gt;lineDashPattern&lt;/code&gt; 和 &lt;code&gt;lineDashPhase&lt;/code&gt; 属性就可以实现这个需求了，之前一直被旧代码的方案限制了思路。真是退一步海阔天空啊。原本跟产品说这有 5 天工作量，结果半个小时就写出个 demo，哈哈。然后用剩下的时间继续完善打磨，做成通用组件。&lt;/p&gt;
&lt;h2 id=&quot;技术实现&quot;&gt;&lt;a href=&quot;#技术实现&quot; class=&quot;headerlink&quot; title=&quot;技术实现&quot;&gt;&lt;/a&gt;技术实现&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;先用贝塞尔曲线画一个圆角矩形(就叫 &lt;code&gt;path&lt;/code&gt; 吧)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path.CGPath&lt;/code&gt; 赋值给 &lt;code&gt;CAShapeLayer&lt;/code&gt; 实例（就叫 &lt;code&gt;maskLayer&lt;/code&gt; 吧）&lt;/li&gt;
&lt;li&gt;根据线宽、分段间隙、&lt;code&gt;path&lt;/code&gt; 周长、总分段数、要展示的分段 index，可计算出 &lt;code&gt;lineDashPattern&lt;/code&gt; 和 &lt;code&gt;lineDashPhase&lt;/code&gt; 的值，刷新 &lt;code&gt;maskLayer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;maskLayer&lt;/code&gt; 赋值给 &lt;code&gt;CAGradientLayer&lt;/code&gt; 实例的 &lt;code&gt;mask&lt;/code&gt;。调整 &lt;code&gt;colors&lt;/code&gt; 等属性即可实现一个彩色渐变分段圆角矩形外圈。&lt;/li&gt;
&lt;li&gt;将多个这样的 &lt;code&gt;CAGradientLayer&lt;/code&gt; 实例重叠在一起，即可实现个别分段『高亮』效果。比如一个 layer 当做底色，另一个放上面当做灰色进度条。（PS：本文最开始的 gif 就是这样）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里面踩坑最多的就是前 3 个步骤，计算时需要考虑到一些边界条件。&lt;/p&gt;
&lt;h3 id=&quot;画圆角矩形的坑&quot;&gt;&lt;a href=&quot;#画圆角矩形的坑&quot; class=&quot;headerlink&quot; title=&quot;画圆角矩形的坑&quot;&gt;&lt;/a&gt;画圆角矩形的坑&lt;/h3&gt;&lt;p&gt;&lt;code&gt;+ bezierPathWithRoundedRect:cornerRadius:&lt;/code&gt; 方法是可以直接画出一个圆角矩形的，但是路径的起始点并没确定。表面上看上去是从顶部直线左端开始顺时针画，然而会有向右的一些偏差。这样就无法精确计算出 &lt;code&gt;lineDashPhase&lt;/code&gt; 的值，导致画出来的效果不对称了。&lt;/p&gt;
&lt;p&gt;于是我这里干脆自己画个圆角矩形，代码也很简单。由于要考虑到线宽，所以需要计算下真正的圆角半径和外接矩形尺寸，顺时针画四段直线四段四分之一圆弧即可。下面的代码是写在 &lt;code&gt;CAShapeLayer&lt;/code&gt; 子类里的：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIBezierPath&lt;/span&gt; *path = [&lt;span class=&quot;built_in&quot;&gt;UIBezierPath&lt;/span&gt; bezierPath];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashRect = &lt;span class=&quot;built_in&quot;&gt;CGRectInset&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.bounds, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; width = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashRect.size.width;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; height = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashRect.size.height;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius = MIN(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashCornerRadius - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius = MAX(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt; center = &lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.frame.size.width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.frame.size.height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path moveToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addLineToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x + width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addArcWithCenter:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x + width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius) radius:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius startAngle:M_PI_2 * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; endAngle:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; clockwise:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addLineToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x + width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, center.y + height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addArcWithCenter:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x + width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y + height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius) radius:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius startAngle:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; endAngle:M_PI_2 clockwise:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addLineToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y + height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addArcWithCenter:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y + height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius) radius:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius startAngle:M_PI_2 endAngle:M_PI clockwise:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addLineToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[path addArcWithCenter:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(center.x - width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius, center.y - height / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius) radius:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius startAngle:M_PI endAngle:M_PI_2 * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; clockwise:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalLength = (width + height) * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius * &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; + M_PI * &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.realDashCornerRadius * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.lineWidth = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.path = path.CGPath;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码也计算出了周长，用于下一步的分段长度计算。&lt;/p&gt;
&lt;h3 id=&quot;处理边界值&quot;&gt;&lt;a href=&quot;#处理边界值&quot; class=&quot;headerlink&quot; title=&quot;处理边界值&quot;&gt;&lt;/a&gt;处理边界值&lt;/h3&gt;&lt;p&gt;圆角矩形的周长已经算出来了，外部提供了 &lt;code&gt;dashGap&lt;/code&gt;，但是绘制时真正的分段间隙是需要考虑到线宽和分段总数的。因为线的边缘会有个半圆，半径为二分之一线宽。当只有一个分段的时候画一个完整的圆角矩形，不需要有间隙了。如果分段总数过多导致计算的分段长度 &lt;code&gt;pieceLength&lt;/code&gt; 小于 0，需要计算能展示出来分段数的最大值 &lt;code&gt;realTotalCount&lt;/code&gt;，并重新计算分段长度 &lt;code&gt;pieceLength&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; realDashGap = (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalCount == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashGap + &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dashWidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; realTotalCount = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; pieceLength = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalLength / &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalCount - realDashGap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pieceLength &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   pieceLength = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   realTotalCount = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalLength / realDashGap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   pieceLength = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.totalLength / realTotalCount - realDashGap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Can&#39;t show! Reduce total count or dash gap! Real Total Count: %lu, Real Dash Gap:%ff&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)realTotalCount, realDashGap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Dash-策略&quot;&gt;&lt;a href=&quot;#Dash-策略&quot; class=&quot;headerlink&quot; title=&quot;Dash 策略&quot;&gt;&lt;/a&gt;Dash 策略&lt;/h3&gt;&lt;p&gt;&lt;code&gt;lineDashPhase&lt;/code&gt; 可以理解为 dash 距离 path 起始点的距离，想让 dash 从顶部中间开始，需要设置初始值：二分之一外接矩形宽度的减去圆角半径，再加上二分之一 &lt;code&gt;realDashGap&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self.lineDashPhase &lt;/span&gt;= - (&lt;span class=&quot;keyword&quot;&gt;self.dashRect.size.width &lt;/span&gt;/ &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;self.realDashCornerRadius &lt;/span&gt;+ realDashGap / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后就是顺时针画需要展示的分段。输入是一个 &lt;code&gt;showIndexes&lt;/code&gt; 数组，比如一共有 10 个分段，想展示的是前两个和最后一个分段，那么 &lt;code&gt;showIndexes&lt;/code&gt; 的内容就是 &lt;code&gt;@[@0, @1, @9]&lt;/code&gt;。此时 &lt;code&gt;lineDashPattern&lt;/code&gt; 的值就应该是（&lt;code&gt;pieceLength&lt;/code&gt; 就是每个分段的长度）：&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@[&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@realDashGap,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@(realDashGap&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;*&lt;/span&gt; 8 + pieceLength &lt;span class=&quot;symbol&quot;&gt;*&lt;/span&gt; 7), &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@realDashGap]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果 &lt;code&gt;showIndexes&lt;/code&gt; 的内容是 &lt;code&gt;@[@1, @2, @9]&lt;/code&gt;，可不可以让 &lt;code&gt;lineDashPattern&lt;/code&gt; 数组前面填 &lt;code&gt;@0&lt;/code&gt; 呢？&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@[&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@0,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@(pieceLength&lt;/span&gt; + realDashGap), &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@realDashGap,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@(realDashGap&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;*&lt;/span&gt; 7 + pieceLength &lt;span class=&quot;symbol&quot;&gt;*&lt;/span&gt; 6), &lt;span class=&quot;meta&quot;&gt;@pieceLength,&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@realDashGap]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为把 &lt;code&gt;lineCap&lt;/code&gt; 设为了 &lt;code&gt;kCALineCapRound&lt;/code&gt;，即便长度为 0 路径也会展示成为一个圆点，半径就是线宽。然而安卓系统对应的 API 在这种情况就不会绘制出圆点。为此 iOS 更麻烦一点，需要再次调整&lt;code&gt;lineDashPhase&lt;/code&gt; 的值来『越过』前面几个分段。具体的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;NSMutableArray&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;NSNumber&lt;/span&gt; *&amp;gt; *dashPattern = [&lt;span class=&quot;type&quot;&gt;NSMutableArray&lt;/span&gt; arrayWithCapacity:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * realTotalCount];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;NSInteger&lt;/span&gt; needsMovePhaseCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (int i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; realTotalCount; i ++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.showIndexes containsObject:@(i)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [dashPattern addObject:@(pieceLength)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [dashPattern addObject:@(realDashGap)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           dashPattern[dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = @(dashPattern[dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].doubleValue + pieceLength + realDashGap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.lineDashPhase -= (pieceLength + realDashGap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           needsMovePhaseCount ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (needsMovePhaseCount &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   dashPattern[dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = @(dashPattern[dashPattern.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].doubleValue + (pieceLength + realDashGap) * needsMovePhaseCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.showIndexes.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.lineDashPattern = dashPattern;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;一开始做这种需求我是拒绝的，交互有点复杂啊，用户看不懂啊，说白了还是不知道咋实现心里没底啊！然而要是没有这种需求，也就没有这篇月末大水文了。&lt;/p&gt;
&lt;p&gt;我真是越来越水了，只会写 UI 了，还是搞底层的逆向大佬们牛逼啊！Hank 老师教教我！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;产品经理要求做个能展示进度的分段彩色外环，大概长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/YXYDashLayer/blob/master/Assets/YXYDashLayer.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;花了两天左右来实现和优化，记录下踩坑经历。&lt;/p&gt;
&lt;p&gt;组件已经开源，取个名字叫 &lt;code&gt;YXYDashLayer&lt;/code&gt; 吧：&lt;a href=&quot;https://github.com/yulingtianxia/YXYDashLayer&quot;&gt;https://github.com/yulingtianxia/YXYDashLayer&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>追踪 Objective-C 方法中的 Block 参数对象</title>
    <link href="http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/"/>
    <id>http://yulingtianxia.com/blog/2018/03/31/Track-Block-Arguments-of-Objective-C-Method/</id>
    <published>2018-03-31T15:44:39.000Z</published>
    <updated>2018-04-01T15:23:14.592Z</updated>
    
    <content type="html">&lt;p&gt;很多方法最后一个参数是类似于 &lt;code&gt;completionBlock&lt;/code&gt; 这种回调，然而有些 API 实现一些异常逻辑时会忘记调用传入的 Block 参数（当然这肯定是 bug 啦），或者存在多次调用。在调试的时候可能会碰到这种大坑，需要追踪下 Block 参数何时调用了，甚至是否调用过。如果不方便直接在 Block 实现中加代码，或者没有源码的情况下，就需要无侵入式地追踪 Block 参数对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockTracker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockTracker&lt;/a&gt; 可以追踪方法调用时传入的 Block 类型的参数的执行和销毁。基于 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockHook&lt;/a&gt; 实现。本文讲述了它的使用方法和实现原理。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h2&gt;&lt;p&gt;只需要调用 &lt;code&gt;bt_trackBlockArgOfSelector:callback:&lt;/code&gt; 方法，就能在对应方法执行传入的 block 参数被调用和销毁的时候得到回调。回调中的内容包含了 &lt;code&gt;block&lt;/code&gt; 对象，回调类型，&lt;code&gt;block&lt;/code&gt; 已经执行的次数，执行 &lt;code&gt;block&lt;/code&gt; 的参数、返回值，堆栈信息。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BTTracker *tracker = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; bt_trackBlockArgOfSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(performBlock:) callback:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;  _Nullable block, BlockTrackerCallbackType type, &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; invokeCount, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * _Nullable * _Null_unspecified args, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * _Nullable result, &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; * _Nonnull callStackSymbols) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@ invoke count = %ld&quot;&lt;/span&gt;, BlockTrackerCallbackTypeInvoke == type ? &lt;span class=&quot;string&quot;&gt;@&quot;BlockTrackerCallBackTypeInvoke&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;BlockTrackerCallBackTypeDead&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)invokeCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当你不想追踪这个方法执行时传入的 block 参数时，也可以停止追踪：&lt;/p&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[tracker stop]&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;举个栗子，现在有个方法叫 &lt;code&gt;performBlock:&lt;/code&gt;，只是简单地调用了 &lt;code&gt;block&lt;/code&gt; 参数：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;)performBlock:(&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;))&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用两次这个方法，每次都传入不同的 block 实现：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block NSString *word = @&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m a block&quot;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self performBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;add &#39;!!!&#39; to word&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   word = [word stringByAppendingString:@&lt;span class=&quot;string&quot;&gt;&quot;!!!&quot;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self performBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;%@&quot;&lt;/span&gt;, word)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为执行两次方法传入的是两个不同的 block 对象，所以会追踪两个 block 对象的执行和销毁，打印的 log 如下：&lt;/p&gt;
&lt;figure class=&quot;highlight smali&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;add &#39;!!!&#39; to word&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BlockTrackerCallBackTypeInvoke&lt;span class=&quot;built_in&quot;&gt; invoke &lt;/span&gt;count = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I&#39;m a block!!!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BlockTrackerCallBackTypeInvoke&lt;span class=&quot;built_in&quot;&gt; invoke &lt;/span&gt;count = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BlockTrackerCallBackTypeDead&lt;span class=&quot;built_in&quot;&gt; invoke &lt;/span&gt;count = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BlockTrackerCallBackTypeDead&lt;span class=&quot;built_in&quot;&gt; invoke &lt;/span&gt;count = 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 block 对象销毁的时候&lt;br&gt;你可以尝试着把 &lt;code&gt;performBlock:&lt;/code&gt; 的实现改成这样试试：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;)performBlock:(&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;built_in&quot;&gt;void&lt;/span&gt;))&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;原理很简单，就是 Hook 方法后再 Hook 下 Block，流程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用 Objective-C Runtime 机制 Hook 某个方法，参考 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 的实现原理。&lt;/li&gt;
&lt;li&gt;在方法真正执行前，使用 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlockHook&lt;/a&gt; 先 Hook 所有 Block 类型的参数。Hook 模式为 &lt;code&gt;BlockHookModeAfter&lt;/code&gt; 和 &lt;code&gt;BlockHookModeDead&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 Block 执行后更新执行次数，并将相关信息回调给 Tracker。销毁后也会回调给 Tracker。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;流程大概很简单，复用以前代码。这里主要讲下 Track 的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;过滤方法的-Block-参数&quot;&gt;&lt;a href=&quot;#过滤方法的-Block-参数&quot; class=&quot;headerlink&quot; title=&quot;过滤方法的 Block 参数&quot;&gt;&lt;/a&gt;过滤方法的 Block 参数&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;bt_trackBlockArgOfSelector:callback:&lt;/code&gt; 里获取方法的 Type Encoding 后判断是否含有 Block 类型的参数，并将 Block 参数的 Index 保存到 &lt;code&gt;BTTracker&lt;/code&gt; 的 &lt;code&gt;blockArgIndex&lt;/code&gt; 属性。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable &lt;span class=&quot;keyword&quot;&gt;BTTracker &lt;/span&gt;*)&lt;span class=&quot;keyword&quot;&gt;bt_trackBlockArgOfSelector:(SEL)selector &lt;/span&gt;callback:(&lt;span class=&quot;keyword&quot;&gt;BlockTrackerCallbackBlock)callback&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class cls = &lt;span class=&quot;keyword&quot;&gt;bt_classOfTarget(self);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method &lt;span class=&quot;keyword&quot;&gt;originMethod &lt;/span&gt;= class_getInstanceMethod(cls, selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!&lt;span class=&quot;keyword&quot;&gt;originMethod) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    const char *&lt;span class=&quot;keyword&quot;&gt;originType &lt;/span&gt;= (char *)method_getTypeEncoding(&lt;span class=&quot;keyword&quot;&gt;originMethod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    if (![[NSString stringWithUTF8String:&lt;span class=&quot;keyword&quot;&gt;originType] &lt;/span&gt;containsString:@&lt;span class=&quot;string&quot;&gt;&quot;@?&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *&lt;span class=&quot;keyword&quot;&gt;blockArgIndex &lt;/span&gt;= [NSMutableArray array]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int argIndex = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; // return type is the first one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(&lt;span class=&quot;keyword&quot;&gt;originType &lt;/span&gt;&amp;amp;&amp;amp; *&lt;span class=&quot;keyword&quot;&gt;originType)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;originType &lt;/span&gt;= &lt;span class=&quot;keyword&quot;&gt;BHSizeAndAlignment(originType, &lt;/span&gt;NULL, NULL, NULL)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ([[NSString stringWithUTF8String:&lt;span class=&quot;keyword&quot;&gt;originType] &lt;/span&gt;hasPrefix:@&lt;span class=&quot;string&quot;&gt;&quot;@?&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;keyword&quot;&gt;blockArgIndex &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;addObject:@(argIndex)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        argIndex++&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;BTTracker &lt;/span&gt;*tracker = &lt;span class=&quot;keyword&quot;&gt;BTEngine.defaultEngine.trackers[bt_methodDescription(self, &lt;/span&gt;selector)]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!tracker) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tracker = [[&lt;span class=&quot;keyword&quot;&gt;BTTracker &lt;/span&gt;alloc] initWithTarget:self selector:selector]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tracker.callback = callback&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tracker.&lt;span class=&quot;keyword&quot;&gt;blockArgIndex &lt;/span&gt;= [&lt;span class=&quot;keyword&quot;&gt;blockArgIndex &lt;/span&gt;copy]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [tracker apply] ? tracker : nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;bt_trackBlockArgOfSelector:callback:&lt;/code&gt; 方法返回的 &lt;code&gt;BTTracker&lt;/code&gt; 对象也保存了 &lt;code&gt;callback&lt;/code&gt; 回调。&lt;/p&gt;
&lt;h3 id=&quot;执行-Callback&quot;&gt;&lt;a href=&quot;#执行-Callback&quot; class=&quot;headerlink&quot; title=&quot;执行 Callback&quot;&gt;&lt;/a&gt;执行 Callback&lt;/h3&gt;&lt;p&gt;遍历之前保存的 Block 参数 Index 列表 &lt;code&gt;blockArgIndex&lt;/code&gt;，从 &lt;code&gt;NSInvocation&lt;/code&gt; 中取到 Block 参数后，就可以 Hook 了。Block 的执行次数保存到了 &lt;code&gt;BHToken&lt;/code&gt; 上，每次执行都会累加。在 Block 执行或销毁后都会调用 &lt;code&gt;callback&lt;/code&gt;，只是传的参数稍有不同。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *index &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; tracker.blockArgIndex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (index.integerValue &amp;lt; invocation.methodSignature.numberOfArguments) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       __unsafe_unretained &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [invocation getArgument:&amp;amp;block atIndex:index.integerValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(block) weakBlock = block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(tracker) weakTracker = tracker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       BHToken *tokenAfter = [block block_hookWithMode:BlockHookModeAfter usingBlock:^(BHToken *token) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(weakBlock) strongBlock = weakBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(weakTracker) strongTracker = weakTracker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *invokeCount = objc_getAssociatedObject(token, &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;invokeCount&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!invokeCount) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               invokeCount = @(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               invokeCount = [&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; numberWithInt:invokeCount.intValue + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           objc_setAssociatedObject(token, &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;invokeCount&quot;&lt;/span&gt;), invokeCount, OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_RETAIN&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (strongTracker.callback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               strongTracker.callback(strongBlock, BlockTrackerCallbackTypeInvoke, invokeCount.intValue, token.args, token.retValue, [&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; callStackSymbols]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [block block_hookWithMode:BlockHookModeDead usingBlock:^(BHToken *token) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(weakTracker) strongTracker = weakTracker;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *invokeCount = objc_getAssociatedObject(tokenAfter, &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;invokeCount&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (strongTracker.callback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               strongTracker.callback(&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, BlockTrackerCallbackTypeDead, invokeCount.intValue, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, [&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; callStackSymbols]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;对-NSInvocation-的一点探索&quot;&gt;&lt;a href=&quot;#对-NSInvocation-的一点探索&quot; class=&quot;headerlink&quot; title=&quot;对 NSInvocation 的一点探索&quot;&gt;&lt;/a&gt;对 NSInvocation 的一点探索&lt;/h3&gt;&lt;p&gt;在从 &lt;code&gt;NSInvocation&lt;/code&gt; 对象获取参数时，需要先调用 &lt;code&gt;retainArguments&lt;/code&gt; 方法让 &lt;code&gt;NSInvocation&lt;/code&gt; 将 Block 参数 &lt;code&gt;copy&lt;/code&gt;。因为有些 Block 参数类型是 &lt;code&gt;__NSStackBlock__&lt;/code&gt;，需要拷贝到堆上，否则从 &lt;code&gt;NSInvocation&lt;/code&gt; 获取的 Block 不会销毁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getArgument:atIndex:&lt;/code&gt; 方法只是将第 &lt;code&gt;index&lt;/code&gt; 个参数指针的值拷贝到 &lt;code&gt;buffer&lt;/code&gt; 中，而 &lt;code&gt;retainArguments&lt;/code&gt; 才是真的对 C 字符串和 Block 拷贝。&lt;/p&gt;
&lt;p&gt;我还为此做了个小实验。一个类外部声明并调用了 &lt;code&gt;test:&lt;/code&gt; 方法，但其实内部实现的是 &lt;code&gt;foo:&lt;/code&gt; 方法。通过实现 &lt;code&gt;methodSignatureForSelector:&lt;/code&gt; 让消息转发流程走到 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法中。然后向 Block 参数关联 &lt;code&gt;BTDealloc&lt;/code&gt; 对象，在 &lt;code&gt;test:&lt;/code&gt; 方法执行后，&lt;code&gt;BTDealloc&lt;/code&gt; 类的 &lt;code&gt;dealloc&lt;/code&gt; 方法并没有执行。也就是说通过 &lt;code&gt;NSInvocation&lt;/code&gt; 获取的 Block 参数没销毁；如果先调用了 &lt;code&gt;retainArguments&lt;/code&gt; 就会销毁。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;test:&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;))block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)) block &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    block();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSMethodSignature *)&lt;span class=&quot;string&quot;&gt;methodSignatureForSelector:&lt;/span&gt;(SEL)aSelector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [NSMethodSignature &lt;span class=&quot;string&quot;&gt;signatureWithObjCTypes:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;v@:@?&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;forwardInvocation:&lt;/span&gt;(NSInvocation *)anInvocation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//    [anInvocation retainArguments];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; **invocationFrame = ((__bridge struct BTInvocaton *)anInvocation)-&amp;gt;frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *blockFromFrame = invocationFrame[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [anInvocation &lt;span class=&quot;string&quot;&gt;getArgument:&lt;/span&gt;&amp;amp;block &lt;span class=&quot;string&quot;&gt;atIndex:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BTDealloc *btDealloc = [BTDealloc &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_setAssociatedObject((__bridge id)block, &lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt;), btDealloc, OBJC_ASSOCIATION_RETAIN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    anInvocation.selector = &lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [anInvocation invoke];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过对 &lt;code&gt;NSInvocation&lt;/code&gt; 对象的解析，我发现 &lt;code&gt;NSInvocation&lt;/code&gt; 的参数存储于一个私有成员变量 &lt;code&gt;_frame&lt;/code&gt; 中，试着将其强转为二级指针，也就是指针数组。拿到对应 index 的值 &lt;code&gt;blockFromFrame&lt;/code&gt; 跟 &lt;code&gt;block&lt;/code&gt; 作比较，发现是一样的。这里获取 &lt;code&gt;_frame&lt;/code&gt; 需要强转下，&lt;code&gt;NSInvocation&lt;/code&gt; 的内存模型如下：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct &lt;span class=&quot;keyword&quot;&gt;BTInvocaton &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *isa&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *frame&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *retdata&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *signature&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *container&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint8_t retainedArgs&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint8_t reserved[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;由于 Hook Method 的逻辑是在消息转发流程搞事情，所以跟 Aspects 一样不能同时 Hook 父类和子类类相同方法。因为如果子类调用父类的实现，就会死循环。如果 Hook 方法这部分使用 &lt;a href=&quot;http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/&quot;&gt;Method Swizzling&lt;/a&gt; 等交换 IMP 的方式实现，也会有着严重依赖 Hook 顺序导致调用错乱的问题。还是基于桥的 Hook 牛逼，汇编跳板，我这辈子是看不懂了。&lt;/p&gt;
&lt;p&gt;老子终于在这个月最后一天快结束的时候憋出来一篇大水文！搬砖累死了没时间研究技术，你们尽管喷！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;很多方法最后一个参数是类似于 &lt;code&gt;completionBlock&lt;/code&gt; 这种回调，然而有些 API 实现一些异常逻辑时会忘记调用传入的 Block 参数（当然这肯定是 bug 啦），或者存在多次调用。在调试的时候可能会碰到这种大坑，需要追踪下 Block 参数何时调用了，甚至是否调用过。如果不方便直接在 Block 实现中加代码，或者没有源码的情况下，就需要无侵入式地追踪 Block 参数对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockTracker&quot;&gt;BlockTracker&lt;/a&gt; 可以追踪方法调用时传入的 Block 类型的参数的执行和销毁。基于 &lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot;&gt;BlockHook&lt;/a&gt; 实现。本文讲述了它的使用方法和实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Hook Objective-C Block with Libffi</title>
    <link href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/"/>
    <id>http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/</id>
    <published>2018-02-28T11:05:24.000Z</published>
    <updated>2018-03-26T16:24:18.836Z</updated>
    
    <content type="html">&lt;p&gt;本文通过参照 &lt;code&gt;MABlockClosure&lt;/code&gt; 的实现和 &lt;code&gt;Aspects&lt;/code&gt; 的 API 设计，基于 libffi 实现了对 Objective-C Block 的 hook。GitHub 地址：&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/BlockHook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;什么场景下需要 hook block 呢？在有源码的情况下，大部分程序员会选择直接在 block 中插代码。假如方法 A 的入参是个 block 对象，方法 A 将 block 传给方法 B,C…等。如果只有方法 A 的源码，上层传入的 block 和下层方法实现都是黑盒的话，想追踪 block 调用的时机，打印些 log，就得 hook 这个 block 对象了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h2&gt;&lt;p&gt;虽然 Github 上已经给了例子，用过 Aspects 的人一看就懂，但为了凑篇幅，还是多 BB 几句吧。&lt;/p&gt;
&lt;p&gt;API 虽然清奇，但是需要在 block 对象上用哦，在其他类型的对象上用是无效的！&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(BHToken *)&lt;/span&gt;block_hookWithMode:&lt;span class=&quot;params&quot;&gt;(BlockHookMode)&lt;/span&gt;mode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     usingBlock:&lt;span class=&quot;params&quot;&gt;(id)&lt;/span&gt;block&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;四种 hook 模式任你选择，可以对同一个 block 对象 hook 多次，但是要注意自己控制好顺序问题！hook 后会返回一个 &lt;code&gt;BHToken&lt;/code&gt; 对象，可以调用它的 &lt;code&gt;remove&lt;/code&gt; 方法来让 hook 失效。切记 &lt;code&gt;remove&lt;/code&gt; 的时候要按照 hook 时的逆序！（以后可以搞个栈优化下用户体验，暂时懒的弄）&lt;/p&gt;
&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;name&quot;&gt;super&lt;/span&gt; viewDidLoad]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Do any additional setup after loading the view, typically from a nib.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSObject *z = NSObject.new&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int (&lt;span class=&quot;name&quot;&gt;^block&lt;/span&gt;)(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt;, int) = ^(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; x, int y) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int result = x + y&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;%d + %d = %d, z is a NSObject: %p&quot;&lt;/span&gt;, x, y, result, z)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return result&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BHToken *tokenInstead = [&lt;span class=&quot;name&quot;&gt;block&lt;/span&gt; block_hookWithMode:BlockHookModeInstead usingBlock:^(&lt;span class=&quot;name&quot;&gt;BHToken&lt;/span&gt; *token, int x, int y)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;name&quot;&gt;token&lt;/span&gt; invokeOriginalBlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;let me see original result: %d&quot;&lt;/span&gt;, *(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; *)(&lt;span class=&quot;name&quot;&gt;token.retValue&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // change the block imp and result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   *(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; *)(&lt;span class=&quot;name&quot;&gt;token.retValue&lt;/span&gt;) = x * y&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hook instead: &#39;+&#39; -&amp;gt; &#39;*&#39;&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BHToken *tokenAfter = [&lt;span class=&quot;name&quot;&gt;block&lt;/span&gt; block_hookWithMode:BlockHookModeAfter usingBlock:^(&lt;span class=&quot;name&quot;&gt;BHToken&lt;/span&gt; *token, int x, int y)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // print args and result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hook after block! %d * %d = %d&quot;&lt;/span&gt;, x, y, *(&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt; *)(&lt;span class=&quot;name&quot;&gt;token.retValue&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BHToken *tokenBefore = [&lt;span class=&quot;name&quot;&gt;block&lt;/span&gt; block_hookWithMode:BlockHookModeBefore usingBlock:^(&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt; token)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // BHToken has to be the first arg.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hook before block! token:%@&quot;&lt;/span&gt;, token)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BHToken *tokenDead = [&lt;span class=&quot;name&quot;&gt;block&lt;/span&gt; block_hookWithMode:BlockHookModeDead usingBlock:^(&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt; token)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // BHToken is the only arg.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;block dead! token:%@&quot;&lt;/span&gt;, token)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(&lt;span class=&quot;name&quot;&gt;dispatch_get_global_queue&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hooked block&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int ret = block(&lt;span class=&quot;name&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;hooked result:%d&quot;&lt;/span&gt;, ret)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // remove all tokens when you don&lt;span class=&quot;symbol&quot;&gt;&#39;t&lt;/span&gt; need.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // reversed order of hook.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;name&quot;&gt;tokenBefore&lt;/span&gt; remove]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;name&quot;&gt;tokenAfter&lt;/span&gt; remove]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;name&quot;&gt;tokenInstead&lt;/span&gt; remove]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;remove tokens, original block&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ret = block(&lt;span class=&quot;name&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSLog(&lt;span class=&quot;name&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;original result:%d&quot;&lt;/span&gt;, ret)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        [&lt;span class=&quot;name&quot;&gt;tokenDead&lt;/span&gt; remove]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以通过设置 &lt;code&gt;BHToken&lt;/code&gt; 的 &lt;code&gt;retValue&lt;/code&gt; 属性来修改 block 的返回值。&lt;code&gt;usingBlock:&lt;/code&gt; 的参数内容是自定义的，跟 Aspects 一样，用户自己填上对应的参数列表。完整参数列表的内容就是 &lt;code&gt;BHToken&lt;/code&gt;（第一个参数）+ 原始 block 参数列表。看上面的例子应该很容易看懂。可以在 hook 的 block 中获取参数和修改返回值，打log，做些有(wei)趣(suo)的事情。&lt;/p&gt;
&lt;p&gt;上面代码执行后的 log 结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hooked block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hook before block! &lt;span class=&quot;string&quot;&gt;token:&lt;/span&gt;&amp;lt;&lt;span class=&quot;string&quot;&gt;BHToken:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x1d00f0d80&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, z is a &lt;span class=&quot;string&quot;&gt;NSObject:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x1d00172b0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let me see original &lt;span class=&quot;string&quot;&gt;result:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hook &lt;span class=&quot;string&quot;&gt;instead:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hook after block! &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hooked &lt;span class=&quot;string&quot;&gt;result:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remove tokens, original block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, z is a &lt;span class=&quot;string&quot;&gt;NSObject:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x1d00172b0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;original &lt;span class=&quot;string&quot;&gt;result:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block dead! &lt;span class=&quot;string&quot;&gt;token:&lt;/span&gt;&amp;lt;&lt;span class=&quot;string&quot;&gt;BHToken:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x1d00f9900&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;老铁稳。&lt;/p&gt;
&lt;p&gt;因为需要动态定义和运行函数，用到了 libffi，所以还需要引入对应架构的静态库，自己去官网下个编译好，在工程中引入 libffi.a 和包含头文件的 include 文件夹就行。示例程序 BlockHookSample 使用的是 arm64 架构。具体做法是在 Build Settings 中的 Other Link Flags 加入 libffi.a 的路径，在 Header Search Paths 加入 include 文件夹路径。&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;先说下大致思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据 block 对象的签名，使用 &lt;code&gt;ffi_prep_cif&lt;/code&gt; 构建 block-&amp;gt;invoke 函数的模板 &lt;code&gt;cif&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ffi_closure&lt;/code&gt;，根据 cif 动态定义函数 &lt;code&gt;replacementInvoke&lt;/code&gt;，并指定通用的实现函数为 &lt;code&gt;ClosureFunc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将 block-&amp;gt;invoke 替换为 &lt;code&gt;replacementInvoke&lt;/code&gt;，原始的 block-&amp;gt;invoke 存放在 &lt;code&gt;originInvoke&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;ClosureFunc&lt;/code&gt; 中动态调用 &lt;code&gt;originInvoke&lt;/code&gt; 函数和执行 hook 的逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对 libffi 的介绍和用法有很多文章可以参考，这里不再赘述。&lt;/p&gt;
&lt;p&gt;再整理下代码设计思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BHToken&lt;/code&gt;: 它实现了 hook 的逻辑，存储了相关的上下文。是最主要的类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSObject (BlockHook)&lt;/code&gt;: 提供 hook 的接口，每次 hook block 对象都会创建一个 &lt;code&gt;BHToken&lt;/code&gt;，并将其返回给用户。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BHCenter&lt;/code&gt; 管理 &lt;code&gt;BHToken&lt;/code&gt; 对象的中心，以后可以拓展更多玩法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面列举下 &lt;code&gt;BHToken&lt;/code&gt; 中几个比较重要的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;通过-Block-创建函数模板&quot;&gt;&lt;a href=&quot;#通过-Block-创建函数模板&quot; class=&quot;headerlink&quot; title=&quot;通过 Block 创建函数模板&quot;&gt;&lt;/a&gt;通过 Block 创建函数模板&lt;/h3&gt;&lt;p&gt;有关 Objective-C Block 内存模型这里不再赘述，Block ABI 可以在 &lt;a href=&quot;https://clang.llvm.org/docs/Block-ABI-Apple.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clang 文档&lt;/a&gt; 查到。根据 block 的 flag 位掩码计算偏移拿到 Type Encoding 签名 signature。&lt;code&gt;BHBlockTypeEncodeString()&lt;/code&gt; 函数实现了这些逻辑，代码不贴了。一个 block 的签名格式是：[返回值类型和偏移][@?0][参数0类型和偏移][参数1类型和偏移]…，比如 arm64 下 &lt;code&gt;int (^block)(int, int)&lt;/code&gt; 的签名是 &lt;code&gt;i16@?0i8i12&lt;/code&gt;。block 指针占 8 字节，参数和返回值 &lt;code&gt;int&lt;/code&gt; 都是 4 字节。&lt;/p&gt;
&lt;p&gt;然后需要把 signature 字符串处理分拆成参数类型列表，在 libffi 中使用 &lt;code&gt;ffi_type&lt;/code&gt; 表示各种类型。&lt;code&gt;_argsWithEncodeString:getCount:&lt;/code&gt; 方法会根据 Type Encoding 规则，将 signature 逐个字符处理，可以获取 &lt;code&gt;ffi_type *&lt;/code&gt; 参数（返回值）数组和参数个数。&lt;code&gt;_ffiArgForEncode:&lt;/code&gt; 方法负责将 Type Encoding 字符映射到对应的 &lt;code&gt;ffi_type&lt;/code&gt; 上，这是个很长的方法。&lt;/p&gt;
&lt;p&gt;有了参数类型列表，返回值类型，参数个数后，就可以调用 &lt;code&gt;ffi_prep_cif()&lt;/code&gt; 函数创建 &lt;code&gt;ffi_cif&lt;/code&gt; 了，也就是函数模板。&lt;code&gt;_prepCIF:withEncodeString:&lt;/code&gt; 方法实现了这个逻辑。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;_prepCIF:&lt;/span&gt;(ffi_cif *)cif &lt;span class=&quot;string&quot;&gt;withEncodeString:&lt;/span&gt;(const &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *)str&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ffi_type **argTypes = [self &lt;span class=&quot;string&quot;&gt;_argsWithEncodeString:&lt;/span&gt;str &lt;span class=&quot;string&quot;&gt;getCount:&lt;/span&gt;&amp;amp;argCount];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ffi_status status = ffi_prep_cif(cif, FFI_DEFAULT_ABI, argCount, [self &lt;span class=&quot;string&quot;&gt;_ffiArgForEncode:&lt;/span&gt; str], argTypes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(status != FFI_OK)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;Got result %ld from ffi_prep_cif&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)status);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        abort();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; argCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;创建闭包，替换-Block-的-invoke&quot;&gt;&lt;a href=&quot;#创建闭包，替换-Block-的-invoke&quot; class=&quot;headerlink&quot; title=&quot;创建闭包，替换 Block 的 invoke&quot;&gt;&lt;/a&gt;创建闭包，替换 Block 的 &lt;code&gt;invoke&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;可以使用函数模板（&lt;code&gt;ffi_cif&lt;/code&gt;）和一个函数指针（&lt;code&gt;replacementInvoke&lt;/code&gt;）创建闭包(&lt;code&gt;ffi_closure&lt;/code&gt;)。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_closure = ffi_closure_alloc(&lt;span class=&quot;name&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;name&quot;&gt;ffi_closure&lt;/span&gt;), &lt;span class=&quot;symbol&quot;&gt;&amp;amp;_replacementInvoke&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当 &lt;code&gt;replacementInvoke()&lt;/code&gt; 函数被调用时，绑定到闭包上的函数 &lt;code&gt;void BHFFIClosureFunc(ffi_cif *cif, void *ret, void **args, void *userdata)&lt;/code&gt; 会被调用。传给 &lt;code&gt;replacementInvoke()&lt;/code&gt; 的参数及其返回值都会被传给 &lt;code&gt;BHFFIClosureFunc()&lt;/code&gt;。&lt;code&gt;ffi_prep_closure_loc&lt;/code&gt; 函数的倒数第二个参数是 &lt;code&gt;user_data&lt;/code&gt;，也会被传给 &lt;code&gt;BHFFIClosureFunc()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)_prepClosure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ffi_status status = ffi_prep_closure_loc(_closure, &amp;amp;_cif, BHFFIClosureFunc, (__bridge void *)(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;), _replacementInvoke);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(status != FFI_OK)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;ffi_prep_closure returned %d&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)status);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        abort();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// exchange invoke func imp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _originInvoke = ((__bridge &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_BHBlock&lt;/span&gt;&lt;/span&gt; *)&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.block)-&amp;gt;invoke;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ((__bridge &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_BHBlock&lt;/span&gt;&lt;/span&gt; *)&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.block)-&amp;gt;invoke = _replacementInvoke;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将函数指针 &lt;code&gt;_replacementInvoke&lt;/code&gt; 和函数模板 &lt;code&gt;_cif&lt;/code&gt; 绑定函数闭包之后，需要将 block 的 &lt;code&gt;invoke&lt;/code&gt; 替换成 &lt;code&gt;_replacementInvoke&lt;/code&gt;，并把原始的实现存到 &lt;code&gt;_originInvoke&lt;/code&gt;。&lt;code&gt;invoke&lt;/code&gt; 函数的模板跟 block 的签名内容是一致的。&lt;/p&gt;
&lt;p&gt;这样当 block 调用时，实际上会调用 &lt;code&gt;_replacementInvoke&lt;/code&gt; 函数，进而调用 &lt;code&gt;BHFFIClosureFunc&lt;/code&gt; 通用函数。在这里面会实现 hook 的逻辑。&lt;/p&gt;
&lt;p&gt;还原 Hook 的 &lt;code&gt;remove&lt;/code&gt; 逻辑也很简单，将 &lt;code&gt;_originInvoke&lt;/code&gt; 恢复到 &lt;code&gt;invoke&lt;/code&gt; 即可：&lt;/p&gt;
&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;((__bridge struct _BHBlock *)self.block)&lt;/span&gt;-&amp;gt;&lt;/span&gt;invoke = _originInvoke;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;实现通用-Hook-函数&quot;&gt;&lt;a href=&quot;#实现通用-Hook-函数&quot; class=&quot;headerlink&quot; title=&quot;实现通用 Hook 函数&quot;&gt;&lt;/a&gt;实现通用 Hook 函数&lt;/h3&gt;&lt;p&gt;所有被 hook 的 block 调用时都会走到 &lt;code&gt;BHFFIClosureFunc&lt;/code&gt; 这里，可以拿到 block-&amp;gt;invoke 的函数模板，返回值指针，参数列表。还有自定义的 &lt;code&gt;userdata&lt;/code&gt;，传入的是 &lt;code&gt;BHToken&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ffi_call()&lt;/code&gt; 动态调用 block 的原始实现 &lt;code&gt;_originInvoke&lt;/code&gt;，并将参数列表和返回值指针传入。还需要传入函数模板，满足 Calling Convention。&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static void BHFFIClosureFunc(ffi_cif *cif, void *&lt;span class=&quot;keyword&quot;&gt;ret&lt;/span&gt;, void **&lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;, void *userdata)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BHToken *&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt; = (__bridge BHToken *)(userdata);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;.retValue = &lt;span class=&quot;keyword&quot;&gt;ret&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (BlockHookModeBefore == &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;.mode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt; invokeHookBlockWithArgs:&lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(BlockHookModeInstead == &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;.mode &amp;amp;&amp;amp; [&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt; invokeHookBlockWithArgs:&lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ffi_call(&amp;amp;&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;-&amp;gt;_cif, &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;-&amp;gt;_originInvoke, &lt;span class=&quot;keyword&quot;&gt;ret&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (BlockHookModeAfter == &lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt;.mode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;token&lt;/span&gt; invokeHookBlockWithArgs:&lt;span class=&quot;keyword&quot;&gt;args&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据 Hook mode，会在不同的时机调用 &lt;code&gt;invokeHookBlockWithArgs:&lt;/code&gt; 方法执行 hook 的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;组装-NSInvocation-执行-Hook-逻辑&quot;&gt;&lt;a href=&quot;#组装-NSInvocation-执行-Hook-逻辑&quot; class=&quot;headerlink&quot; title=&quot;组装 NSInvocation 执行 Hook 逻辑&quot;&gt;&lt;/a&gt;组装 &lt;code&gt;NSInvocation&lt;/code&gt; 执行 Hook 逻辑&lt;/h3&gt;&lt;p&gt;Hook 逻辑实现在 &lt;code&gt;self.hookBlock&lt;/code&gt; 中，被 Hook 的 block 是 &lt;code&gt;self.block&lt;/code&gt;，分别获取两者的签名，并拷贝后者的参数传给前者构造的 &lt;code&gt;blockInvocation&lt;/code&gt;。这里要注意 &lt;code&gt;self.hookBlock&lt;/code&gt; 的参数比 &lt;code&gt;self.block&lt;/code&gt; 多一个 &lt;code&gt;token&lt;/code&gt;，所以在二者参数比对和传递时需要特殊处理下。最后执行 &lt;code&gt;blockInvocation&lt;/code&gt;，即调用了 &lt;code&gt;usingBlock:&lt;/code&gt; 的参数。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)invokeHookBlockWithArgs:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; **)args&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.block || !&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.hookBlock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMethodSignature&lt;/span&gt; *hookBlockSignature = [&lt;span class=&quot;built_in&quot;&gt;NSMethodSignature&lt;/span&gt; signatureWithObjCTypes:BHBlockTypeEncodeString(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.hookBlock)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMethodSignature&lt;/span&gt; *originalBlockSignature = [&lt;span class=&quot;built_in&quot;&gt;NSMethodSignature&lt;/span&gt; signatureWithObjCTypes:BHBlockTypeEncodeString(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.block)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSInvocation&lt;/span&gt; *blockInvocation = [&lt;span class=&quot;built_in&quot;&gt;NSInvocation&lt;/span&gt; invocationWithMethodSignature:hookBlockSignature];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// origin block invoke func arguments: block(self), ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// hook block signature arguments: block(self), token, ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hookBlockSignature.numberOfArguments &amp;gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.numberOfArguments + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Block has too many arguments. Not calling %@&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hookBlockSignature.numberOfArguments &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [blockInvocation setArgument:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)&amp;amp;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; atIndex:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *argBuf = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; idx = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; idx &amp;lt; hookBlockSignature.numberOfArguments; idx++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *type = [originalBlockSignature getArgumentTypeAtIndex:idx - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; argSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSGetSizeAndAlignment&lt;/span&gt;(type, &amp;amp;argSize, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(argBuf = reallocf(argBuf, argSize))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Failed to allocate memory for block invocation.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        memcpy(argBuf, args[idx - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], argSize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [blockInvocation setArgument:argBuf atIndex:idx];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [blockInvocation invokeWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.hookBlock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (argBuf != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        free(argBuf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为用户传入的 &lt;code&gt;hookBlock&lt;/code&gt; 签名是不确定的，所以需要针对参数数量判断临界条件。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;又是大水文一篇，总算是在月末憋出来了。因为只花了一天时间写代码，实在太仓促，肯定还有一堆 bug。目前不建议用到生产环境上，辅助 debug 还是可以的，以后会慢慢优化。也欢迎各位老铁们提 PR：&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook/pulls&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/BlockHook/pulls&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码大量参考了 &lt;a href=&quot;https://github.com/mikeash/MABlockClosure&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MABlockClosure&lt;/a&gt; 的一些工具函数，API 设计上致敬 &lt;a href=&quot;https://github.com/steipete/Aspects&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Aspects&lt;/a&gt;。技术上如有疏漏，还请各位大佬们多多指教。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过参照 &lt;code&gt;MABlockClosure&lt;/code&gt; 的实现和 &lt;code&gt;Aspects&lt;/code&gt; 的 API 设计，基于 libffi 实现了对 Objective-C Block 的 hook。GitHub 地址：&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot;&gt;https://github.com/yulingtianxia/BlockHook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;什么场景下需要 hook block 呢？在有源码的情况下，大部分程序员会选择直接在 block 中插代码。假如方法 A 的入参是个 block 对象，方法 A 将 block 传给方法 B,C…等。如果只有方法 A 的源码，上层传入的 block 和下层方法实现都是黑盒的话，想追踪 block 调用的时机，打印些 log，就得 hook 这个 block 对象了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>How to make a Pebble watchface</title>
    <link href="http://yulingtianxia.com/blog/2018/01/15/How-to-make-a-Pebble-watchface/"/>
    <id>http://yulingtianxia.com/blog/2018/01/15/How-to-make-a-Pebble-watchface/</id>
    <published>2018-01-14T16:00:17.000Z</published>
    <updated>2018-01-14T15:22:23.743Z</updated>
    
    <content type="html">&lt;p&gt;之前的 leader 送了我一块 Pebble 智能手表，俗话说『穷玩车，富玩表』，希望自己能在 2018 年里『变有钱』，那就多玩玩表吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先简单介绍下 pebble。这个系列的智能手表虽然没有触屏，甚至有的型号是黑白背光屏，但提供了四个硕大的按钮用于上滚、下滚，进入和退出操作。它的数据传输需要依赖于手机的蓝牙连接，相当于一块副屏。但能在手表上独立运行 app，不像 watchOS 1 那样必须依赖手机上的 host app。其优势是续航性和性价比。pebble 曾一度跟安卓和 iOS 系统有三分天下之势，国外很多 geek 都喜欢搞搞 pebble。它甚至提供了云端编程环境，开发者很容易上手，查文档也十分便捷。经历一些固件升级后，开发语言也从 C 语言拓展到了 JS。 发布 app 的流程也很简单，geek 们可以在上面搞些有趣的事情了。&lt;/p&gt;
&lt;p&gt;你可以在 pebble 上安装各种 app，比如查看 evernote，玩一些小游戏。用户输入只有四个按钮，以及重力感应传感器、健康相关传感器等。功能上略差，但能续航一周。它也解决了大部分关于时间的刚需，比如定制表盘，接收通知，计时器等。&lt;/p&gt;
&lt;p&gt;出于对 pebble 的好奇以及感叹时间从自己身边流逝，时刻提醒自己把握当下珍惜每一秒，我做了一个简单有趣的 watchface。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Pebble-MoHa/blob/master/watchface.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;戴着黑框眼镜的程序员哥哥在手表中仿佛看到了自己，并时刻提醒着我们珍惜每一秒的光阴。pebble 以超长续航能力著称，于是我索性将电池电量一直显示满格，满足一切强迫症患者！同样以『超长待机』著称的英国女王伊丽莎白二世出生于 1926 年，有了来自女王的 buff 加持，你的 pebble 将会更持久更耐用！&lt;/p&gt;
&lt;p&gt;为了展现上面 GIF 的效果，我设置了个定时器每秒回调下面的函数：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; void update_time() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取当地时间戳&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  time_t temp = time(NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tm&lt;/span&gt;&lt;/span&gt; *tick_time = localtime(&amp;amp;temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 时间戳转字符串：时，分，显示到 label 上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; s_hour_buffer[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  strftime(s_hour_buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(s_hour_buffer), clock_is_24h_style() ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                          &lt;span class=&quot;string&quot;&gt;&quot;%H&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;%I&quot;&lt;/span&gt;, tick_time);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  text_layer_set_text(s_left_time_layer, s_hour_buffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; s_minute_buffer[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  strftime(s_minute_buffer, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(s_minute_buffer), &lt;span class=&quot;string&quot;&gt;&quot;%M&quot;&lt;/span&gt;, tick_time);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  text_layer_set_text(s_right_time_layer, s_minute_buffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 每隔一秒切换下显示状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (tick_time-&amp;gt;tm_sec % &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_eye_layer, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_left_time_layer, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_right_time_layer, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bitmap_layer_set_bitmap(s_nose_layer, s_nose_empty_bitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_eye_layer, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_left_time_layer, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer_set_hidden((Layer *)s_right_time_layer, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bitmap_layer_set_bitmap(s_nose_layer, s_nose_bitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 显示每日金句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *s_words[] = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;You Naive!&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;I&#39;m angry!&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;2 young 2 simple&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Wearing 3 watch&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Apply for Professor&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Excited!&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Sometimes naive!&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  text_layer_set_text(s_word_layer, s_words[tick_time-&amp;gt;tm_wday]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终实现的代码只有一百多行，GitHub 地址： &lt;a href=&quot;https://github.com/yulingtianxia/Pebble-MoHa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/Pebble-MoHa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里说几个开发时需要注意的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;显示带 alpha 通道的 png 图片时需要参照下&lt;a href=&quot;https://developer.pebble.com/blog/2015/05/13/tips-and-tricks-transparent-images/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇指引&lt;/a&gt;，我 P 图的时候干脆搞成不透明的了。&lt;/li&gt;
&lt;li&gt;位图无法缩放，但可以设置其在 &lt;code&gt;BitmapLayer&lt;/code&gt; 中的对齐策略。&lt;/li&gt;
&lt;li&gt;加载资源时需要加上 &lt;code&gt;RESOURCE_ID_&lt;/code&gt; 前缀。&lt;/li&gt;
&lt;li&gt;系统自带的字体并不是所有字号都有的，种类很有限。&lt;/li&gt;
&lt;li&gt;圆形手表的 &lt;code&gt;Window&lt;/code&gt; 的 &lt;code&gt;bounds.size&lt;/code&gt; 是外接矩形，有内建方法判断是否是圆形手表。&lt;/li&gt;
&lt;li&gt;真机调试需要打开手机上 Pebble 官方 App，打开开发者模式，开启开发者连接，保持蓝牙连接，让电脑与手机在同一个子网内。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我选择使用云端开发工具 &lt;a href=&quot;https://cloudpebble.net/ide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CloudPebble&lt;/a&gt; 而不是本地 sdk，主要是因为 CloudPebble 集成了一套创建和管理工程、托管代码和资源、在真机或模拟器编译运行、持续集成以及支持同步 GitHub 的开发环境。很适合初学者快速上手，敏捷开发。&lt;/p&gt;
&lt;p&gt;开发语言选择 C 语言，并不是为了装逼，也不是因为我不会 JS，而是因为 leader 送我的手表所支持固件最新版本目前为 v3.12.3，而使用 JS 开发需要依赖 Rocky.js，要求固件版本 v4.x。&lt;/p&gt;
&lt;p&gt;强烈建议看这篇&lt;a href=&quot;https://developer.pebble.com/tutorials/watchface-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方开发者教程&lt;/a&gt;来快速入门。不得不说 pebble 的开发者博客里无论是文档还是教程都很赞，就是有些 demo 的 github 连接失效了。不过按照教程一步步去做终归还是很容易搞定的。&lt;/p&gt;
&lt;p&gt;使用 &lt;a href=&quot;https://developer.pebble.com/docs/c/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pebble C SDK&lt;/a&gt; 的 API 时会用到各种功能的函数，监听回调也都是传入自定义函数指针。跟 UI 相关的 API 跟移动开发很类似，也会提供 &lt;code&gt;Window&lt;/code&gt;，&lt;code&gt;Layer&lt;/code&gt;，&lt;code&gt;GBitmap&lt;/code&gt; 等类型。因为不涉及到 UI 的点击，所以会简单很多。但要注意的是对象的生命周期，每次调用 xxx_create 方法一定要对应调用 xxx_destroy 方法。&lt;code&gt;Layer&lt;/code&gt; 有很多子类，比如 &lt;code&gt;TextLayer&lt;/code&gt;,&lt;code&gt;BitmapLayer&lt;/code&gt; 等。这些子类可以很方便地显示文字和图片等内容。对于这次我做的 watchface 来说，图片和文字已经够用了。构建 &lt;code&gt;Layer&lt;/code&gt; 的层级关系也很简单，比如用 &lt;code&gt;layer_add_child()&lt;/code&gt; 就能往一个 &lt;code&gt;Layer&lt;/code&gt; 上添加其他 &lt;code&gt;Layer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;目前 pebble 项目所支持的图片资源种类很少，且对二进制和资源大小均有限制。毕竟手表上能发挥的空间有限，所以将大部分逻辑放在手机上。通过蓝牙将数据传输给手表，手表上只负责展示一些比较及时的数据，做一些简单的操作同步数据给手机。所以 pebble 也提供了 iOS 和 Android 对应的 sdk。&lt;/p&gt;
&lt;p&gt;pebble 推出了好几款手表，所以一个项目对应的 target 也有五种之多。所幸的是 CloudPebble 的模拟器提供了这五种 target 的模拟器，在网页中编程也有较好的编程体验，支持高亮和查看文档。管理资源更是简单，每种 target 都提供预览。项目配置也都是可视化操作，十分容易上手。&lt;/p&gt;
&lt;p&gt;以上内容就是开发一款 pebble watchface 的基本法则，喜欢的话可以去主页点个赞：&lt;a href=&quot;https://apps.getpebble.com/applications/5a4b9bfc0dfc329496001b60&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://apps.getpebble.com/applications/5a4b9bfc0dfc329496001b60&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前的 leader 送了我一块 Pebble 智能手表，俗话说『穷玩车，富玩表』，希望自己能在 2018 年里『变有钱』，那就多玩玩表吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="瞎折腾" scheme="http://yulingtianxia.com/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Associated Object 与 Dealloc</title>
    <link href="http://yulingtianxia.com/blog/2017/12/15/Associated-Object-and-Dealloc/"/>
    <id>http://yulingtianxia.com/blog/2017/12/15/Associated-Object-and-Dealloc/</id>
    <published>2017-12-14T16:19:21.000Z</published>
    <updated>2017-12-14T16:19:38.963Z</updated>
    
    <content type="html">&lt;p&gt;我的 Objective-C 消息节流防抖库 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 需要实现一个特性：当 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;target&lt;/code&gt; 释放后，自动调用 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;discard&lt;/code&gt; 方法。后来使用了业界很早就已有的方案：Associated Object，在这里整理下相关的知识点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;问题的由来&quot;&gt;&lt;a href=&quot;#问题的由来&quot; class=&quot;headerlink&quot; title=&quot;问题的由来&quot;&gt;&lt;/a&gt;问题的由来&lt;/h2&gt;&lt;p&gt;起初的思路是考虑到 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;target&lt;/code&gt; 属性是 &lt;code&gt;weak&lt;/code&gt; 的，想在其释放之前，也就是 &lt;code&gt;target&lt;/code&gt; 变成 &lt;code&gt;nil&lt;/code&gt; 之前调用 &lt;code&gt;MTRule&lt;/code&gt; 对象的 &lt;code&gt;discard&lt;/code&gt;  方法。然而 &lt;code&gt;target&lt;/code&gt; 被释放赋值为 &lt;code&gt;nil&lt;/code&gt; 的操作并不能通过 KVO 之类来监听，因为其并不是在外部通过 set 方法，这涉及到 &lt;code&gt;weak&lt;/code&gt; 的实现原理（PS: 可以查看源码中 &lt;code&gt;weak_clear_no_lock()&lt;/code&gt; 函数的实现）。于是问题转而变成了『在对象销毁前得到通知』。&lt;/p&gt;
&lt;p&gt;接着我在 MacRumors 上找到了一篇 2005 年的&lt;a href=&quot;https://forums.macrumors.com/threads/getting-notified-when-an-object-instance-is-deallocated.976309/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;贴子&lt;/a&gt;。大概内容就是讲通过 KVO 监听 &lt;code&gt;retainCount&lt;/code&gt; 属性纯属失了智，众所周知 &lt;code&gt;retainCount&lt;/code&gt; 不能真实反映对象内存管理的情况，即便 &lt;code&gt;retainCount&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; 的时候收到了 &lt;code&gt;release&lt;/code&gt; 消息，也会直接 &lt;code&gt;dealloc&lt;/code&gt; 掉，并不会变成 &lt;code&gt;0&lt;/code&gt;。接着又有人说干脆 hook 下 &lt;code&gt;dealloc&lt;/code&gt; 方法，然后抛通知，但是这样不安全。直到 2008 年 DenNukem 回帖说他直到咋办啦，用 Associated Object！&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;当一个对象（Host）释放后，其关联的对象（Associated Object）也会被解除。可以在 Host 对象上添加 Associated Object，策略用 &lt;code&gt;OBJC_ASSOCIATION_RETAIN&lt;/code&gt;。由于只有 Host 持有了这个 Associated Object，当 Host 释放后 Associated Object 也会被释放。在 Associated Object 的 &lt;code&gt;dealloc&lt;/code&gt; 方法中告知外界其 Host 对象已经释放。Perfect！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;dealloc&lt;/code&gt; 方法的调用顺序是从子类到父类直至 &lt;code&gt;NSObject&lt;/code&gt; 的，&lt;code&gt;NSObject&lt;/code&gt; 的 &lt;code&gt;dealloc&lt;/code&gt; 会调用 &lt;code&gt;object_dispose()&lt;/code&gt; 函数，进而移除 Associated Object。&lt;/strong&gt;具体的实现如下:&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;object_dispose(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!obj) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 销毁对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_destructInstance(obj);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 释放内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    free(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *objc_destructInstance(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Read all of the flags at once for performance.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; cxx = obj-&amp;gt;hasCxxDtor();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; assoc = obj-&amp;gt;hasAssociatedObjects();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// This order is important.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// C++ 析构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cxx) object_cxxDestruct(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 移除 Associated Object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (assoc) _object_remove_assocations(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ARC 下调用实例变量的 release 方法，移除 weak 引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        obj-&amp;gt;clearDeallocating();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;也就是说 Associated Object 的 &lt;code&gt;dealloc&lt;/code&gt; 调用时 Host 已经释放了，无法拿到关于 Host 对象的任何信息了。但这其实对于大部分场景已经足够了，给外界一个 block/delegate callback，甚至是抛通知都 OK 的。&lt;/strong&gt;实现起来很简单，代码很少，网上也可以找到一些 &lt;a href=&quot;https://blog.slaunchaman.com/2011/04/11/fun-with-the-objective-c-runtime-run-code-at-deallocation-of-any-object/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MRC&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/ChenYilong/CYLDeallocBlockExecutor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ARC&lt;/a&gt; 下实现的示例代码。&lt;/p&gt;
&lt;p&gt;虽说 Runtime 帮我们自动移除了 Associated Object，但对我这种平常几乎一直写 MRC 代码的人来说还真有点不适应，毕竟脑子里时刻警惕着：每一次 &lt;code&gt;retain&lt;/code&gt; 都要配套来一次 &lt;code&gt;release&lt;/code&gt; 或 &lt;code&gt;autorelease&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;MessageThrottle-的特殊定制&quot;&gt;&lt;a href=&quot;#MessageThrottle-的特殊定制&quot; class=&quot;headerlink&quot; title=&quot;MessageThrottle 的特殊定制&quot;&gt;&lt;/a&gt;MessageThrottle 的特殊定制&lt;/h2&gt;&lt;p&gt;好，又回归到文章最开头的问题。现在解决了『&lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;target&lt;/code&gt; 释放后，自动调用 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;discard&lt;/code&gt; 方法』的问题。但是，要注意到此时 &lt;code&gt;target&lt;/code&gt; 属性都释放了，于是就无法提供 &lt;code&gt;discard&lt;/code&gt; 方法正确执行做需要的信息。所以需要在 Associated Object 中加入一些属性来保存一些执行 &lt;code&gt;discard&lt;/code&gt; 时所需必要的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;MTDealloc &lt;/span&gt;: NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这三个属性就是 discardRule:whenTargetDealloc: 方法将要用到的信息。这个方法会把 rule 从 MTEngine 列表中移除，并按需要还原之前的 hook 操作。这些细节不是重点，重点就是调用 discard 需要这仨属性。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic, weak) MTRule *rule;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic, copy) NSString *methodDescription;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic) Class cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@implementation&lt;/span&gt; MTDealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)dealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 我只是觉得这样写代码就没警告了，而且还骚&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL selector = NSSelectorFromString(@&quot;&lt;span class=&quot;attribute&quot;&gt;discardRule&lt;/span&gt;:&lt;span class=&quot;attribute&quot;&gt;whenTargetDealloc&lt;/span&gt;:&quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ((void (*)(id, SEL, MTRule *, MTDealloc *))&lt;span class=&quot;selector-attr&quot;&gt;[MTEngine.defaultEngine methodForSelector:selector]&lt;/span&gt;)(MTEngine.defaultEngine, selector, self.rule, self);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后只需要在 &lt;code&gt;applyRule&lt;/code&gt; 的时候初始化和配置好 &lt;code&gt;MTDealloc&lt;/code&gt; 对象，并将其关联到 &lt;code&gt;target&lt;/code&gt; 上即可：&lt;/p&gt;
&lt;figure class=&quot;highlight puppet&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// applyRule 时调用这个方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static void mt_configureTargetDealloc(MTRule *rule)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mt_object_isClass(rule.target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class cls = object_getClass(&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.&lt;span class=&quot;literal&quot;&gt;target&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MTDealloc *mtDealloc = objc_getAssociatedObject(&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.&lt;span class=&quot;literal&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!mtDealloc) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mtDealloc = [MTDealloc new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mtDealloc.&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mtDealloc.methodDescription = mt_methodDescription(&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.&lt;span class=&quot;literal&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mtDealloc.cls = cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            objc_setAssociatedObject(&lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.&lt;span class=&quot;literal&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;rule&lt;/span&gt;.selector, mtDealloc, OBJC_ASSOCIATION_RETAIN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用 &lt;code&gt;rule.selector&lt;/code&gt; 作为 Key 的目的就是让 &lt;code&gt;target&lt;/code&gt; 对象上的每一个方法都对应一个关联对象，不会搞混。&lt;/p&gt;
&lt;p&gt;感兴趣的可以查看 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 的源码，或者阅读我的上一篇文章 &lt;a href=&quot;http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/&quot;&gt;Objective-C Message Throttle and Debounce&lt;/a&gt;，更详细地讲述了 Objective-C 消息节流防抖的实现原理。这里只是对其实现自动 &lt;code&gt;discard&lt;/code&gt; 原理的补充。&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://forums.macrumors.com/threads/getting-notified-when-an-object-instance-is-deallocated.976309/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Getting notified when an object instance is deallocated&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.slaunchaman.com/2011/04/11/fun-with-the-objective-c-runtime-run-code-at-deallocation-of-any-object/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/10842829/will-an-associated-object-be-released-automatically/10843510#10843510&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Will An Associated Object Be Released Automatically?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ChenYilong/CYLDeallocBlockExecutor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CYLDeallocBlockExecutor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://opensource.apple.com/source/objc4/objc4-723/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc4-723&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我的 Objective-C 消息节流防抖库 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot;&gt;MessageThrottle&lt;/a&gt; 需要实现一个特性：当 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;target&lt;/code&gt; 释放后，自动调用 &lt;code&gt;MTRule&lt;/code&gt; 的 &lt;code&gt;discard&lt;/code&gt; 方法。后来使用了业界很早就已有的方案：Associated Object，在这里整理下相关的知识点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Message Throttle and Debounce</title>
    <link href="http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/"/>
    <id>http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/</id>
    <published>2017-11-04T16:39:44.000Z</published>
    <updated>2017-11-28T03:22:24.669Z</updated>
    
    <content type="html">&lt;p&gt;在实际项目中经常会遇到因方法调用频繁而导致的 UI 闪动问题和性能问题，这时用某种策略需要控制调用频率，以达到节流和防抖的效果。&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 是我实现的一个 Objective-C 消息节流和防抖的轻量级工具库，使用便捷且业务无关。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;读懂本文的前提是对 &lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot;&gt;Objective-C Runtime&lt;/a&gt; 和 &lt;a href=&quot;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&quot;&gt;Objective-C 消息发送与转发机制原理&lt;/a&gt;有一定了解。&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;函数节流（throttle）是一个很基础的概念，常常跟函数防抖（debounce）作比较。在处理连续事件时比较常用，可以通过&lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个 Demo&lt;/a&gt; 感受下二者区别。在 JS 中有较多的实现和应用案例，可以查看&lt;a href=&quot;https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt; 更直接地了解下。&lt;/p&gt;
&lt;p&gt;虽然在开发 iOS 和 macOS 的时候不用过多关心连续事件的采样问题，但有时也需要避免某个方法被频繁调用。比如一个很复杂的页面可能会频繁请求网络，每次回包都需更新界面，这时就需要防抖，控制刷新频率。&lt;/p&gt;
&lt;p&gt;在 Objective-C 中，方法调用其实就是消息发送，所以我改了个名字，叫消息节流和防抖。&lt;/p&gt;
&lt;h2 id=&quot;使用姿势&quot;&gt;&lt;a href=&quot;#使用姿势&quot; class=&quot;headerlink&quot; title=&quot;使用姿势&quot;&gt;&lt;/a&gt;使用姿势&lt;/h2&gt;&lt;p&gt;假如我创建了一个 &lt;code&gt;Stub&lt;/code&gt; 类的实例 &lt;code&gt;s&lt;/code&gt;，我想限制它调用 &lt;code&gt;foo:&lt;/code&gt; 方法的频率。先要创建并配置一个 &lt;code&gt;MTRule&lt;/code&gt;，并将规则应用到 &lt;code&gt;MTEngine&lt;/code&gt; 单例中：&lt;/p&gt;
&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stub *s = [Stub &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MTRule *rule = [MTRule &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rule.target = s; &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; You can also assign `&lt;span class=&quot;javascript&quot;&gt;Stub.class&lt;/span&gt;` &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; `&lt;span class=&quot;javascript&quot;&gt;mt_metaClass(Stub.class)&lt;/span&gt;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rule.selector = @selector(foo:);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rule.durationThreshold = &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[MTEngine.defaultEngine applyRule:rule]; &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; use `&lt;span class=&quot;javascript&quot;&gt;[rule apply]&lt;/span&gt;`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt; 可以是一个实例对象，也可以是一个类或元类。这样可以更灵活地控制限制策略，既可以只控制某个对象的消息发送频率，也可以控制某个类的实例方法和类方法的频率。当然，规则的 &lt;code&gt;target&lt;/code&gt; 为实例对象的优先级比类更高，也不会发生冲突。&lt;/p&gt;
&lt;p&gt;当然还有更简单的用法，跟上面那段代码作用相同：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[s &lt;span class=&quot;string&quot;&gt;limitSelector:&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;foo:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;oncePerDuration:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;// returns MTRule instance&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;无论是节流还是防抖，都需要设定一个时间 &lt;code&gt;durationThreshold&lt;/code&gt; 阈值来限制频率，都意味着方法在最后会延迟调用。&lt;code&gt;MTRule&lt;/code&gt; 默认的模式是 &lt;code&gt;MTPerformModeDebounce&lt;/code&gt;，也就是防抖模式，需要等消息不再连续频繁发送后才执行。&lt;code&gt;MTPerformModeLast&lt;/code&gt; 和 &lt;code&gt;MTPerformModeFirstly&lt;/code&gt; 对应着节流模式，也就是控制一定时间内只执行一次。区别在于前者执行的是这段时间内最后发送的消息，后者执行第一次发送的消息。&lt;/p&gt;
&lt;p&gt;比如我想要控制界面上某个 Label 内容的更新频率，给用户更好的体验，这时候很适合使用 &lt;code&gt;MTPerformModeLast&lt;/code&gt; 模式：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.mode = MTPerformModeLast;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然所有规则都是可以动态调整的，也就是在应用规则以后，依然可以改变 &lt;code&gt;MTRule&lt;/code&gt; 对象中各项配置，并会在下次消息发送时生效。如果调皮地将 &lt;code&gt;durationThreshold&lt;/code&gt; 改成非正数，那么等同于立即执行方法，不会限制频率。&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;MTPerformModeDebounce&lt;/code&gt; 和 &lt;code&gt;MTPerformModeLast&lt;/code&gt; 模式的时候，因为执行消息会有延迟，可以指定执行消息的队列 &lt;code&gt;messageQueue&lt;/code&gt;，默认为主队列。&lt;/p&gt;
&lt;p&gt;当想要废除某条规则时，使用一行代码即可：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[MTEngine.defaultEngine discardRule:&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;]; // &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; use `[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt; discard]`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;应用和废除规则都是线程安全的。&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;参照 &lt;a href=&quot;https://github.com/steipete/Aspects&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Aspects&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/bang590/JSPatch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSPatch&lt;/a&gt; 中 Hook 的原理，将限制频率逻辑嵌入消息转发流程中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给类添加一个新的方法 &lt;code&gt;fixed_selector&lt;/code&gt;，对应实现为 &lt;code&gt;rule.selector&lt;/code&gt; 的 &lt;code&gt;IMP&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;利用 &lt;a href=&quot;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&quot;&gt;Objective-C runtime 消息转发机制&lt;/a&gt;，将 &lt;code&gt;rule.selector&lt;/code&gt; 对应的 &lt;code&gt;IMP&lt;/code&gt; 改成 &lt;code&gt;_objc_msgForward&lt;/code&gt; 从而触发调用 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;forwardInvocation:&lt;/code&gt; 的实现替换为自己实现的 &lt;code&gt;IMP&lt;/code&gt;，并在自己实现的逻辑中将 &lt;code&gt;invocation.selector&lt;/code&gt; 设为 &lt;code&gt;fixed_selector&lt;/code&gt;。并限制 &lt;code&gt;[invocation invoke]&lt;/code&gt; 的调用频率。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种做法的缺陷是如果同时 hook 了基类和子类的同一个方法，且子类调用了基类的方法，就会导致循环调用。因为调用 &lt;code&gt;super&lt;/code&gt; 方法时，传入的 &lt;code&gt;target&lt;/code&gt; 还是 &lt;code&gt;self&lt;/code&gt; 对象，导致调用了子类的方法。好在这里并不允许同时 hook 一条继承链上的两个类，因为子类和基类限制频率的规则会相互干扰，导致不易发现的 bug。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 从设计上使用 &lt;code&gt;MTEngine&lt;/code&gt; 单例这种中心化的的方式来管理所有规则。Aspects 是将 hook 的上下文插入到对应的 &lt;code&gt;target&lt;/code&gt; 中，这样的好处是需要暴露的接口较少。而 &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MessageThrottle&lt;/a&gt; 需要提供当前所有的规则给使用方。因为方法调用频率的限制会影响其上游代码和下游代码的运行频率，所以中心化管理的做法很有必要。&lt;/p&gt;
&lt;p&gt;由于配置规则的内容较多，如果使用逐个传参的方式，方法名会很长。所以这里用 &lt;code&gt;MTRule&lt;/code&gt; 类封装了规则的上下文，并使用 &lt;code&gt;applyRule:&lt;/code&gt; 和 &lt;code&gt;discardRule:&lt;/code&gt; 方法应用和废除规则。&lt;/p&gt;
&lt;h3 id=&quot;管理-MTRule&quot;&gt;&lt;a href=&quot;#管理-MTRule&quot; class=&quot;headerlink&quot; title=&quot;管理 MTRule&quot;&gt;&lt;/a&gt;管理 &lt;code&gt;MTRule&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;MTEngine&lt;/code&gt; 内部使用键值对存取 &lt;code&gt;MTRule&lt;/code&gt;，这里使用 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;selector&lt;/code&gt; 的组合值作为 key。这里只要保证唯一性即可区分不同的规则，格式不固定：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * mt_methodDescription(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; target, SEL selector)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *selectorName = &lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (object_isClass(target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *className = &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;(target);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;%@ [%@ %@]&quot;&lt;/span&gt;, class_isMetaClass(target) ? &lt;span class=&quot;string&quot;&gt;@&quot;+&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;-&quot;&lt;/span&gt;, className, selectorName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;[%p %@]&quot;&lt;/span&gt;, target, selectorName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在应用和废除规则的时候，需要检查规则合法性。这里只是简单检查下库中涉及的类和方法，一些内存管理和runtime 的方法并没有做限制，毕竟用户想作死我也管不着：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; mt_checkRuleValid(MTRule *rule)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rule.target &amp;amp;&amp;amp; rule.selector &amp;amp;&amp;amp; rule.durationThreshold &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *selectorName = &lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(rule.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([selectorName isEqualToString:&lt;span class=&quot;string&quot;&gt;@&quot;forwardInvocation:&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (object_isClass(rule.target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cls = rule.target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cls = object_getClass(rule.target);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *className = &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([className isEqualToString:&lt;span class=&quot;string&quot;&gt;@&quot;MTRule&quot;&lt;/span&gt;] || [className isEqualToString:&lt;span class=&quot;string&quot;&gt;@&quot;MTEngine&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;处理-NSInvocation&quot;&gt;&lt;a href=&quot;#处理-NSInvocation&quot; class=&quot;headerlink&quot; title=&quot;处理 NSInvocation&quot;&gt;&lt;/a&gt;处理 &lt;code&gt;NSInvocation&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;在进入到消息转发流程调用 &lt;code&gt;forwardInvocation:&lt;/code&gt; 方法时会进入到自定义的处理逻辑中，然后决定是否执行 &lt;code&gt;[invocation invoke]&lt;/code&gt;。之前已经将原始 &lt;code&gt;selector&lt;/code&gt; 的 IMP 替换成了 &lt;code&gt;fixedSelector&lt;/code&gt;，所以调用 &lt;code&gt;[invocation invoke]&lt;/code&gt; 之前需要调用 &lt;code&gt;invocation.selector = fixedSelector&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面的函数就是处理 &lt;code&gt;NSInvocation&lt;/code&gt; 对象的逻辑。先用 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;selector&lt;/code&gt; 获取 &lt;code&gt;MTRule&lt;/code&gt; 对象，进而根据不同的 &lt;code&gt;mode&lt;/code&gt; 采取不同的策略。如果 &lt;code&gt;durationThreshold&lt;/code&gt; 非正数就立即执行方法。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; mt_handleInvocation(&lt;span class=&quot;built_in&quot;&gt;NSInvocation&lt;/span&gt; *invocation, SEL fixedSelector)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *methodDescriptionForInstance = mt_methodDescription(invocation.target, invocation.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *methodDescriptionForClass = mt_methodDescription(object_getClass(invocation.target), invocation.selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MTRule *rule = MTEngine.defaultEngine.rules[methodDescriptionForInstance];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!rule) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rule = MTEngine.defaultEngine.rules[methodDescriptionForClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rule.durationThreshold &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [invocation setSelector:fixedSelector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [invocation invoke];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSTimeInterval&lt;/span&gt; now = [[&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; date] timeIntervalSince1970];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (rule.mode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; MTPerformModeFirstly:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; MTPerformModeLast:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; MTPerformModeDebounce:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码省略了不同 &lt;code&gt;mode&lt;/code&gt; 的处理逻辑，下面会逐个讲解。&lt;/p&gt;
&lt;h4 id=&quot;MTPerformModeFirstly&quot;&gt;&lt;a href=&quot;#MTPerformModeFirstly&quot; class=&quot;headerlink&quot; title=&quot;MTPerformModeFirstly&quot;&gt;&lt;/a&gt;&lt;code&gt;MTPerformModeFirstly&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;MTModePerformFirstly&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start                                                                end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                           durationThreshold                          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@-------------------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@---------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------------&lt;/span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                         |          |               |          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;perform immediately       ignore     ignore          ignore&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最简单粗暴的实现方式，忽略第一次发送消息之后 &lt;code&gt;durationThreshold&lt;/code&gt; 时间段内的所有消息。&lt;/p&gt;
&lt;figure class=&quot;highlight inform7&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (now - &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastTimeRequest &amp;gt; &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.durationThreshold) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastTimeRequest = now;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	invocation.selector = fixedSelector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;[invocation invoke]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;MTPerformModeLast&quot;&gt;&lt;a href=&quot;#MTPerformModeLast&quot; class=&quot;headerlink&quot; title=&quot;MTPerformModeLast&quot;&gt;&lt;/a&gt;&lt;code&gt;MTPerformModeLast&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;MTModePerformLast&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start                                                                end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                           durationThreshold                          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@-------------------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@---------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------------&lt;/span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                         |          |               |          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ignore                    ignore     ignore          will perform at end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;durationThreshold&lt;/code&gt; 时间内不断更新 &lt;code&gt;lastInvocation&lt;/code&gt; 的值，并在达到阈值 &lt;code&gt;durationThreshold&lt;/code&gt; 后执行 &lt;code&gt;[lastInvocation invoke]&lt;/code&gt;。这样保证了执行的是最后一次发送的消息。需要注意的是，&lt;code&gt;NSInvocation&lt;/code&gt; 对象默认不会持有参数，在异步延迟执行 &lt;code&gt;invoke&lt;/code&gt; 的时候参数可能已经被释放了，进而野指针 crash。所以需要调用 &lt;code&gt;retainArguments&lt;/code&gt; 方法提前持有参数，防止之后被释放掉。如果实际传入的参数与参数类型不符，可能导致 &lt;code&gt;retainArguments&lt;/code&gt; 方法 crash。我曾想过将参数列表保存到一个 &lt;code&gt;NSArray&lt;/code&gt; 里，然后放到 &lt;code&gt;MTRule&lt;/code&gt; 中，这样可以对参数类型做判断，避免 crash，也顺便持有了参数列表。但发现需要覆盖的类型太多，工作量和风险更多。我把这个半成品代码放在了 GitHubGist 上: &lt;a href=&quot;https://gist.github.com/yulingtianxia/1518fc7604ed65aa4ca98abdeee974e1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ConvertInvocationArguments.m&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (now - &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastTimeRequest &amp;gt; &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.durationThreshold) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastTimeRequest = now;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.durationThreshold * NSEC_PER_SEC)), &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.messageQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation invoke];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	invocation.selector = fixedSelector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = invocation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation retainArguments];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;MTPerformModeDebounce&quot;&gt;&lt;a href=&quot;#MTPerformModeDebounce&quot; class=&quot;headerlink&quot; title=&quot;MTPerformModeDebounce&quot;&gt;&lt;/a&gt;&lt;code&gt;MTPerformModeDebounce&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;MTModePerformDebounce&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start                                        end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|           durationThreshold(old)             |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@----------------------&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;@----------------------&lt;/span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                      |                 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ignore                 will perform at end of new duration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       |---------------------------------------------&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       |           durationThreshold(new)             |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       start                                        end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然流程看上去复杂但其实实现起来也很简单。每次发送消息完再过 &lt;code&gt;durationThreshold&lt;/code&gt; 时间后，检查下 &lt;code&gt;lastInvocation&lt;/code&gt; 有没有变化。如果无变化，则说明这段时间内没有新的消息发送，则可以执行 &lt;code&gt;lastInvocation&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;invocation.selector = fixedSelector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = invocation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation retainArguments];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.durationThreshold * NSEC_PER_SEC)), &lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.messageQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation == invocation) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		[&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation invoke];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;rule&lt;/span&gt;.lastInvocation = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;规则的应用与废除&quot;&gt;&lt;a href=&quot;#规则的应用与废除&quot; class=&quot;headerlink&quot; title=&quot;规则的应用与废除&quot;&gt;&lt;/a&gt;规则的应用与废除&lt;/h3&gt;&lt;p&gt;在真正应用规则之前，需要检查下规则合法性，然后检查继承链上是否已经应用过规则了。如果有，则需要输出错误信息；否则应用规则。这里使用 POSIX 的互斥锁保证线程安全。&lt;code&gt;mt_overrideMethod()&lt;/code&gt; 函数所作的事情就是开始提到的利用消息转发流程 hook 的三个步骤。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;BOOL)applyRule:(MTRule &lt;/span&gt;*)rule&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block &lt;span class=&quot;keyword&quot;&gt;BOOL &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;shouldApply &lt;/span&gt;= YES&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mt_checkRuleValid(rule)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.rules enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, MTRule * _Nonnull obj, &lt;span class=&quot;keyword&quot;&gt;BOOL &lt;/span&gt;* _Nonnull stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (rule.selector == obj.selector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;amp;&amp;amp; object_isClass(rule.target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;amp;&amp;amp; object_isClass(obj.target)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Class clsA = rule.target&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Class clsB = obj.target&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;shouldApply &lt;/span&gt;= !([clsA isSubclassOfClass:clsB] &lt;span class=&quot;title&quot;&gt;||&lt;/span&gt; [clsB isSubclassOfClass:clsA])&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                *stop = &lt;span class=&quot;keyword&quot;&gt;shouldApply;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;                NSString *errorDescription = [NSString stringWithFormat:@&lt;span class=&quot;string&quot;&gt;&quot;Error: %@ already apply rule in %@. A message can only have one throttle per class hierarchy.&quot;&lt;/span&gt;, NSStringFromSelector(obj.selector), NSStringFromClass(clsB)]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;%@&quot;&lt;/span&gt;, errorDescription)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (&lt;span class=&quot;keyword&quot;&gt;shouldApply) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.rules[mt_methodDescription(rule.target, rule.selector)] = rule&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mt_overrideMethod(rule.target, rule.selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;keyword&quot;&gt;shouldApply;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;废除规则是执行相反的操作。如果 &lt;code&gt;target&lt;/code&gt; 是个实例对象，&lt;code&gt;mt_recoverMethod()&lt;/code&gt; 函数会判断是否有相同 &lt;code&gt;selector&lt;/code&gt; 且 &lt;code&gt;target&lt;/code&gt; 为这个实例对象的类的其他规则。如果有，那将不会移除 hook。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;BOOL)discardRule:(MTRule &lt;/span&gt;*)rule&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;BOOL &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;shouldDiscard &lt;/span&gt;= NO&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (mt_checkRuleValid(rule)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSString *description = mt_methodDescription(rule.target, rule.selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;shouldDiscard &lt;/span&gt;= self.rules[description] != nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (&lt;span class=&quot;keyword&quot;&gt;shouldDiscard) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.rules[description] = nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mt_recoverMethod(rule.target, rule.selector)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;keyword&quot;&gt;shouldDiscard;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h2&gt;&lt;p&gt;其实在开发过程中遇到需要限制方法调用频率的场景并不多，只是最近恰巧连续碰到几个刷新 UI 过频繁的问题，才想到应该去造个轮子。因为时间仓促，肯定还有考虑不周和一些 bug，待投入使用后慢慢完善和修复。&lt;/p&gt;
&lt;p&gt;其实想在某个特定函数做节流很简单，但每次都需要做重复劳动，写脏代码，还不如抽象出一个工具类出来。尽量造与业务无关的轮子，锻炼技术，也受益整个业务发展。&lt;/p&gt;
&lt;p&gt;好，装逼到此为止。Github : &lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yulingtianxia/MessageThrottle&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在实际项目中经常会遇到因方法调用频繁而导致的 UI 闪动问题和性能问题，这时用某种策略需要控制调用频率，以达到节流和防抖的效果。&lt;a href=&quot;https://github.com/yulingtianxia/MessageThrottle&quot;&gt;MessageThrottle&lt;/a&gt; 是我实现的一个 Objective-C 消息节流和防抖的轻量级工具库，使用便捷且业务无关。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
      <category term="Message Forwarding" scheme="http://yulingtianxia.com/tags/Message-Forwarding/"/>
    
  </entry>
  
  <entry>
    <title>Threading Programming Guide(3)</title>
    <link href="http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/"/>
    <id>http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/</id>
    <published>2017-10-08T09:03:54.000Z</published>
    <updated>2017-10-10T16:02:37.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第三部分。关于同步的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/&quot;&gt;Threading Programming Guide(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/&quot;&gt;Threading Programming Guide(2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;同步&lt;/h2&gt;&lt;p&gt;两个线程同时修改同一个资源可能会不小心干扰到对方，多线程存取资源带来了潜在的线程安全问题。比如，一个线程可能会覆盖了另一个线程的修改，或者使应用置于未知混乱状态。如果幸运的话，错乱的资源可能会导致明显的性能问题或 crash 这类相对容易复现和解决的 bug；如果不太走运，面临的就是短时间难以重现的 bug 和对代码的全面排查。&lt;/p&gt;
&lt;p&gt;为了线程安全，要尽量避免共享资源并减少线程间交互。即便有必须交互的地方，也需要使用同步工具来确保安全。&lt;/p&gt;
&lt;p&gt;macOS 和 iOS 提供了许多同步工具，范围涵盖互斥操作工具到应用中的序列化事件。下面会介绍这些工具的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;同步工具&quot;&gt;&lt;a href=&quot;#同步工具&quot; class=&quot;headerlink&quot; title=&quot;同步工具&quot;&gt;&lt;/a&gt;同步工具&lt;/h3&gt;&lt;p&gt;完全避免同步问题是理想方案，但并不现实。下面介绍几类基本的同步工具。&lt;/p&gt;
&lt;h4 id=&quot;原子操作&quot;&gt;&lt;a href=&quot;#原子操作&quot; class=&quot;headerlink&quot; title=&quot;原子操作&quot;&gt;&lt;/a&gt;原子操作&lt;/h4&gt;&lt;p&gt;原子操作是对简单数据类型同步的一种简易形式。优点是不会阻塞竞争的线程。对于简单的操作，比如增加计数器变量的值，原子操作比锁拥有更好的性能。&lt;/p&gt;
&lt;p&gt;macOS 和 iOS 包含许多基本的数学和逻辑运算的操作，可以在 32 位和 64 位上执行。其中就有 compare-and-swap, test-and-set 和 test-and-clear 操作的原子版本。 详见 &lt;code&gt;/usr/include/libkern/OSAtomic.h&lt;/code&gt; 头文件，或 &lt;code&gt;atomic&lt;/code&gt; man page。&lt;/p&gt;
&lt;h4 id=&quot;内存屏障和-Volatile-变量&quot;&gt;&lt;a href=&quot;#内存屏障和-Volatile-变量&quot; class=&quot;headerlink&quot; title=&quot;内存屏障和 Volatile 变量&quot;&gt;&lt;/a&gt;内存屏障和 &lt;code&gt;Volatile&lt;/code&gt; 变量&lt;/h4&gt;&lt;p&gt;编译器为了让性能达到最佳，会经常重排序汇编指令，这就有可能导致存取内存的顺序跟着变化，进而产生错误数据，影响到一些看似各自独立的变量。由于编译器优化造成对变量错误的更新顺序，产生了潜在的错误结果。&lt;/p&gt;
&lt;p&gt;内存屏障（Memory Barrier）是一种非阻塞的同步工具，用来确保以正确的顺序操作内存。Memory Barrier 就像栅栏一样，强制处理器在栅栏之前的所有读写操作都执行后才可以开始执行栅栏之后的操作。内存屏障知识详见维基百科 &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_barrier&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Memory Barrier&lt;/a&gt;。可以在代码中调用 &lt;code&gt;OSMemoryBarrier&lt;/code&gt; 函数添加内存屏障，详见 &lt;code&gt;OSMemoryBarrier&lt;/code&gt; man page。&lt;/p&gt;
&lt;p&gt;Volatile 关键字对单独的变量应用了另一种内存约束。编译器为了优化代码，会将变量的值加载到寄存器中。对于局部变量这没毛病，如果这个变量由别的线程更新了的话，将出现不一致的现象。Volatile 关键字可以用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。 如果一个变量可能在任何时候被外部资源修改，而编译器可能无法察觉，那么可以将其声明为 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Volatile变量&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;volatile 变量&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;由于内存屏障和 volatile 变量都降低了编译器对代码的优化，除非万不得已，需慎用。&lt;/p&gt;
&lt;h4 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h4&gt;&lt;p&gt;锁是最常用的同步工具之一，可以用它保护代码中的临界区域（critical section）。临界区域中的代码只允许同时被一个线程访问。其他线程对这块代码的修改都会被拒绝，因为会影响其正确性。&lt;/p&gt;
&lt;p&gt;下表列出了程序员最常用的一些锁。macOS 和 iOS 提供了大部分锁的实现，那些没实现的锁也会有说明。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;锁&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mutex&lt;/td&gt;
&lt;td&gt;互斥锁（Mutual exclusion，缩写Mutex）是多线程编程中一种对资源的保护机制，避免多个线程同时访问。如果互斥锁正在使用，其他线程需要等到它被释放后才能获取到。在同一时间只能有一个线程使用互斥锁。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Recursive lock&lt;/td&gt;
&lt;td&gt;也叫重入锁或递归锁，是互斥锁的变种。重入锁允许同一条线程多次获得同一个锁，但也释放锁时也要释放对应的次数。重入锁主要用于递归程序或者多个方法都需要获得锁的场景。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Read-write lock&lt;/td&gt;
&lt;td&gt;读写锁可以认为是一种共享版的互斥锁。如果对一个临界区大部分是读操作而只有少量的写操作，在大规模操作上应用读写锁可以显著降低线程互斥产生的代价。正常操作数据时，可以同时有多个读操作。线程想要做写操作时，需要等到所有的读操作完成并释放锁之后，然后写操作会获取锁并更新数据。在写操作线程阻塞等待锁被释放时，新来的读操作线程在写操作完成前会一直阻塞。系统只支持 POSIX 线程中使用读写锁。关于如何使用这些锁，详见 &lt;code&gt;pthread&lt;/code&gt; man page。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Distributed lock&lt;/td&gt;
&lt;td&gt;提供进程级别的互斥锁，但并不会真的阻塞进程，只是简单地向进程汇报锁正被占用，并让进程自己决定如何处理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spin lock&lt;/td&gt;
&lt;td&gt;自旋锁会重复查询锁的条件，直到为 true。因为自旋锁属于在『死等』，它最常用在多核处理器系统上，且锁的等待时间很短，时间短到轮询比阻塞线程的开销还小（因为需要阻塞线程切换上下文和更新线程数据结构）。因为它的轮询性质，系统没有提供自旋锁的任何实现，在特定场景下可以自己实现。内核中实现自旋锁详见 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kernel Programming Guide&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Double-checked lock&lt;/td&gt;
&lt;td&gt;双重检查锁试图减少并发系统中竞争和同步的开销。由于双重检查锁潜在地不安全性，系统不提供直接支持，不鼓励使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意：大部分的锁也会纳入内存屏障来确保进入临界区域前的加载和存储指令已经完成。&lt;/p&gt;
&lt;h4 id=&quot;条件变量&quot;&gt;&lt;a href=&quot;#条件变量&quot; class=&quot;headerlink&quot; title=&quot;条件变量&quot;&gt;&lt;/a&gt;条件变量&lt;/h4&gt;&lt;p&gt;Condition 是信号量的另一种类型，它允许线程在某个条件为 true 的时候，向其他线程发信号（signal）。通常用于标示资源的可用性或确保任务以特定的顺序执行。在进入临界区域时如果检查条件变量不为 true，线程会一直阻塞，直到某个其他线程 signal。与互斥锁的不同点在于 condition 允许被多个线程同时访问，它更像是个用某个特定标准筛查线程的门卫。&lt;/p&gt;
&lt;p&gt;一种使用场景是管理即将发生的事件池。当队列中有事件到来时，使用条件变量对发信号（signal）。于是一个被唤醒的线程就可以从队列中获取并处理事件。如果有两个事件大致同时到达队列，会对 condition 发两次信号唤醒两个线程。&lt;/p&gt;
&lt;p&gt;系统用几种不同的技术对 condition 提供支持。写这块代码需要谨慎，后面会给出示例。&lt;/p&gt;
&lt;h4 id=&quot;Perform-Selector&quot;&gt;&lt;a href=&quot;#Perform-Selector&quot; class=&quot;headerlink&quot; title=&quot;Perform Selector&quot;&gt;&lt;/a&gt;Perform Selector&lt;/h4&gt;&lt;p&gt;Cocoa 提供了向一个活跃线程异步分发消息的便捷方式，也就是 &lt;code&gt;NSObject&lt;/code&gt; 类的 &lt;code&gt;performSelector...&lt;/code&gt; 系列方法。使用这些方法向线程发送的执行 &lt;code&gt;selector&lt;/code&gt; 的请求会被目标线程的 run loop 按接收顺序执行。&lt;/p&gt;
&lt;p&gt;详见 &lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/#Cocoa-Perform-Selector-Sources&quot;&gt;Cocoa Perform Selector Sources&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;同步开销与性能&quot;&gt;&lt;a href=&quot;#同步开销与性能&quot; class=&quot;headerlink&quot; title=&quot;同步开销与性能&quot;&gt;&lt;/a&gt;同步开销与性能&lt;/h3&gt;&lt;p&gt;同步机制在帮助确保代码正确性的同时也造成了性能代价。即便没有竞争，使用同步工具也会引发延迟。锁和原子操作为了确保充分保护代码，通常会需要使用内存屏障和内核级同步。如果存在对锁的竞争，线程会阻塞，经历甚至更久的延迟。&lt;/p&gt;
&lt;p&gt;下表列出了非竞争场景下互斥锁和原子操作的一些大致开销。这些测量值取自几千个样本的均值。时间开销会随着处理器负荷、计算机速度以及系统程序的可用内存数量产生巨幅波动。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;大约的开销&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mutex acquisition time&lt;/td&gt;
&lt;td&gt;大约 0.2 ms&lt;/td&gt;
&lt;td&gt;无竞争场景下获取锁的时间。如果锁已经被其他线程持有，获取锁的耗时还会更长。结果取自对均值和中位数的分析，运行系统为 macOS 10.5，配备基于Intel 2 GHz Core Duo 处理器和 1 GB RAM 的 iMac。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Atomic compare-and-swap&lt;/td&gt;
&lt;td&gt;大约 0.05 ms&lt;/td&gt;
&lt;td&gt;无竞争场景下的 compare-and-swap 时间。运行环境同上。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;设计并发任务的时候，最重要的因素永远是正确性，但是也应该考虑到性能因素。总不能一味追求正确性而导致多线程执行的代码比单线程还慢吧。&lt;/p&gt;
&lt;p&gt;如果是在单线程应用的基础上进行多线程的改装，应该分别测量下关键任务在单线程和多线程下执行的性能，比对结果后再决定是否使用多线程。&lt;/p&gt;
&lt;p&gt;关于性能和指标采集工具详见 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Performance Overview&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程安全和信号&quot;&gt;&lt;a href=&quot;#线程安全和信号&quot; class=&quot;headerlink&quot; title=&quot;线程安全和信号&quot;&gt;&lt;/a&gt;线程安全和信号&lt;/h3&gt;&lt;p&gt;信号(Signal) 是一种底层 BSD 机制，用于向进程传递信息或以某种方式操作进程。有些程序使用信号来监测某些事件，比如子进程终止。系统使用信号来终止失控的进程和传达其他类型的信息。&lt;/p&gt;
&lt;p&gt;在多线程应用中，信号可能被发送到任何线程。所以实现 signal handler 的首要原则就是不要假定handler 会运行在某个特定线程。也就是说，假如在 A 线程设置 signal handler，信号被发送到 B 线程，A 和 B 不一定相同。&lt;/p&gt;
&lt;p&gt;设置 signal handler 的细节可以查看 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;sigaction&lt;/code&gt; man page。&lt;/p&gt;
&lt;h3 id=&quot;线程安全设计技巧&quot;&gt;&lt;a href=&quot;#线程安全设计技巧&quot; class=&quot;headerlink&quot; title=&quot;线程安全设计技巧&quot;&gt;&lt;/a&gt;线程安全设计技巧&lt;/h3&gt;&lt;p&gt;同步工具是把双刃剑，能让代码线程安全，但使用过多也会带来性能问题。能平衡好二者利弊靠的是经验，下面会提供一些技巧。&lt;/p&gt;
&lt;h4 id=&quot;完全避免同步&quot;&gt;&lt;a href=&quot;#完全避免同步&quot; class=&quot;headerlink&quot; title=&quot;完全避免同步&quot;&gt;&lt;/a&gt;完全避免同步&lt;/h4&gt;&lt;p&gt;最佳解决方案是从代码和数据结构设计上避免需要同步。同步工具很管用但也影响性能，能从设计根源上避免当然是最好的了。比如实现并发的时候要减少任务之间的相互作用和依赖。如果每个任务都在自己的私有数据集上操作，就不需要使用锁保护数据了。即便在两个任务共享一分公共数据集的情况下，可以考虑分割数据集或为每个任务提供一份数据拷贝。当然拷贝数据集也会有成本，这就需要提前权衡下拷贝成本高还是同步成本高。&lt;/p&gt;
&lt;h4 id=&quot;理解同步的限制&quot;&gt;&lt;a href=&quot;#理解同步的限制&quot; class=&quot;headerlink&quot; title=&quot;理解同步的限制&quot;&gt;&lt;/a&gt;理解同步的限制&lt;/h4&gt;&lt;p&gt;同步工具只有在应用中所有线程都持续使用才能生效。如果创建了互斥锁来限制对某个资源的存取，那么所有线程在试图操作此资源前都必须获得这个的互斥锁。如果做不到这些，互斥锁提供的保护就会失效，这是程序员的错。&lt;/p&gt;
&lt;h4 id=&quot;清楚代码正确性的风险&quot;&gt;&lt;a href=&quot;#清楚代码正确性的风险&quot; class=&quot;headerlink&quot; title=&quot;清楚代码正确性的风险&quot;&gt;&lt;/a&gt;清楚代码正确性的风险&lt;/h4&gt;&lt;p&gt;使用锁和内存屏障时需要认真些，要在代码中加对地方才行。你甚至觉得自己加锁的地方是对的，其实只是错觉。下面一系列例子试图阐述这个问题。表面上看似没毛病的代码，也能挑出瑕疵。基础假设是有一个可变数组，包含了一组不可变的对象。如果想要执行数组中第一个对象的方法，可以用下面代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSLock* arrayLock = GetArrayLock()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray* myArray = GetSharedArray()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id anObject&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock lock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anObject = [myArray objectAtIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock unlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject doSomething]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为数组是可变的，在获取数组第一个元素之前，锁会阻止其他线程修改数组。又因为元素对象本身是不可变的，不用对 &lt;code&gt;doSomething&lt;/code&gt; 方法加锁。&lt;/p&gt;
&lt;p&gt;不过上面的例子存在问题：在锁释放后 &lt;code&gt;doSomething&lt;/code&gt; 执行前，如果另一个线程将数组中所有对象都移除会发生什么呢？&lt;code&gt;anObject&lt;/code&gt; 野指针！解决问题的办法也很简单，重新整理下代码顺序，在 &lt;code&gt;doSomething&lt;/code&gt; 执行后再释放锁：&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSLock* arrayLock = GetArrayLock()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray* myArray = GetSharedArray()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id anObject&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock lock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anObject = [myArray objectAtIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject doSomething]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock unlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把调用 &lt;code&gt;doSomething&lt;/code&gt; 的代码挪到锁里面保证了对象依然有效，但如果 &lt;code&gt;doSomething&lt;/code&gt; 执行时间过长又会导致锁也会被占用很久，造成性能瓶颈。&lt;/p&gt;
&lt;p&gt;代码的毛病不是临界区域不清晰，真正的问题在于其他线程插了一脚触发的内存管理问题。因为其他线程释放了 &lt;code&gt;anObject&lt;/code&gt;，更好的解决方案是在锁释放前 &lt;code&gt;retain&lt;/code&gt; 它。此解决方案不仅对症下药，而且无潜在的性能问题。&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSLock* arrayLock = GetArrayLock()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray* myArray = GetSharedArray()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id anObject&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock lock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anObject = [myArray objectAtIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject retain]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arrayLock unlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject doSomething]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject release]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;尽管上面的例子非常简单，但抓到重点了。要透过表面看本质。要预先考虑到一些问题，比如内存管理和其他方面的设计可能会受多线程的影响。除此之外，在安全问题上要对编辑器的行为做最坏的打算。小心谨慎方能避灾。&lt;/p&gt;
&lt;h4 id=&quot;提防死锁和活锁&quot;&gt;&lt;a href=&quot;#提防死锁和活锁&quot; class=&quot;headerlink&quot; title=&quot;提防死锁和活锁&quot;&gt;&lt;/a&gt;提防死锁和活锁&lt;/h4&gt;&lt;p&gt;如果线程在同一时刻持有不止一个锁，随时都有发生死锁的可能。当两个不同的线程分别持有一个锁，并且尝试获取对方持有的锁，&lt;a href=&quot;https://zh.wikipedia.org/wiki/死锁&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;死锁&lt;/a&gt;就发生了。因为每个线程永远都获取不到另一个锁，结果就是永久阻塞。&lt;/p&gt;
&lt;p&gt;活锁跟死锁很像，死锁是获取不到另一个锁就死等，而活锁是获取不到就释放已经持有的锁和资源，然后重试。活锁把时间都花在释放锁和尝试获取其他锁上面了，并没啥干活儿。&lt;/p&gt;
&lt;p&gt;避免死锁和活锁的最好方法就是一次只获取一个锁。如果一次必须获取不止一个锁，那就应该确保其他线程别这么做。&lt;/p&gt;
&lt;h4 id=&quot;正确地使用-Volatile-变量&quot;&gt;&lt;a href=&quot;#正确地使用-Volatile-变量&quot; class=&quot;headerlink&quot; title=&quot;正确地使用 Volatile 变量&quot;&gt;&lt;/a&gt;正确地使用 &lt;code&gt;Volatile&lt;/code&gt; 变量&lt;/h4&gt;&lt;p&gt;如果已经对一段代码用互斥锁保护了，就不要自动假定需要对这段代码中的重要变量用 &lt;code&gt;volatile&lt;/code&gt; 关键字再保护一次。互斥锁包含了内存屏障，确保加载和存储操作的顺序正确。添加 &lt;code&gt;volatile&lt;/code&gt; 关键字会强制访问变量时每次都从内存加载。可能在特殊情况下有必要将这两种同步技术混合使用，但也会导致严重降低性能。如果只用互斥锁保护变量就够了，删掉 &lt;code&gt;volatile&lt;/code&gt; 关键字吧。&lt;/p&gt;
&lt;p&gt;不要用 &lt;code&gt;volatile&lt;/code&gt; 变量试图替代使用互斥锁。互斥锁和其他同步机制通常比 &lt;code&gt;volatile&lt;/code&gt; 变量能更好地保护数据结构的完整性。&lt;code&gt;volatile&lt;/code&gt; 关键字只是确保变量从内存加载而不是存在寄存器中。它无法确保代码可以正确地访问变量。&lt;/p&gt;
&lt;h3 id=&quot;使用原子操作&quot;&gt;&lt;a href=&quot;#使用原子操作&quot; class=&quot;headerlink&quot; title=&quot;使用原子操作&quot;&gt;&lt;/a&gt;使用原子操作&lt;/h3&gt;&lt;p&gt;无阻塞同步可以执行一些操作并避免锁的开销。虽然用锁可以有效地同步两个线程，但即便在无竞争情况下获取锁的代价相对较高。相反，许多同步操作花一小部分时间就能完成，而且跟锁一样管用。&lt;/p&gt;
&lt;p&gt;可以用原子操作在 32 位或 64 位数值上做些简单的数学和逻辑操作。为了确保在原子操作完成后才可再次访问受影响的内存，这些操作依赖专门的硬件指令（和可选的内存屏障）。在多线程情况下为确保内存被正确地同步，应该始终使用纳入内存屏障版本的原子操作（带有 &lt;code&gt;Barrier&lt;/code&gt; 后缀）。&lt;/p&gt;
&lt;p&gt;下标列出了可用的数学和逻辑原子操作以及相关函数名。这些函数都声明在 &lt;code&gt;/usr/include/libkern/OSAtomic.h&lt;/code&gt; 头文件中，它包含了完整语法。这些函数的 64 位版本仅在 64 位处理器中可用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Add&lt;/td&gt;
&lt;td&gt;OSAtomicAdd32 OSAtomicAdd32Barrier OSAtomicAdd64 OSAtomicAdd64Barrier&lt;/td&gt;
&lt;td&gt;将两个整数相加并将结果存在其中一个指定的变量中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Increment&lt;/td&gt;
&lt;td&gt;OSAtomicIncrement32 OSAtomicIncrement32Barrier OSAtomicIncrement64 OSAtomicIncrement64Barrier&lt;/td&gt;
&lt;td&gt;将指定的整数值加一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Decrement&lt;/td&gt;
&lt;td&gt;OSAtomicDecrement32 OSAtomicDecrement32Barrier OSAtomicDecrement64 OSAtomicDecrement64Barrier&lt;/td&gt;
&lt;td&gt;将指定的整数值减一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Logical OR&lt;/td&gt;
&lt;td&gt;OSAtomicOr32 OSAtomicOr32Barrier&lt;/td&gt;
&lt;td&gt;在指定的 32 位数值和掩码之间做逻辑或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Logical AND&lt;/td&gt;
&lt;td&gt;OSAtomicAnd32 OSAtomicAnd32Barrier&lt;/td&gt;
&lt;td&gt;在指定的 32 位数值和掩码之间做逻辑与&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Logical XOR&lt;/td&gt;
&lt;td&gt;OSAtomicXor32 OSAtomicXor32Barrier&lt;/td&gt;
&lt;td&gt;在指定的 32 位数值和掩码之间做逻辑异或&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compare and swap&lt;/td&gt;
&lt;td&gt;OSAtomicCompareAndSwap32 OSAtomicCompareAndSwap32Barrier OSAtomicCompareAndSwap64 OSAtomicCompareAndSwap64Barrier OSAtomicCompareAndSwapPtr OSAtomicCompareAndSwapPtrBarrier OSAtomicCompareAndSwapInt OSAtomicCompareAndSwapIntBarrier OSAtomicCompareAndSwapLong OSAtomicCompareAndSwapLongBarrier&lt;/td&gt;
&lt;td&gt;函数有三个参数：oldValue, newValue, theValue 指针。如果 oldValue 跟 theValue 指针的内容相等，则把 newValue 赋给 theValue 指针的内容。否则啥都不干。比较和赋值会以一个原子操作完成。返回值表明是否发生了交换。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Test and set&lt;/td&gt;
&lt;td&gt;OSAtomicTestAndSet OSAtomicTestAndSetBarrier&lt;/td&gt;
&lt;td&gt;将指定变量第 n 位设为 1，并将旧值以 bool 形式返回。注意这里会将变量按 8 位分块，每块的内容是逆序的。所以如果想要设置 0 位的值，n 需要传入 7。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Test and clear&lt;/td&gt;
&lt;td&gt;OSAtomicTestAndClear OSAtomicTestAndClearBarrier&lt;/td&gt;
&lt;td&gt;将指定变量第 n 位设为 0，并将旧值以 bool 形式返回。注意这里会将变量按 8 位分块，每块的内容是逆序的。所以如果想要设置 0 位的值，n 需要传入 7。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;大多数原子函数的行为都会是相对简单且能预料到的。下面的示例代码使用了 &lt;code&gt;OSAtomicTestAndSet&lt;/code&gt; 和 &lt;code&gt;OSAtomicCompareAndSwap32&lt;/code&gt; 函数，结果可能跟你预想的不太一样。这些函数在无竞争情况下被调用，且没有其他线程同时操作。&lt;/p&gt;
&lt;figure class=&quot;highlight mizar&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int32_t  theValue = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicTestAndSet(0, &amp;amp;theValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;now&lt;/span&gt; 128.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theValue = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicTestAndSet(7, &amp;amp;theValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;now&lt;/span&gt; 1.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theValue = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicTestAndSet(15, &amp;amp;theValue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;now&lt;/span&gt; 256.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicCompareAndSwap32(256, 512, &amp;amp;theValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;now&lt;/span&gt; 512.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSAtomicCompareAndSwap32(256, 1024, &amp;amp;theValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// theValue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; still 512.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于原子操作可以看看 &lt;code&gt;atomic&lt;/code&gt; man page 和 &lt;code&gt;/usr/include/libkern/OSAtomic.h&lt;/code&gt; 头文件。&lt;/p&gt;
&lt;h3 id=&quot;使用锁&quot;&gt;&lt;a href=&quot;#使用锁&quot; class=&quot;headerlink&quot; title=&quot;使用锁&quot;&gt;&lt;/a&gt;使用锁&lt;/h3&gt;&lt;p&gt;锁是多线程编程中的一个基础同步工具，macOS 和 iOS 都提供了基础的互斥锁。Foundation 框架定义了几种用于特别场景的互斥锁作为补充。&lt;/p&gt;
&lt;h4 id=&quot;POSIX-互斥锁&quot;&gt;&lt;a href=&quot;#POSIX-互斥锁&quot; class=&quot;headerlink&quot; title=&quot;POSIX 互斥锁&quot;&gt;&lt;/a&gt;POSIX 互斥锁&lt;/h4&gt;&lt;p&gt;POSIX 互斥锁贼好用。用 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 结构体声明一个互斥锁变量，将其传入 &lt;code&gt;pthread_mutex_init&lt;/code&gt; 函数初始化，然后用 &lt;code&gt;pthread_mutex_lock&lt;/code&gt; 和 &lt;code&gt;pthread_mutex_unlock&lt;/code&gt; 函数获取和释放锁就行了。等到不需要用锁了，调用 &lt;code&gt;pthread_mutex_destroy&lt;/code&gt; 函数析构锁的数据结构。下面是简化后的代码，实际使用时要考虑到错误处理等细节：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pthread_mutex_t&lt;/span&gt; mutex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyInitFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_init(&amp;amp;mutex, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyLockingFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Do work.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;NSLock&quot;&gt;&lt;a href=&quot;#NSLock&quot; class=&quot;headerlink&quot; title=&quot;NSLock&quot;&gt;&lt;/a&gt;&lt;code&gt;NSLock&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;NSLock&lt;/code&gt; 实现了 Cocoa 中基本的互斥锁。包括 &lt;code&gt;NSLock&lt;/code&gt; 的所有锁的接口实际上都由 &lt;code&gt;NSLocking&lt;/code&gt; 协议定义，也就是 &lt;code&gt;lock&lt;/code&gt; 和 &lt;code&gt;unlock&lt;/code&gt; 这俩方法，对应功能是获取和释放锁。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;code&gt;NSLock&lt;/code&gt; 类还提供了 &lt;code&gt;tryLock&lt;/code&gt; 和 &lt;code&gt;lockBeforeDate:&lt;/code&gt; 方法。&lt;code&gt;tryLock&lt;/code&gt; 方法尝试获取锁，但如果锁不可用，并不会阻塞，只是返回 &lt;code&gt;NO&lt;/code&gt; 而已。&lt;code&gt;lockBeforeDate:&lt;/code&gt; 方法尝试获取锁，并一直阻塞线程，直到获取到锁（返回 &lt;code&gt;YES&lt;/code&gt;）或达到限定的时间（返回 &lt;code&gt;NO&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;下面的示例代码展示了如何使用 &lt;code&gt;NSLock&lt;/code&gt; 在多个线程计算要被显示的数据时，即便获取不到锁的情况下依然可以继续运算。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; moreToDo = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLock&lt;/span&gt; *theLock = [[&lt;span class=&quot;built_in&quot;&gt;NSLock&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (moreToDo) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Do another increment of calculation */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* until there’s no more to do. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([theLock tryLock]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* Update display used by all threads. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [theLock unlock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;@synchronized&quot;&gt;&lt;/a&gt;&lt;code&gt;@synchronized&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;可以用 &lt;code&gt;@synchronized&lt;/code&gt; 指令很方便地在 Objective-C 代码中飞快地写个互斥锁。它的作用跟互斥锁一样，但不用创建锁，只需要把一个 Objective-C 对象当做锁的 token 即可：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;selector-tag&quot;&gt;myMethod&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:(id)anObj&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;@synchronized&lt;/span&gt;(anObj)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Everything between the braces is protected by the @synchronized directive.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;传给 &lt;code&gt;@synchronized&lt;/code&gt; 的对象是区分被保护的代码块的唯一标识。如果两个线程都执行上面的 &lt;code&gt;myMethod:&lt;/code&gt; 方法，传入的对象如果不同，则不会有阻塞；传入的对象相同，则一个线程先获取锁，另一个线程在临界区域执行完成之前会一直阻塞。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;@synchronized&lt;/code&gt; 的前提是工程开启了 Objective-C exception handling 选项。因为 &lt;code&gt;@synchronized&lt;/code&gt; 的 block 为了保护代码，预防措施是隐式加入 exception handler。handler 在异常抛出时会自动释放互斥锁。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/&quot;&gt;关于 @synchronized，这儿比你想知道的还要多&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用其他-Cocoa-框架的锁&quot;&gt;&lt;a href=&quot;#使用其他-Cocoa-框架的锁&quot; class=&quot;headerlink&quot; title=&quot;使用其他 Cocoa 框架的锁&quot;&gt;&lt;/a&gt;使用其他 Cocoa 框架的锁&lt;/h4&gt;&lt;h5 id=&quot;NSRecursiveLock&quot;&gt;&lt;a href=&quot;#NSRecursiveLock&quot; class=&quot;headerlink&quot; title=&quot;NSRecursiveLock&quot;&gt;&lt;/a&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;NSRecursiveLock&lt;/code&gt; 类也就是递归锁，可以被同一线程获取多次而不会导致死锁。当然 &lt;code&gt;lock&lt;/code&gt; 多少次，也要相应地 &lt;code&gt;unlock&lt;/code&gt; 多少次，这样锁才会被真正释放，其他线程才能获取锁。&lt;/p&gt;
&lt;p&gt;递归锁通常用于递归函数中来避免死锁线程。也可以用于非递归的场景下。这有个使用 &lt;code&gt;NSRecursiveLock&lt;/code&gt; 的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyRecursiveFunction&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [theLock &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        --&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MyRecursiveFunction(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [theLock unlock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MyRecursiveFunction(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：因为递归锁需要 &lt;code&gt;lock&lt;/code&gt; 和 &lt;code&gt;unlock&lt;/code&gt; 次数相等才能释放，应该小心权衡。可以重写代码来避免递归，或避免使用递归锁，这样可以获取更好的性能。&lt;/p&gt;
&lt;h5 id=&quot;NSConditionLock&quot;&gt;&lt;a href=&quot;#NSConditionLock&quot; class=&quot;headerlink&quot; title=&quot;NSConditionLock&quot;&gt;&lt;/a&gt;&lt;code&gt;NSConditionLock&lt;/code&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 定义了可以用特定值来 &lt;code&gt;lock&lt;/code&gt; 和 &lt;code&gt;unlock&lt;/code&gt; 的互斥锁，但别跟条件变量搞混了。虽然行为差不多但实现很不一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 一般用于线程需要以特定的顺序执行任务时，例如生产者消费者问题。当生产者执行时，消费者需要使用程序中特定的条件变量来获取锁。所谓的条件变量其实就是个程序员定义的整型数。当生产者完成后，它会 &lt;code&gt;unlock&lt;/code&gt; 并更新条件变量，进而唤醒了消费者线程。消费者线程继续处理数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSConditionLock&lt;/code&gt; 的加锁和解锁方法可以任意组合使用。比如可以用 &lt;code&gt;lock&lt;/code&gt; 跟 &lt;code&gt;unlockWithCondition:&lt;/code&gt; 搭配，或用 &lt;code&gt;lockWhenCondition:&lt;/code&gt; 跟 &lt;code&gt;unlock&lt;/code&gt; 搭配。当然第二种搭配没有在解锁后设置 &lt;code&gt;condition&lt;/code&gt; 属性的值，其他一些等待特定条件变量的线程可能还会阻塞。&lt;/p&gt;
&lt;p&gt;下面的例子展示了如何使用条件锁处理生产者-消费者问题。摄像应用含有一个数据队列，生产者线程向队列添加数据，消费者线程从队列取数据。生产者不需要等特定的条件，但是必须等锁可用的时候才能安全地向队列添加数据。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id condLock = [[NSConditionLock alloc] &lt;span class=&quot;string&quot;&gt;initWithCondition:&lt;/span&gt;NO_DATA];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [condLock lock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Add data to the queue. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [condLock &lt;span class=&quot;string&quot;&gt;unlockWithCondition:&lt;/span&gt;HAS_DATA];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于锁的初始条件被设置成 &lt;code&gt;NO_DATA&lt;/code&gt;，生产者线程起初会顺利地获取锁。它向队列填充数据并将条件设置为 &lt;code&gt;HAS_DATA&lt;/code&gt;。在接下来的迭代中，不管队列是否为空，生产者线程总能添加新数据。它只有消费者线程从队列中获取数据的时候才会阻塞。&lt;/p&gt;
&lt;p&gt;由于消费者线程必须有数据去处理，它会用一个特定的条件等待着队列。当生产者网队列中放数据时，消费者线程会活跃起来并获取锁。然后它可能从队列获取一些数据并更新队列状态。下面的例子展示了消费者线程循环程序的基本结构。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;while&lt;/span&gt; (true)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-attr&quot;&gt;[condLock lockWhenCondition:HAS_DATA]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Remove data from the queue. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-attr&quot;&gt;[condLock unlockWithCondition:(isEmpty ? NO_DATA : HAS_DATA)]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Process the data locally.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;NSDistributedLock&quot;&gt;&lt;a href=&quot;#NSDistributedLock&quot; class=&quot;headerlink&quot; title=&quot;NSDistributedLock&quot;&gt;&lt;/a&gt;&lt;code&gt;NSDistributedLock&lt;/code&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;NSDistributedLock&lt;/code&gt; 可以用于多个应用拥有并访问某个共享资源（例如文件）的临界区。它实际上是使用文件系统的文件或目录等实现的互斥锁。所有使用 &lt;code&gt;NSDistributedLock&lt;/code&gt; 对象的应用必须对其可写入。这通常意味着将其放入一个所有运行此应用的计算机都能访问的文件系统。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSDistributedLock&lt;/code&gt; &lt;strong&gt;不&lt;/strong&gt;像其他锁一样遵从 &lt;code&gt;NSLocking&lt;/code&gt; 协议，没有 &lt;code&gt;lock&lt;/code&gt; 方法。&lt;code&gt;lock&lt;/code&gt; 方法会阻塞进程的执行并需要系统以预定的速率查询锁。与其在代码上强制损耗性能，不如用 &lt;code&gt;NSDistributedLock&lt;/code&gt; 提供的 &lt;code&gt;tryLock&lt;/code&gt; 方法来让程序员决定是否去查询锁。&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;NSDistributedLock&lt;/code&gt; 使用文件系统实现，它只有在拥有者显式释放它时才会跟着释放。如果应用 crash 时还持有一个 &lt;code&gt;NSDistributedLock&lt;/code&gt; 对象，其他 client 将不能访问被保护的资源。在这种情况下，可以使用 &lt;code&gt;breakLock&lt;/code&gt; 方法打破已经存在的锁，这样就能获取到它了。通常应该避免打破锁，除非你确信拥有锁的进程挂了，无法释放锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSDistributedLock&lt;/code&gt; 跟其他锁一样，调用 &lt;code&gt;unlock&lt;/code&gt; 方法释放它。&lt;/p&gt;
&lt;h3 id=&quot;使用条件（Condition）&quot;&gt;&lt;a href=&quot;#使用条件（Condition）&quot; class=&quot;headerlink&quot; title=&quot;使用条件（Condition）&quot;&gt;&lt;/a&gt;使用条件（Condition）&lt;/h3&gt;&lt;p&gt;Condition 是一种特殊类型的锁，它可以让操作必须以正确的顺序进行。它跟互斥锁有细微的差别。等待 condition 的线程会保持阻塞，直到 condition 被其他线程显式发信号。&lt;/p&gt;
&lt;p&gt;由于牵扯到操作系统实现的细节，条件锁在即使没被发信号的情况下被允许伪造成功返回。为了避免这种站不住脚的发信号导致的问题，应该总是把断言跟条件锁结合起来使用。断言是一个决定线程是否能安全进行的更具体的方式。在发信号的线程设置断言前，condition 会让你的线程保持睡眠。&lt;/p&gt;
&lt;p&gt;下面展示如何在代码中使用 condition。&lt;/p&gt;
&lt;h4 id=&quot;NSCondition&quot;&gt;&lt;a href=&quot;#NSCondition&quot; class=&quot;headerlink&quot; title=&quot;NSCondition&quot;&gt;&lt;/a&gt;&lt;code&gt;NSCondition&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;NSCondition&lt;/code&gt; 是对 POSIX Condition 语法的封装，而且将锁和 condition 数据结构包含在一个对象里。这使得可以用一个对象既能当做互斥锁 &lt;code&gt;lock&lt;/code&gt;，又能像 Condition 一样继续 &lt;code&gt;wait&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面的代码中 &lt;code&gt;cocoaCondition&lt;/code&gt; 变量是一个 &lt;code&gt;NSCondition&lt;/code&gt; 对象，&lt;code&gt;timeToDoWork&lt;/code&gt; 变量是一个整型数，用作断言。其他线程会在向 condition 发信号之前立刻增加 &lt;code&gt;timeToDoWork&lt;/code&gt; 的值。&lt;/p&gt;
&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;name&quot;&gt;cocoaCondition&lt;/span&gt; lock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (&lt;span class=&quot;name&quot;&gt;timeToDoWork&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;name&quot;&gt;cocoaCondition&lt;/span&gt; wait]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timeToDoWork--&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Do real work here.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;name&quot;&gt;cocoaCondition&lt;/span&gt; unlock]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后就是增加断言的值，并向 condition 发信号。当然这些操作要加锁：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[cocoaCondition lock]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timeToDoWork++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[cocoaCondition signal]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-attr&quot;&gt;[cocoaCondition unlock]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;POSIX-Condition&quot;&gt;&lt;a href=&quot;#POSIX-Condition&quot; class=&quot;headerlink&quot; title=&quot;POSIX Condition&quot;&gt;&lt;/a&gt;POSIX Condition&lt;/h4&gt;&lt;p&gt;POSIX 线程条件锁需要将 condition 数据结构和互斥锁一起使用。尽管两个锁结构是分开的，但是互斥锁在运行时会被紧紧地捆到 condition 结构上。等待发信号的线程应该始终将相同的互斥锁和 condition 结构一起使用。改变配对会导致错误。&lt;/p&gt;
&lt;p&gt;下面的代码展示了 condition 和断言基本的初始化和使用。在初始化 condition 和互斥锁后，线程进入了一个使用 &lt;code&gt;ready_to_go&lt;/code&gt; 变量作为断言的 &lt;code&gt;while&lt;/code&gt; 循环。只有断言设置好并且 condition 接着被发信号后，等待着的线程才会被唤醒，并开始工作。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pthread_mutex_t&lt;/span&gt; mutex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pthread_cond_t&lt;/span&gt; condition;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Boolean     ready_to_go = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyCondInitFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_init(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_cond_init(&amp;amp;condition, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyWaitOnConditionFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Lock the mutex.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// If the predicate is already set, then the while loop is bypassed;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// otherwise, the thread sleeps until the predicate is set.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(ready_to_go == &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pthread_cond_wait(&amp;amp;condition, &amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Do work. (The mutex should stay locked.)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Reset the predicate and release the mutex.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ready_to_go = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;发信号的线程负责设置断言并向条件锁发信号。下面的代码展示了它的实现。为了避免线程之间等待 condition 而发生竞态条件，发信号的操作要在互斥锁里面进行。因为是简化过后的例子，代码中没包含错误处理的代码，只展示基础用法。&lt;/p&gt;
&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SignalThreadUsingCondition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// At this point, there should be work for the other thread to do.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_lock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ready_to_go = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Signal the other thread to begin work.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_cond_signal(&amp;amp;condition);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_unlock(&amp;amp;mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第三部分。关于同步的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/&quot;&gt;Threading Programming Guide(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/&quot;&gt;Threading Programming Guide(2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yulingtianxia.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Threading Programming Guide(2)</title>
    <link href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/"/>
    <id>http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/</id>
    <published>2017-09-17T06:07:13.000Z</published>
    <updated>2017-10-10T16:02:37.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第二部分。关于 Run Loop 的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/&quot;&gt;Threading Programming Guide(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/&quot;&gt;Threading Programming Guide(3)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Run-Loops&quot;&gt;&lt;a href=&quot;#Run-Loops&quot; class=&quot;headerlink&quot; title=&quot;Run Loops&quot;&gt;&lt;/a&gt;Run Loops&lt;/h2&gt;&lt;p&gt;Run Loop 作为线程相关基础设施的一部分，充当着循环处理、调度事件/消息的角色。它使得线程不会执行完单个任务后就立刻结束，而是让线程在没有任务时保持休眠状态，在需要处理消息时被立刻唤醒。&lt;/p&gt;
&lt;p&gt;Run Loop 其实是个对象，但不需要主动去创建它，而且每个线程都有对应的 run loop 对象。Run Loop 的管理机制并不完全是自动的，有时需要设计好 run loop 的运行时间和事件处理回调。次级线程需要开发者手动去配置并运行它的 run loop，在应用启动过程中主线程的 run loop 已经自动配置并运行了。&lt;/p&gt;
&lt;p&gt;Run Loop 作为苹果提供的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Event_loop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Event Loop&lt;/a&gt; 机制的实现方案，在 Cocoa 和 Core Foundation 有两个对应的类：&lt;a href=&quot;https://developer.apple.com/documentation/foundation/runloop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;NSRunLoop&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://developer.apple.com/documentation/corefoundation/cfrunloop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;CFRunLoop&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-Loop-剖析&quot;&gt;&lt;a href=&quot;#Run-Loop-剖析&quot; class=&quot;headerlink&quot; title=&quot;Run Loop 剖析&quot;&gt;&lt;/a&gt;Run Loop 剖析&lt;/h3&gt;&lt;p&gt;Run Loop 可能需要开发者自己写 &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 循环，并在里面驱动 run loop 对象运行，每轮运行都会处理接收到事件的回调。&lt;/p&gt;
&lt;p&gt;Run Loop 接收的事件来源 (source) 有两种。Input Source 传送来自其他应用或线程的异步事件/消息；Timer Source 传送的是基于定时器的同步事件，可以定时或重复发送。&lt;/p&gt;
&lt;p&gt;下图展示了 run loop 与多种 source 的概念架构。运行 &lt;code&gt;NSRunLoop&lt;/code&gt; 实例的方式有三种，&lt;code&gt;runUntilDate:&lt;/code&gt; 方法是其中的一种，后面会讲。Input Source 发送的异步事件产生的回调会使 &lt;code&gt;runUntilDate:&lt;/code&gt; 退出；Timer Source 则不会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg&quot; alt=&quot;Structure of a run loop and its sources&quot;&gt;&lt;/p&gt;
&lt;p&gt;Run Loop 的一些行为会发通知，开发者可以注册成为 run-loop 观察者 (observer)。&lt;/p&gt;
&lt;p&gt;Input Source, Timer Source, Run Loop Observer 统称为 Mode Item，这里的 Mode 指的是 Run Loop Mode。一个 Run Loop 包含若干个 Mode，每个 Mode 又包含若干个 Item。Item 与 Mode 是多对多的关系，没有 Item 的 Model 会立刻退出。&lt;/p&gt;
&lt;p&gt;下面几节会详细讲述上面提到的这些概念。&lt;/p&gt;
&lt;h4 id=&quot;Run-Loop-Modes&quot;&gt;&lt;a href=&quot;#Run-Loop-Modes&quot; class=&quot;headerlink&quot; title=&quot;Run Loop Modes&quot;&gt;&lt;/a&gt;Run Loop Modes&lt;/h4&gt;&lt;p&gt;Run Loop Mode 包含了需要被监听的 input source 和 timer 集合，以及需要接收通知的 observer 集合。Run loop 的每次运行都会处在某个特定模式下，而且只有这个模式所包含的 item 集合才会参与发送事件(被监听)和接收通知。&lt;/p&gt;
&lt;p&gt;开发者使用 run loop mode 时直接指定名字就行，Cocoa 和 Core Foundation 定义了一些默认和常用的 Mode。Run Loop Mode 对应的类是 &lt;code&gt;CFRunLoopModeRef&lt;/code&gt;，但是并没有作为公有 API 开放出来，但可以通过 Core Foundation 源码了解下:&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; *&lt;span class=&quot;built_in&quot;&gt;CFRunLoopModeRef&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRuntimeBase&lt;/span&gt; _base; &lt;span class=&quot;comment&quot;&gt;// CF 的基石，遍地可见&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_t _lock; &lt;span class=&quot;comment&quot;&gt;// 确保 CF 中的 Run Loop 线程安全&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt; _name; &lt;span class=&quot;comment&quot;&gt;// Mode 的名字，比如 kCFRunLoopDefaultMode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean _stopped; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; _padding[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _sources0; &lt;span class=&quot;comment&quot;&gt;// Input Sources 中的 Custom Input Source 集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _sources1; &lt;span class=&quot;comment&quot;&gt;// Input Sources 中的 Port-Based Source 集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableArrayRef&lt;/span&gt; _observers; &lt;span class=&quot;comment&quot;&gt;// Run Loop Observers 数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableArrayRef&lt;/span&gt; _timers; &lt;span class=&quot;comment&quot;&gt;// Timer Sources 数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; _portToV1SourceMap; &lt;span class=&quot;comment&quot;&gt;// 端口(port)与 sources1 的映射表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;built_in&quot;&gt;CFPortSet&lt;/span&gt; _portSet; &lt;span class=&quot;comment&quot;&gt;// 端口集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;... 省略后面源码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Core Foundation 中所有实例都以 &lt;code&gt;CFRuntimeBase&lt;/code&gt; 开始，仅限于内部使用。通过它的结构可以看出这里面保存了一些基本信息，比如 isa 指针，retainCount 等。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __CFRuntimeBase &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; _cfisa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; _cfinfo[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; _rc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; CFRuntimeBase;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不同 Mode 直接是靠事件的来源 (Source) 区分的，而不是事件的类型。比方说 Mode 不能只搭配鼠标点击事件或键盘事件，但可以让某个 Mode 监听一些端口、暂停 timer、修改 source 和 observer 等。&lt;/p&gt;
&lt;p&gt;下面的表格列出了一些系统定义的 Mode，大多数情况下会使用 Default Mode。&lt;a href=&quot;http://iphonedevwiki.net/index.php/CFRunLoop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iphonedevwiki&lt;/a&gt; 列出了 Core Foundation 中更多的 Mode，很多是系统私有的。使用不同的 Mode 可以过滤不同 Source 发出的事件，比如在要求时效性操作的场景下使用自定义 Mode 来阻止低优先级 Source 发送事件。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Mode&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Default&lt;/td&gt;
&lt;td&gt;NSDefaultRunLoopMode (Cocoa), kCFRunLoopDefaultMode (Core Foundation)&lt;/td&gt;
&lt;td&gt;大多数操作下最常用的 Mode，运行 Run Loop 和配置 Source 的首选&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;NSConnectionReplyMode (Cocoa)&lt;/td&gt;
&lt;td&gt;Cocoa 中结合 NSConnection 使用，用于监听回复(Reply)，极少用到。(已弃用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Modal&lt;/td&gt;
&lt;td&gt;NSModalPanelRunLoopMode (Cocoa)&lt;/td&gt;
&lt;td&gt;Cocoa 中 modal panel 使用它接收与之相关 Source 的事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Event tracking&lt;/td&gt;
&lt;td&gt;NSEventTrackingRunLoopMode (Cocoa), UITrackingRunLoopMode (Cocoa Touch)&lt;/td&gt;
&lt;td&gt;Cocoa 用它限定鼠标拖拽事件之类的用户交互轨迹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Common modes&lt;/td&gt;
&lt;td&gt;NSRunLoopCommonModes (Cocoa), kCFRunLoopCommonModes (Core Foundation)&lt;/td&gt;
&lt;td&gt;可配置的通用模式集合，将某个 Input Source 关联到此 Mode 也会将其关联到集合中所有 Mode。Cocoa 框架中的 Common modes 默认包含 Default, Modal, Event tracking 三种 Mode；CF 框架起初只包含 Default，可以使用 &lt;code&gt;CFRunLoopAddCommonMode&lt;/code&gt;函数向集合中添加自定义 Mode。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;Input-Sources&quot;&gt;&lt;a href=&quot;#Input-Sources&quot; class=&quot;headerlink&quot; title=&quot;Input Sources&quot;&gt;&lt;/a&gt;Input Sources&lt;/h4&gt;&lt;p&gt;Input Sources 有两种实现：基于端口(Port-based)和自定义(Custom)，它们都向线程异步分发事件，而唯一的不同就是被发信号（signal）的方式。基于端口的事件源会自动由内核发信号，自定义事件源需要被其他线程手动发信号。&lt;/p&gt;
&lt;p&gt;Input Source 会被添加到一些 Mode 中，如果某个 input source 不在当前的 Mode 中，那么它生成的事件在 run loop 处于正确的 mode 之前会先被 hold 住。&lt;/p&gt;
&lt;h5 id=&quot;Port-Based-Sources-Source1&quot;&gt;&lt;a href=&quot;#Port-Based-Sources-Source1&quot; class=&quot;headerlink&quot; title=&quot;Port-Based Sources(Source1)&quot;&gt;&lt;/a&gt;Port-Based Sources(Source1)&lt;/h5&gt;&lt;p&gt;Cocoa 和 Core Foundation 使用端口相关的对象和函数提供了对创建基于端口的事件源的内建支持。比如在 Cocoa 中，只需创建一个端口对象并使用 &lt;code&gt;NSPort&lt;/code&gt; 的方法来向 run loop 添加端口。端口对象为你处理好了创建和配置 input source 的事情。&lt;/p&gt;
&lt;p&gt;在 Core Foundation 中需要手动创建端口和 run loop source。涉及到的 API 有 &lt;code&gt;CFMachPortRef&lt;/code&gt;, &lt;code&gt;CFMessagePortRef&lt;/code&gt;, &lt;code&gt;CFSocketRef&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;Custom-Input-Sources-Source0&quot;&gt;&lt;a href=&quot;#Custom-Input-Sources-Source0&quot; class=&quot;headerlink&quot; title=&quot;Custom Input Sources(Source0)&quot;&gt;&lt;/a&gt;Custom Input Sources(Source0)&lt;/h5&gt;&lt;p&gt;只能使用 Core Foundation 中的 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt; 相关函数来创建自定义事件源。在处理到来的事件、从 run loop 移除 source 后都会有函数回调，可以通过实现这些回调函数来配置 source。&lt;/p&gt;
&lt;p&gt;除此之外还需定义事件分发机制。source 有一部分是在单独的线程运行的，负责为 input source 提供数据，并在数据准备好后对 source 发信号。事件分发机制取决于开发者，但别弄得太过复杂。&lt;/p&gt;
&lt;h5 id=&quot;Cocoa-Perform-Selector-Sources&quot;&gt;&lt;a href=&quot;#Cocoa-Perform-Selector-Sources&quot; class=&quot;headerlink&quot; title=&quot;Cocoa Perform Selector Sources&quot;&gt;&lt;/a&gt;Cocoa Perform Selector Sources&lt;/h5&gt;&lt;p&gt;Cocoa 定义了一种在任何线程执行 &lt;code&gt;selector&lt;/code&gt; 的 custom input source。与机遇端口的事件源相同之处是在目标线程依次执行 &lt;code&gt;selector&lt;/code&gt;，缓解了一条线程运行多个方法时可能发生的同步问题；不同之处在于 &lt;code&gt;selector&lt;/code&gt; 执行后会将 source 从 run loop 挪走。&lt;/p&gt;
&lt;p&gt;在任意线程 perform selector 的前置条件是线程必须有一个活跃的 run loop。对于自己创建的线程，&lt;code&gt;selector&lt;/code&gt; 直到启动 run loop 之后才会运行；主线程会自动配置并运行 run loop，然而要在应用的 &lt;code&gt;applicationDidFinishLaunching:&lt;/code&gt; delegate 方法调用后才生效。Run Loop 每次循环会处理队列中所有的 &lt;code&gt;selector&lt;/code&gt;，而不是循环一次处理一个。&lt;/p&gt;
&lt;p&gt;下表中列出了 &lt;code&gt;NSObject&lt;/code&gt; 类提供的在任何线程执行 &lt;code&gt;selector&lt;/code&gt; 的 API。在任何线程下，只要能拿到 Objective-C 对象就能使用下面的 API，包括 POSIX 线程。这些方法并不会为了执行 &lt;code&gt;selector&lt;/code&gt; 真的去创建一个新线程。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;performSelectorOnMainThread:withObject:waitUntilDone:&lt;/code&gt;, &lt;code&gt;performSelectorOnMainThread:withObject:waitUntilDone:modes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在应用主线程 run loop 的下次循环执行特定的 &lt;code&gt;selector&lt;/code&gt;，并提供了选项可以在执行 &lt;code&gt;selector&lt;/code&gt; 之前阻塞当前线程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;performSelector:onThread:withObject:waitUntilDone:&lt;/code&gt;, &lt;code&gt;performSelector:onThread:withObject:waitUntilDone:modes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在任意 &lt;code&gt;NSThread&lt;/code&gt; 对象执行 &lt;code&gt;selector&lt;/code&gt;，同上。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;performSelector:withObject:afterDelay:&lt;/code&gt;, &lt;code&gt;performSelector:withObject:afterDelay:inModes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在当前线程 run loop 的下次循环延迟一段时间执行 &lt;code&gt;selector&lt;/code&gt;。因为需要等到下次 run loop 循环才会依次执行队列中的 &lt;code&gt;selector&lt;/code&gt;，所以本身就会有一点延时。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cancelPreviousPerformRequestsWithTarget:&lt;/code&gt;, &lt;code&gt;cancelPreviousPerformRequestsWithTarget:selector:object:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;取消 &lt;code&gt;performSelector:withObject:afterDelay:&lt;/code&gt; 或 &lt;code&gt;performSelector:withObject:afterDelay:inModes:&lt;/code&gt; 方法向当前线程发送的消息。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;Timer-Sources&quot;&gt;&lt;a href=&quot;#Timer-Sources&quot; class=&quot;headerlink&quot; title=&quot;Timer Sources&quot;&gt;&lt;/a&gt;Timer Sources&lt;/h4&gt;&lt;p&gt;Timer source 会在未来一个预定时间向线程同步分发事件。线程可以用 Timer 来通知自己做一些事情。比如用户在搜索栏输入一连串字符之后的某个时间自动搜索一次结果。正是因为有了个延时，才让用户有机会在自动搜索发生前尽可能打出想要的搜索字符串。&lt;/p&gt;
&lt;p&gt;Timer 并不是实时的，会有误差。如果一个 timer 不在正在运行的 run loop 监控的 mode 中，需要一直等到 run loop 运行在一个支持这个 timer 的 mode 时，timer 才会触发。如果一个 timer 触发的时候恰巧 run loop 正忙于执行某个 handler 程序，这个 timer 的 handler 程序需要等到下次才会通过 run loop 执行。如果 run loop 根本不在运行，timer 永远都不会触发。&lt;/p&gt;
&lt;p&gt;可以配置 timer 只生成一次或重复多次事件。重复的 timer 每次会根据已经编排的触发时间自动重新编排。如果实际的触发时间太过于延迟，甚至是晚了一个或多个周期，那么也只会触发一次，而非连续多次。之后会重新编排下次触发时间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSTimer&lt;/code&gt; 和 &lt;code&gt;CFRunLoopTimerRef&lt;/code&gt; 是 toll-free bridged 的，设置好时间和回调函数后加到正在运行的 run loop 中即可。具体信息可以参考这两个类的 API 文档。&lt;/p&gt;
&lt;h4 id=&quot;Run-Loop-Observers&quot;&gt;&lt;a href=&quot;#Run-Loop-Observers&quot; class=&quot;headerlink&quot; title=&quot;Run Loop Observers&quot;&gt;&lt;/a&gt;Run Loop Observers&lt;/h4&gt;&lt;p&gt;不同于 source 在同步或异步事件发生时触发，observer 会在 run loop 运行期间的某些特殊地方触发。这些 run loop 中『特殊』的地方列举如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入 run loop&lt;/li&gt;
&lt;li&gt;当 run loop 即将处理一个 timer&lt;/li&gt;
&lt;li&gt;当 run loop 即将处理一个 input source&lt;/li&gt;
&lt;li&gt;当 run loop 即将休眠&lt;/li&gt;
&lt;li&gt;当 run loop 已经被唤醒，但在它处理唤醒它的事件之前&lt;/li&gt;
&lt;li&gt;退出 run loop&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以使用 Core Foundation 的 &lt;code&gt;CFRunLoopObserverRef&lt;/code&gt; 类创建 run loop observer。&lt;code&gt;CFRunLoopObserverRef&lt;/code&gt; 记录了回调函数和关注的事件类型（上面 6 种时间的掩码），它跟 timer 一样可以在创建的时候选择只触发一次或重复触发。&lt;/p&gt;
&lt;h4 id=&quot;Run-Loop-事件顺序&quot;&gt;&lt;a href=&quot;#Run-Loop-事件顺序&quot; class=&quot;headerlink&quot; title=&quot;Run Loop 事件顺序&quot;&gt;&lt;/a&gt;Run Loop 事件顺序&lt;/h4&gt;&lt;p&gt;线程的 run loop 每次运行都会处理待决的事件，并为绑定的所有 observer 生成通知。次序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通知 observer 已经进入 run loop&lt;/li&gt;
&lt;li&gt;通知 observer 有 timer 将要触发&lt;/li&gt;
&lt;li&gt;通知 observer 有非基于端口的 input source 将要触发&lt;/li&gt;
&lt;li&gt;触发所有已就绪的非基于端口的 input source&lt;/li&gt;
&lt;li&gt;如果一个基于端口的 input source 已就绪并等待触发，立即处理事件，并转至&lt;strong&gt;第 9 步&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通知 observer 线程即将休眠&lt;/li&gt;
&lt;li&gt;让线程休眠，直到被以下条件唤醒：&lt;ul&gt;
&lt;li&gt;有基于端口的 input source 事件到达&lt;/li&gt;
&lt;li&gt;timer 触发&lt;/li&gt;
&lt;li&gt;run loop 设定的超时时间到了&lt;/li&gt;
&lt;li&gt;run loop 被手动唤醒&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通知 observer 线程刚刚被唤醒&lt;/li&gt;
&lt;li&gt;处理待决事件&lt;ul&gt;
&lt;li&gt;如果用户定义的 timer 触发了，处理 timer 事件并重启 run loop，跳回到&lt;strong&gt;第 2 步&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 input source 触发了，分发事件&lt;/li&gt;
&lt;li&gt;如果 run loop 被唤醒且没有超时，重启 run loop，跳回到&lt;strong&gt;第 2 步&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通知 observer 已经退出 run loop&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 timer 和 input source 对 observer 的通知是在事件真正发生前就已经发出，所以这之间会有时间间隔。如果对事件时间的掌控很严格，可以使用休眠和唤醒的通知帮你关联实际事件的时机。&lt;/p&gt;
&lt;p&gt;由于 timer 和其他周期性事件是在运行 run loop 的时候发送的，绕过 loop 会打断这些事件的发送。典型的案例就是在实现鼠标追踪程序中写了个不断从应用请求事件的循环逻辑，按理说应该是让应用正常地分发这些事件，而不是主动抓取。这就导致 timer 被开发者写的循环逻辑阻塞而一直无法触发。&lt;/p&gt;
&lt;p&gt;可以使用 run loop 对象将其手动唤醒，其他事件也可能导致 run loop 被唤醒。比如添加另一个非基于端口的 input source 唤醒 run loop，input source 就能立刻被处理，而不是一直等到其他事件发生。&lt;/p&gt;
&lt;h3 id=&quot;该何时使用-Run-Loop？&quot;&gt;&lt;a href=&quot;#该何时使用-Run-Loop？&quot; class=&quot;headerlink&quot; title=&quot;该何时使用 Run Loop？&quot;&gt;&lt;/a&gt;该何时使用 Run Loop？&lt;/h3&gt;&lt;p&gt;需要手动运行 run loop 的场景只有一个，那就是你创建次级线程的时候。应用主线程的 run loop 是基础设施中至关重要的部分。应用框架会把自动运行主线程 run loop 的程序写好，比如 &lt;code&gt;UIApplication&lt;/code&gt; 或 &lt;code&gt;NSApplication&lt;/code&gt; 中的 &lt;code&gt;run&lt;/code&gt;。如果使用 Xcode 带的模板创建工程，千万不要去调用这些方法。&lt;/p&gt;
&lt;p&gt;对于次级线程是否有必要手动开启 run loop，那要看实际情况了。比如使用线程执行一些预先设定好的运行时间较长的任务，可能就不需要开启 run loop 了。Run Loop 是为『想要与线程更多交互』的场景准备的，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 input source 与其他线程通信&lt;/li&gt;
&lt;li&gt;在线程中使用 timer&lt;/li&gt;
&lt;li&gt;在 Cocoa 应用中使用任何 &lt;code&gt;performSelector...&lt;/code&gt; 系列的方法&lt;/li&gt;
&lt;li&gt;让线程执行周期性任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果选择使用 run loop，配置和启动是很简单的。可是就所有的线程编程来说，应该计划好在合适的场景下退出次级线程，总比强行退出要好。&lt;/p&gt;
&lt;h3 id=&quot;使用-Run-Loop-对象&quot;&gt;&lt;a href=&quot;#使用-Run-Loop-对象&quot; class=&quot;headerlink&quot; title=&quot;使用 Run Loop 对象&quot;&gt;&lt;/a&gt;使用 Run Loop 对象&lt;/h3&gt;&lt;p&gt;Run Loop 对象提供了向 run loop 中添加 input source、timer 和 run-loop observer 的主要接口，并运行起来。每个线程都关联一个单独的 run loop。在 Cocoa 中，Run Loop 对象是个 &lt;code&gt;NSRunLoop&lt;/code&gt; 类的实例，在 Core Foundation 中是 &lt;code&gt;CFRunLoopRef&lt;/code&gt; 指针。但它们不是 toll-free bridge 的。&lt;/p&gt;
&lt;h4 id=&quot;获取-Run-Loop-对象&quot;&gt;&lt;a href=&quot;#获取-Run-Loop-对象&quot; class=&quot;headerlink&quot; title=&quot;获取 Run Loop 对象&quot;&gt;&lt;/a&gt;获取 Run Loop 对象&lt;/h4&gt;&lt;p&gt;获取当前线程的 run loop 对象有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cocoa 框架 &lt;code&gt;NSRunLoop&lt;/code&gt; 的类方法 &lt;code&gt;currentRunLoop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CFRunLoopGetCurrent&lt;/code&gt; 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以从 &lt;code&gt;NSRunLoop&lt;/code&gt; 对象的 &lt;code&gt;getCFRunLoop&lt;/code&gt; 方法获取到 &lt;code&gt;CFRunLoopRef&lt;/code&gt;，这样就可以传给 Core Foundation 程序使用了。二者都指向同一个 run loop，所以可以混用。&lt;/p&gt;
&lt;h4 id=&quot;配置-Run-Loop&quot;&gt;&lt;a href=&quot;#配置-Run-Loop&quot; class=&quot;headerlink&quot; title=&quot;配置 Run Loop&quot;&gt;&lt;/a&gt;配置 Run Loop&lt;/h4&gt;&lt;p&gt;在次级线程运行 run loop 之前，必须向其添加至少一个 input source 或 timer，否则 run loop 会因没有可监控的 source 而在运行后立刻退出。&lt;/p&gt;
&lt;p&gt;除了用 source 外，还可以用 run loop observer 观察 run loop 的各种运行阶段。做法是创建一个 &lt;code&gt;CFRunLoopObserverRef&lt;/code&gt; 类型的对象并用 &lt;code&gt;CFRunLoopAddObserver&lt;/code&gt; 函数将其添加到 run loop 中。注意的是只能用 Core Foundation 创建 run loop observer，Cocoa 框架无能为力。&lt;/p&gt;
&lt;p&gt;下面的示例代码在线程入口函数中创建了 run loop observer 并将其添加到 run loop 中。observer 监听了 run loop 所有的活动，并省略了回调函数 &lt;code&gt;myRunLoopObserver&lt;/code&gt; 的实现。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)threadMain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// The application uses garbage collection, so no autorelease pool is needed.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt;* myRunLoop = [&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Create a run loop observer and attach it to the run loop.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverContext&lt;/span&gt;  context = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverRef&lt;/span&gt;    observer = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverCreate&lt;/span&gt;(k&lt;span class=&quot;built_in&quot;&gt;CFAllocatorDefault&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopAllActivities&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &amp;amp;myRunLoopObserver, &amp;amp;context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (observer)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;    cfLoop = [myRunLoop get&lt;span class=&quot;built_in&quot;&gt;CFRunLoop&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRunLoopAddObserver&lt;/span&gt;(cfLoop, observer, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDefaultMode&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Create and schedule the timer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt; scheduledTimerWithTimeInterval:&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt; target:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(doFireTimer:) userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; repeats:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;    loopCount = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Run the run loop 10 times to let the timer fire.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [myRunLoop runUntilDate:[&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; dateWithTimeIntervalSinceNow:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        loopCount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (loopCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了不让 run loop 刚运行就立刻退出，上面的代码向 run loop 添加了一个 timer。因为 timer 一旦触发就无效了，依然会导致 run loop 退出，所以这里 &lt;code&gt;repeats&lt;/code&gt; 参数传入 &lt;code&gt;YES&lt;/code&gt;。但这样会让 run loop 一直运行很久，并需要周期性触发 timer 来唤醒线程，这实际上是轮询的另一种形式罢了。相比之下，input source 等待事件发生后才唤醒线程，在这之前线程保持休眠。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CFRunLoopObserverContext&lt;/code&gt; 结构体定义如下，查文档可知第二个参数 &lt;code&gt;info&lt;/code&gt; 会在回调函数被调用时当做参数传入，这里传入 &lt;code&gt;self&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFIndex&lt;/span&gt;	version;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*retain)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*release)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt;	(*copyDescription)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverContext&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;启动-Run-Loop&quot;&gt;&lt;a href=&quot;#启动-Run-Loop&quot; class=&quot;headerlink&quot; title=&quot;启动 Run Loop&quot;&gt;&lt;/a&gt;启动 Run Loop&lt;/h4&gt;&lt;p&gt;只有在应用的次级线程才需要启动 run loop，而且需要有至少一个 input source 或 timer，否则 run loop 启动后会立刻退出。&lt;/p&gt;
&lt;p&gt;启动 run loop 的几种方式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件：&lt;/li&gt;
&lt;li&gt;设定时间限制&lt;/li&gt;
&lt;li&gt;处于特定模式（Mode）&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;方法名(NSRunLoop)&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;无条件&lt;/td&gt;
&lt;td&gt;run&lt;/td&gt;
&lt;td&gt;最简单但也最不可取的方案。会让线程进入无限循环，对 run loop 很难控制。可以添加和移除 input source 和 timer，但只能通过 kill 的方式停止 run loop。也无法在自定义模式下运行 run loop。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设定时间限制&lt;/td&gt;
&lt;td&gt;runUntilDate:&lt;/td&gt;
&lt;td&gt;run loop 在收到事件或超时前会一直运行。run loop 结束后可以重启，并处理接下来的事情。比上一种方式更好，提供了时间限制。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处于特定模式&lt;/td&gt;
&lt;td&gt;runMode:beforeDate:&lt;/td&gt;
&lt;td&gt;相比上一种方式，增加了在特定模式下运行 run loop。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 和 &lt;code&gt;runUntilDate:&lt;/code&gt; 方法会使用 &lt;code&gt;NSDefaultRunLoopMode&lt;/code&gt; 参数不断调用 &lt;code&gt;runMode:beforeDate:&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;下面的代码展示了一个线程入口函数的大纲，主要是 run loop 的基本构成。本质上就是配置好 run loop 并运行后，每轮运行后不断检查是否需要退出线程。使用 Core Foundation 可以检查 run loop 每次运行的结果，并决定是否需要退出线程。当然也可以使用上面 &lt;code&gt;NSRunLoop&lt;/code&gt; 提供的 API，而且无需检查每次运行的返回值。后面会有例子。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)skeletonThreadMain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Set up an autorelease pool here if not using garbage collection.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; done = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Add your sources or timers to the run loop and do any other setup.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Start the run loop but return after each source is handled.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SInt32    result = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunInMode&lt;/span&gt;(k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDefaultMode&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// If a source explicitly stopped the run loop, or if there are no&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// sources or timers, go ahead and exit.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((result == k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunStopped&lt;/span&gt;) || (result == k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunFinished&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            done = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Check for any other exit conditions here and set the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// done variable as needed.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!done);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Clean up code here. Be sure to release any allocated autorelease pools.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实上面这段调用 &lt;code&gt;CFRunLoopRunInMode()&lt;/code&gt; 的逻辑跟 &lt;code&gt;CFRunLoopRun()&lt;/code&gt; 差不多。&lt;/p&gt;
&lt;p&gt;可以递归启动 run loop。也就是说可以在 input source 或 timer 的回调处理函数中调用 &lt;code&gt;CFRunLoopRun&lt;/code&gt;, &lt;code&gt;CFRunLoopRunInMode&lt;/code&gt; 或上面提到的 &lt;code&gt;NSRunLoop&lt;/code&gt; 的三个方法，而且嵌套的 run loop 可以在任意 Mode 下运行。&lt;/p&gt;
&lt;h4 id=&quot;退出-Run-Loop&quot;&gt;&lt;a href=&quot;#退出-Run-Loop&quot; class=&quot;headerlink&quot; title=&quot;退出 Run Loop&quot;&gt;&lt;/a&gt;退出 Run Loop&lt;/h4&gt;&lt;p&gt;在 run loop 已经将事件处理之前有两种退出的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给 run loop 配置 timeout 值&lt;/li&gt;
&lt;li&gt;告诉 run loop 停止&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐第一种方法，因为它会让 run loop 完成一切正常的处理，包括在退出前向 observer 发通知。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;CFRunLoopStop&lt;/code&gt; 函数停止 run loop 的结果跟第一种方式差不多，run loop 会把剩下的通知发出去，然后退出。不同点在于可以用这个函数停止以无条件方式（&lt;code&gt;run&lt;/code&gt; 方法）启动的 run loop。要注意的是 &lt;code&gt;CFRunLoopStop&lt;/code&gt; 只会停止对 &lt;code&gt;CFRunLoopRun&lt;/code&gt; 和 &lt;code&gt;CFRunLoopRunInMode&lt;/code&gt; 的调用，对于 Cocoa 框架相当于只停止一次 &lt;code&gt;runMode:beforeDate:&lt;/code&gt; 的调用，而不是退出 run loop。stop 一次运行和 exit 整个 run loop 是不一样的。&lt;/p&gt;
&lt;p&gt;虽然移除 run loop 的 input source 和 timer 也会导致其退出，但这种方法不可靠。因为有些系统程序会向 run loop 中添加 input source，开发者根本不知道有这回事，移除的时候就会漏掉，自然就不会导致 run loop 退出。&lt;/p&gt;
&lt;h4 id=&quot;线程安全和-Run-Loop-对象&quot;&gt;&lt;a href=&quot;#线程安全和-Run-Loop-对象&quot; class=&quot;headerlink&quot; title=&quot;线程安全和 Run Loop 对象&quot;&gt;&lt;/a&gt;线程安全和 Run Loop 对象&lt;/h4&gt;&lt;p&gt;使用 Core Foundation 中的函数操作 run loop 对象一般都是线程安全的，可以在任何线程调用。如果要更改 run loop 的配置，尽可能在 run loop 自己的线程操作。&lt;/p&gt;
&lt;p&gt;Cocoa 中对应的 &lt;code&gt;NSRunLoop&lt;/code&gt; 内部并不是线程安全的，必须在 run loop 所在的线程修改它。向其他线程的 run loop 添加 input source 或 timer 都会导致 crash 或异常行为。&lt;/p&gt;
&lt;h3 id=&quot;配置-Run-Loop-Source&quot;&gt;&lt;a href=&quot;#配置-Run-Loop-Source&quot; class=&quot;headerlink&quot; title=&quot;配置 Run Loop Source&quot;&gt;&lt;/a&gt;配置 Run Loop Source&lt;/h3&gt;&lt;p&gt;主要演示使用 Cocoa 和 Core Foundation 设置各种类型的 source。&lt;/p&gt;
&lt;h4 id=&quot;定义-Custom-Input-Source&quot;&gt;&lt;a href=&quot;#定义-Custom-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;定义 Custom Input Source&quot;&gt;&lt;/a&gt;定义 Custom Input Source&lt;/h4&gt;&lt;p&gt;创建 custom input source 需要阐明如下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想让 input source 处理的信息&lt;/li&gt;
&lt;li&gt;用于让外部 client 获知如何联系 input source 的 scheduler 程序&lt;/li&gt;
&lt;li&gt;执行任何 client 发出请求的 perform 程序&lt;/li&gt;
&lt;li&gt;作废 input source 的 cancellation 程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Custom Input Source 的配置是很灵活的，scheduler，perform 和 cancellation 这几个程序的实现才是关键。然而 input source 剩余的大部分行为都发生在这些程序的外部，需要开发者自己定义一个机制，用于向 input source 传递数据和暴漏 input source 给其他线程。&lt;/p&gt;
&lt;p&gt;下图展示了一个配置 custom input source 的例子。主线程维护了对 input source 及其 custom command buffer 和 run loop 的引用。当主线程想要把一个任务切换到 worker 线程的时候，会向 command buffer 发送一条命令。这条命令包含了 worker 线程启动任务所需的任何信息。由于主线程和 worker 线程的 input source 都可以存取 command buffer，所以存取操作需要被同步。一旦命令发出，主线程对 input source 发信号，并唤醒 worker 线程的 run loop。Run Loop 一旦收到了唤醒命令，就会调用 input source 的 handler 程序，handler 会处理 command buffer 中的命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面会解释上图中 custom input source 的实现，并展示需要实现的关键代码。&lt;/p&gt;
&lt;h5 id=&quot;定义-Input-Source&quot;&gt;&lt;a href=&quot;#定义-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;定义 Input Source&quot;&gt;&lt;/a&gt;定义 Input Source&lt;/h5&gt;&lt;p&gt;需要用 Core Foundation 配置 run loop source，并将其加到 run loop 中。因为 handler 都是基于 C 的函数，所以需要将其封装成 Objective-C 的接口。下面的代码封装了两个 Objective-C 类：&lt;code&gt;RunLoopSource&lt;/code&gt; 封装了 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt;，并管理一个 command buffer，并使用 buffer 接收其他线程的消息。&lt;code&gt;RunLoopContext&lt;/code&gt; 封装了 &lt;code&gt;CFRunLoopRef&lt;/code&gt; 和 &lt;code&gt;RunLoopSource&lt;/code&gt; 指针，用于向应用主线程传递 source 对象和 run loop 引用。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RunLoopSource&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceRef&lt;/span&gt; runLoopSource;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;* commands;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)addToCurrentRunLoop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)invalidate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Handler method&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sourceFired;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Client interface for registering commands to process&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)addCommand:(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)command withData:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)fireAllCommandsOnRunLoop:(&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;)runloop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// These are the CFRunLoopSourceRef callback functions.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; RunLoopSourceScheduleRoutine (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt; mode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; RunLoopSourcePerformRoutine (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; RunLoopSourceCancelRoutine (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt; mode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// RunLoopContext is a container object used during registration of the input source.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RunLoopContext&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;        runLoop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopSource*        source;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; runLoop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) RunLoopSource* source;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)initWithSource:(RunLoopSource*)src andLoop:(&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;)loop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面会分别列出 scheduler，handler 和 cancellation 三个 C 语言的回调函数的实现。&lt;/p&gt;
&lt;p&gt;第一个被调用的函数是 scheduler，当你把 source 添加到 run loop 中时就会调用。按照之前的实例，我们的 input source 只有一个 client，也就是主线程。这里 scheduler 做的事情就是用 application delegate 的 &lt;code&gt;registerSource:&lt;/code&gt; 方法将 &lt;code&gt;RunLoopContext&lt;/code&gt; 对象中的信息传递过去，以便之后 application delegate 与 input source 通信时使用。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void RunLoopSourceScheduleRoutine (&lt;span class=&quot;name&quot;&gt;void&lt;/span&gt; *info, CFRunLoopRef rl, CFStringRef mode)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopSource* obj = (&lt;span class=&quot;name&quot;&gt;__bridge&lt;/span&gt; RunLoopSource*)info&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AppDelegate*   del = [AppDelegate sharedAppDelegate]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource&lt;span class=&quot;symbol&quot;&gt;:obj&lt;/span&gt; andLoop&lt;span class=&quot;symbol&quot;&gt;:rl&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [del performSelectorOnMainThread:@selector(&lt;span class=&quot;name&quot;&gt;registerSource&lt;/span&gt;:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                withObject&lt;span class=&quot;symbol&quot;&gt;:theContext&lt;/span&gt; waitUntilDone&lt;span class=&quot;symbol&quot;&gt;:NO&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当 input source 被发信号（signal）的时候，用于处理数据的 perform 函数会被调用，它是最重要的回调之一。这里很简单地转发给了 &lt;code&gt;RunLoopSource&lt;/code&gt; 的 &lt;code&gt;sourceFired&lt;/code&gt; 方法。后面会列出 &lt;code&gt;sourceFired&lt;/code&gt; 处理 command buffer 的逻辑。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void RunLoopSourcePerformRoutine (&lt;span class=&quot;name&quot;&gt;void&lt;/span&gt; *info)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopSource*  obj = (&lt;span class=&quot;name&quot;&gt;__bridge&lt;/span&gt; RunLoopSource*)info&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [obj sourceFired]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果用调用 &lt;code&gt;CFRunLoopSourceInvalidate&lt;/code&gt; 函数之类的方式将 input source 从它的 run loop 中移除，系统会调用 input source 的 cancellation 程序。可以在这个程序中告诉 client 可以移除对 input source 的引用了，因为它已经失效了。下面的 cancellation 回调函数将传入的 &lt;code&gt;RunLoopSource&lt;/code&gt; 对象和 &lt;code&gt;CFRunLoopRef&lt;/code&gt; 打包成一个 &lt;code&gt;RunLoopContext&lt;/code&gt;，并传给 application delegate。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void RunLoopSourceCancelRoutine (&lt;span class=&quot;name&quot;&gt;void&lt;/span&gt; *info, CFRunLoopRef rl, CFStringRef mode)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopSource* obj = (&lt;span class=&quot;name&quot;&gt;__bridge&lt;/span&gt; RunLoopSource*)info&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AppDelegate* del = [AppDelegate sharedAppDelegate]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource&lt;span class=&quot;symbol&quot;&gt;:obj&lt;/span&gt; andLoop&lt;span class=&quot;symbol&quot;&gt;:rl&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [del performSelectorOnMainThread:@selector(&lt;span class=&quot;name&quot;&gt;removeSource&lt;/span&gt;:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                withObject&lt;span class=&quot;symbol&quot;&gt;:theContext&lt;/span&gt; waitUntilDone&lt;span class=&quot;symbol&quot;&gt;:YES&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这三个回调函数中 application delegate 的 &lt;code&gt;registerSource:&lt;/code&gt; 和 &lt;code&gt;removeSource:&lt;/code&gt; 方法暂时省略，后面会列出。这三个回调函数会在创建 custom input source 的时候当做参数传入。&lt;/p&gt;
&lt;h5 id=&quot;在-Run-Loop-上装载-Input-Source&quot;&gt;&lt;a href=&quot;#在-Run-Loop-上装载-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;在 Run Loop 上装载 Input Source&quot;&gt;&lt;/a&gt;在 Run Loop 上装载 Input Source&lt;/h5&gt;&lt;p&gt;下面代码是 &lt;code&gt;RunLoopSource&lt;/code&gt; 类的 &lt;code&gt;init&lt;/code&gt; 和 &lt;code&gt;addToCurrentRunLoop&lt;/code&gt; 方法。&lt;code&gt;init&lt;/code&gt; 创建了一个 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt;，这才是真正被添加到 run loop 中的类型。当 worker 线程调用 &lt;code&gt;addToCurrentRunLoop&lt;/code&gt; 方法时，才会将 input source 装载到 run loop 中，并在此时调用 &lt;code&gt;RunLoopSourceScheduleRoutine&lt;/code&gt; 回调函数。之后就可以启动 run loop 了。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceContext&lt;/span&gt;    context = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, (__bridge &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;), &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        &amp;amp;RunLoopSourceScheduleRoutine,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        &amp;amp;RunLoopSourceCancelRoutine,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        &amp;amp;RunLoopSourcePerformRoutine&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runLoopSource = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceCreate&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &amp;amp;context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    commands = [[&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)addToCurrentRunLoop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; runLoop = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopAddSource&lt;/span&gt;(runLoop, runLoopSource, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDefaultMode&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;CFRunLoopSourceContext&lt;/code&gt; 结构体描述了 custom input source（source0）的上下文，而 &lt;code&gt;CFRunLoopSourceContext1&lt;/code&gt; 结构体描述了 port-based input source（source1）的上下文。看文档可知，&lt;code&gt;info&lt;/code&gt; 用于向回调函数传入数据，&lt;code&gt;schedule&lt;/code&gt;，&lt;code&gt;cancel&lt;/code&gt; 和 &lt;code&gt;perform&lt;/code&gt; 分别对应上面代码中传入的三个回调函数。将这些信息打包进上下文后，就可以用 &lt;code&gt;CFRunLoopSourceCreate&lt;/code&gt; 函数创建 run loop 对象了。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFIndex&lt;/span&gt;	version;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*retain)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*release)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt;	(*copyDescription)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean	(*equal)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info1, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFHashCode&lt;/span&gt;	(*hash)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*schedule)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; mode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*cancel)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; mode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*perform)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceContext&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFIndex&lt;/span&gt;	version;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *(*retain)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*release)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt;	(*copyDescription)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean	(*equal)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info1, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFHashCode&lt;/span&gt;	(*hash)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#if (TARGET_OS_MAC &amp;amp;&amp;amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mach_port_t	(*getPort)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	(*perform)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *msg, &lt;span class=&quot;built_in&quot;&gt;CFIndex&lt;/span&gt; size, &lt;span class=&quot;built_in&quot;&gt;CFAllocatorRef&lt;/span&gt; allocator, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *	(*getPort)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;	(*perform)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceContext1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两种 Context 的结构很相似，所以 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt; 中使用 &lt;code&gt;union&lt;/code&gt; 存储这两个互斥存在的结构体，内存占用上只差一个指针：&lt;/p&gt;
&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__CFRunLoopSource&lt;/span&gt; * &lt;span class=&quot;title&quot;&gt;CFRunLoopSourceRef&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__CFRunLoopSource&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFRuntimeBase _base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint32_t _bits;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_mutex_t _lock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFIndex _order;			&lt;span class=&quot;regexp&quot;&gt;/* immutable */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFMutableBagRef _runLoops;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CFRunLoopSourceContext version0;	&lt;span class=&quot;regexp&quot;&gt;/* immutable, except invalidation */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CFRunLoopSourceContext1 version1;	&lt;span class=&quot;regexp&quot;&gt;/* immutable, except invalidation */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; _context;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;Input-Source-与-Client-的协作&quot;&gt;&lt;a href=&quot;#Input-Source-与-Client-的协作&quot; class=&quot;headerlink&quot; title=&quot;Input Source 与 Client 的协作&quot;&gt;&lt;/a&gt;Input Source 与 Client 的协作&lt;/h5&gt;&lt;p&gt;自定义的 input source 需要由其他线程手动发信号。重点是其线程在这之前会一直处于休眠状态，所以一定要让其他线程知道这个 input source，并能与之通信。&lt;/p&gt;
&lt;p&gt;当 input source 第一次装载到 run loop 的时候，可以向 client 发送注册 input source 的请求。可以将一个 input source 直接或间接注册到多个 client 中。下面的代码展示了 application delegate 提供的注册方法 &lt;code&gt;registerSource:&lt;/code&gt;，之前提到过回调函数 &lt;code&gt;RunLoopSourceScheduleRoutine&lt;/code&gt; 的实现会调用 &lt;code&gt;registerSource:&lt;/code&gt;。也就是说执行流程是 install(&lt;code&gt;addToCurrentRunLoop&lt;/code&gt;) -&amp;gt; schedule(&lt;code&gt;RunLoopSourceScheduleRoutine&lt;/code&gt;) -&amp;gt; register(&lt;code&gt;registerSource:&lt;/code&gt;)。对应地，当 input source 从 run loop 中被移除，回调函数 &lt;code&gt;RunLoopSourceCancelRoutine&lt;/code&gt; 中会调用 &lt;code&gt;removeSource:&lt;/code&gt; 方法。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;registerSource:&lt;/span&gt;(RunLoopContext*)sourceInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [sourcesToPing &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;sourceInfo];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;removeSource:&lt;/span&gt;(RunLoopContext*)sourceInfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id    objToRemove = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (RunLoopContext* context &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sourcesToPing)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([context &lt;span class=&quot;string&quot;&gt;isEqual:&lt;/span&gt;sourceInfo])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            objToRemove = context;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (objToRemove)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [sourcesToPing &lt;span class=&quot;string&quot;&gt;removeObject:&lt;/span&gt;objToRemove];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码逻辑很简单，就是 application delegate 维护了一个存储 &lt;code&gt;RunLoopContext&lt;/code&gt; 对象的可变数组 &lt;code&gt;sourcesToPing&lt;/code&gt;，并提供了增加和移除数组元素的两个方法。&lt;/p&gt;
&lt;h5 id=&quot;给-Input-Source-发信号-Signal&quot;&gt;&lt;a href=&quot;#给-Input-Source-发信号-Signal&quot; class=&quot;headerlink&quot; title=&quot;给 Input Source 发信号(Signal)&quot;&gt;&lt;/a&gt;给 Input Source 发信号(Signal)&lt;/h5&gt;&lt;p&gt;Client 在将数据传递给 input source 后，还需要给 source 发信号，并唤醒 run loop。发信号的作用是让 run loop 知道 input source 已经做好被处理的准备了。当信号发出时线程可能还在休眠，所以必须唤醒 run loop。否则可能会导致延迟处理 input source。&lt;/p&gt;
&lt;p&gt;下面代码展示了 &lt;code&gt;RunLoopSource&lt;/code&gt; 对象的 &lt;code&gt;fireCommandsOnRunLoop&lt;/code&gt; 方法。当 Client 准备好让 source 处理 command buffer 中的命令时会调用这个方法。&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;fireCommandsOnRunLoop:&lt;span class=&quot;params&quot;&gt;(CFRunLoopRef)&lt;/span&gt;runloop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFRunLoopSourceSignal&lt;span class=&quot;params&quot;&gt;(runLoopSource)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFRunLoopWakeUp&lt;span class=&quot;params&quot;&gt;(runloop)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;配置-Timer-Source&quot;&gt;&lt;a href=&quot;#配置-Timer-Source&quot; class=&quot;headerlink&quot; title=&quot;配置 Timer Source&quot;&gt;&lt;/a&gt;配置 Timer Source&lt;/h4&gt;&lt;p&gt;使用不同框架创建 timer 对象的方式略有差别：Cocoa 中使用 &lt;code&gt;NSTimer&lt;/code&gt;，Core Foundation 中使用 &lt;code&gt;CFRunLoopTimerRef&lt;/code&gt; 类型。二者是 toll-free bridged 的，但是 &lt;code&gt;NSTimer&lt;/code&gt; 提供的 API 更便捷。比如可以用下面的方法马上创建并安排（schedule）好一个 timer：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;scheduledTimerWithTimeInterval:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;target:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;selector:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;userInfo:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;repeats:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;scheduledTimerWithTimeInterval:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;invocation:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;repeats:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这些方法会创建 timer 并添加到当前线程 run loop 的 Default Mode 中。也可以手动创建一个 &lt;code&gt;NSTimer&lt;/code&gt; 对象并用 &lt;code&gt;NSRunLoop&lt;/code&gt; 的 &lt;code&gt;addTimer:forMode:&lt;/code&gt; 方法将其添加到 run loop 的指定 Mode 中。这些方法做的事情都差不多，只是对 timer 配置的掌控程度不同。下面的代码展示了两种添加 timer 的方式：第一个 timer 延迟 1 秒触发并每隔 0.1 秒重复触发，第二个 timer 延迟 0.2 秒触发然后每隔 0.2 秒重复触发。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt;* myRunLoop = [&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create and schedule the first timer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt;* futureDate = [&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; dateWithTimeIntervalSinceNow:&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt;* myTimer = [[&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt; alloc] initWithFireDate:futureDate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        interval:&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        target:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(myDoFireTimer1:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        repeats:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[myRunLoop addTimer:myTimer forMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create and schedule the second timer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt; scheduledTimerWithTimeInterval:&lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        target:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(myDoFireTimer2:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        repeats:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面的代码展示了如何使用 Core Foundation 函数配置 timer。虽然这个例子并没有在 &lt;code&gt;context&lt;/code&gt; 结构体中传递任何用户定义的信息，但你可以用这个结构体传送 timer 所需的一切自定义信息。可以查看文档了解下 &lt;code&gt;CFRunLoopTimerRef&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; runLoop = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimerContext&lt;/span&gt; context = &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimerRef&lt;/span&gt; timer = &lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimerCreate&lt;/span&gt;(k&lt;span class=&quot;built_in&quot;&gt;CFAllocatorDefault&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        &amp;amp;my&lt;span class=&quot;built_in&quot;&gt;CFTimerCallback&lt;/span&gt;, &amp;amp;context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopAddTimer&lt;/span&gt;(runLoop, timer, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopCommonModes&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;配置-Port-Based-Input-Source&quot;&gt;&lt;a href=&quot;#配置-Port-Based-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;配置 Port-Based Input Source&quot;&gt;&lt;/a&gt;配置 Port-Based Input Source&lt;/h4&gt;&lt;p&gt;Cocoa 和 Core Foundation 都提供了用于线程间或进程间通讯的基于端口（port-based）的对象。下面展示了如何用几种不同类型的端口来设置端口通信。&lt;/p&gt;
&lt;h5 id=&quot;配置-NSMachPort-对象&quot;&gt;&lt;a href=&quot;#配置-NSMachPort-对象&quot; class=&quot;headerlink&quot; title=&quot;配置 NSMachPort 对象&quot;&gt;&lt;/a&gt;配置 &lt;code&gt;NSMachPort&lt;/code&gt; 对象&lt;/h5&gt;&lt;p&gt;使用 &lt;code&gt;NSMachPort&lt;/code&gt; 对象建立本地连接过程如下：创建 &lt;code&gt;NSMachPort&lt;/code&gt; 对象并添加到主线程的 run loop 中。当启动次级线程时将这个 &lt;code&gt;NSMachPort&lt;/code&gt; 对象传递给次级线程的入口函数。次级线程会用这个 &lt;code&gt;NSMachPort&lt;/code&gt; 对象往主线程发消息。&lt;/p&gt;
&lt;h6 id=&quot;实现主线程代码&quot;&gt;&lt;a href=&quot;#实现主线程代码&quot; class=&quot;headerlink&quot; title=&quot;实现主线程代码&quot;&gt;&lt;/a&gt;实现主线程代码&lt;/h6&gt;&lt;p&gt;下面的代码展示了启动次级 worker 线程的主要代码。使用 Cocoa 框架写出的代码要比 Core Foundation 的少多了，但效果几乎一样。有个不同点是 Cocoa 直接传递 &lt;code&gt;NSPort&lt;/code&gt; 对象，而 Core Foundation 传递端口名字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)launchThread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;* myPort = [&lt;span class=&quot;built_in&quot;&gt;NSMachPort&lt;/span&gt; port];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (myPort)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// This class handles incoming port messages.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [myPort setDelegate:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Install the port as an input source on the current run loop.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop] addPort:myPort forMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Detach the thread. Let the worker release the port.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; detachNewThreadSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(LaunchThreadWithPort:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               toTarget:[MyWorkerClass class] withObject:myPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们想要在次级线程启动一切正常后给主线程通过本地端口通信报个平安，下面的 &lt;code&gt;handlePortMessage:&lt;/code&gt; 方法会在线程自己的本地端口收到数据后被调用。&lt;code&gt;NSPortMessage&lt;/code&gt; 持有两个端口对象：发送端口和接收端口。&lt;code&gt;handlePortMessage:&lt;/code&gt; 方法中使用 &lt;code&gt;[portMessage sendPort]&lt;/code&gt; 获取到了发送端口对象，也就是次级线程拥有的本地端口。也就是次级线程启动后会给主线程发消息，告知自己的端口对象，主线程会将其存下来以备日后使用。&lt;code&gt;msgid&lt;/code&gt; 标记了消息的唯一 ID。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define kCheckinMessage 100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Handle responses from the worker thread.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)handlePortMessage:(&lt;span class=&quot;built_in&quot;&gt;NSPortMessage&lt;/span&gt; *)portMessage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; message = [portMessage msgid];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;* distantPort = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (message == kCheckinMessage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the worker thread’s communications port.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        distantPort = [portMessage sendPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Retain and save the worker port for later use.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; storeDistantPort:distantPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Handle other messages.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;实现次级线程代码&quot;&gt;&lt;a href=&quot;#实现次级线程代码&quot; class=&quot;headerlink&quot; title=&quot;实现次级线程代码&quot;&gt;&lt;/a&gt;实现次级线程代码&lt;/h6&gt;&lt;p&gt;次级线程的入口函数会被传入主线程的端口对象，配置好次级线程后，使用主线程的端口对象来与主线程通信。下面代码中的 &lt;code&gt;MyWorkerClass&lt;/code&gt; 是个辅助类，它的 &lt;code&gt;sendCheckinMessage:&lt;/code&gt; 方法负责创建次级线程的本地端口，并发消息给主线程。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)LaunchThreadWithPort:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)inData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSAutoreleasePool&lt;/span&gt;*  pool = [[&lt;span class=&quot;built_in&quot;&gt;NSAutoreleasePool&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Set up the connection between this thread and the main thread.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;* distantPort = (&lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;*)inData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyWorkerClass*  workerObj = [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [workerObj sendCheckinMessage:distantPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [distantPort release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Let the run loop process things.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop] runMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            beforeDate:[&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; distantFuture]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (![workerObj shouldExit]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [workerObj release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [pool release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;t&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在线程间的单向通信中，同一个 &lt;code&gt;NSMachPort&lt;/code&gt; 对象既可以其所在线程的本地端口，又可以是其他线程的远程端口。也就是线程创建的本地端口对象对于其他现场来说是远程端口。下面的代码展示了 &lt;code&gt;sendCheckinMessage:&lt;/code&gt; 方法的实现。它创建了次级线程的本地端口，并使用主线程从 &lt;code&gt;LaunchThreadWithPort:&lt;/code&gt; 方法传来的端口对象，构建了 &lt;code&gt;NSPortMessage&lt;/code&gt; 消息对象，设置好 &lt;code&gt;msgid&lt;/code&gt; 后，然后立即发送出去。&lt;/p&gt;
&lt;figure class=&quot;highlight smali&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Worker thread&lt;span class=&quot;built_in&quot;&gt; check-in &lt;/span&gt;method&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)sendCheckinMessage:(NSPort*)outPort&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Retain&lt;span class=&quot;built_in&quot;&gt; and &lt;/span&gt;save the remote port for future use.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self setRemotePort:outPort];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Create&lt;span class=&quot;built_in&quot;&gt; and &lt;/span&gt;configure the worker thread port.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSPort* myPort = [NSMachPort port];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [myPort setDelegate:self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRun&lt;span class=&quot;class&quot;&gt;LoopMode];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Create the&lt;span class=&quot;built_in&quot;&gt; check-in &lt;/span&gt;message.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSPortMessage* messageObj = [[NSPortMessage alloc] initWithSendPort:outPort&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                         receivePort:myPort components:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt; if &lt;/span&gt;(messageObj)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Finish configuring the message&lt;span class=&quot;built_in&quot;&gt; and &lt;/span&gt;send it immediately.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [messageObj setMsgid:kCheckinMessage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [messageObj sendBeforeDate:[NSDate date]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;配置-NSMessagePort-对象&quot;&gt;&lt;a href=&quot;#配置-NSMessagePort-对象&quot; class=&quot;headerlink&quot; title=&quot;配置 NSMessagePort 对象&quot;&gt;&lt;/a&gt;配置 &lt;code&gt;NSMessagePort&lt;/code&gt; 对象&lt;/h5&gt;&lt;p&gt;如果用 &lt;code&gt;NSMessagePort&lt;/code&gt; 对象建立本地连接，不能在线程间简单地传递端口对象，而是必须要拿到端口名称。使用一个字符串作为键在 &lt;code&gt;NSMessagePortNameServer&lt;/code&gt; 注册本地端口，并把这个字符串传给另外的线程，这样就能通过这个字符串获取到端口对象，接着用它通信。下面的代码展示了使用创建和注册 &lt;code&gt;NSMessagePort&lt;/code&gt; 的过程。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSPort&lt;/span&gt;* localPort = [[&lt;span class=&quot;built_in&quot;&gt;NSMessagePort&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Configure the object and add it to the current run loop.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[localPort setDelegate:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop] addPort:localPort forMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Register the port using a specific name. The name must be unique.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;* localPortName = [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;MyPortName&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;NSMessagePortNameServer&lt;/span&gt; sharedInstance] registerPort:localPort&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     name:localPortName];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;使用-Core-Foundation-配置基于端口的-Input-Source&quot;&gt;&lt;a href=&quot;#使用-Core-Foundation-配置基于端口的-Input-Source&quot; class=&quot;headerlink&quot; title=&quot;使用 Core Foundation 配置基于端口的 Input Source&quot;&gt;&lt;/a&gt;使用 Core Foundation 配置基于端口的 Input Source&lt;/h5&gt;&lt;p&gt;使用 Core Foundation 在主线程和其他线程之间建立一个双向通讯通道需要写更多的代码。&lt;/p&gt;
&lt;p&gt;首先在主线程中发起一个 worker 线程，然后创建端口用于监听其他线程的消息。跟之前使用 Cocoa 不同在于这里是将一个唯一的端口名传给 worker 线程的入口函数，而不是端口对象。&lt;/p&gt;
&lt;p&gt;官方文档中创建 &lt;code&gt;CFMessagePortRef&lt;/code&gt; 的相关方法在 iOS 7 之后已经失效了，而且使用 Cocoa 提供的 API 更加方便，这里不再贴出 Core Foundation 版本的示例代码。&lt;/p&gt;
&lt;p&gt;所以不推荐使用 Core Foundation 建立线程端口通讯，但是 macOS 上建立进程间通讯还是可以尝试的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第二部分。关于 Run Loop 的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/&quot;&gt;Threading Programming Guide(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/&quot;&gt;Threading Programming Guide(3)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yulingtianxia.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Threading Programming Guide(1)</title>
    <link href="http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/"/>
    <id>http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/</id>
    <published>2017-08-28T01:20:24.000Z</published>
    <updated>2017-10-14T16:41:52.086Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第一部分。&lt;/p&gt;
&lt;p&gt;其实苹果建议使用对线程的高级封装，比如 operation objects and Grand Central Dispatch，它们使用方便更加高效，可以参考 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Concurrency Programming Guide&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但了解更底层一些的内容其实更有趣，难道不是么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/&quot;&gt;Threading Programming Guide(2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/&quot;&gt;Threading Programming Guide(3)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;线程相关概念&quot;&gt;&lt;a href=&quot;#线程相关概念&quot; class=&quot;headerlink&quot; title=&quot;线程相关概念&quot;&gt;&lt;/a&gt;线程相关概念&lt;/h2&gt;&lt;h3 id=&quot;概要和术语&quot;&gt;&lt;a href=&quot;#概要和术语&quot; class=&quot;headerlink&quot; title=&quot;概要和术语&quot;&gt;&lt;/a&gt;概要和术语&lt;/h3&gt;&lt;p&gt;线程的概念在计算机组成原理中学过，在各个系统中的实现和行为也都大同小异。多线程编程有利也有弊：在提升程序运行效率和用户体验的同时也带来了线程间同步的种种问题。现在大多数 CPU 都是多核的，所以很多程序都是并发执行来提升性能。多线程编程的代码更复杂，尤其是在存取同一个数据时更需要注意。这里讲一讲 macOS 和 iOS 提供的有关线程的 API 以及同步机制。&lt;/p&gt;
&lt;p&gt;如果把进程(process)理解为一个运行着多个线程(thread)的程序，线程运算调度一条独立路径的代码。任务(work)可以理解成需要被执行的代码块或函数之类的抽象概念。&lt;/p&gt;
&lt;h3 id=&quot;替代技术&quot;&gt;&lt;a href=&quot;#替代技术&quot; class=&quot;headerlink&quot; title=&quot;替代技术&quot;&gt;&lt;/a&gt;替代技术&lt;/h3&gt;&lt;p&gt;亲自去创建底层意义上的线程很难操作，也很容易出问题。创建一个新的线程会消耗很多 CPU 和内存资源，所以尽可能先考虑下是否真的有必要创建线程。对于直接手动创建线程执行任务来说，可以替代的技术还有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operation objects: 封装了一套在辅助线程执行任务的 API，只关注提交的任务即可，线程管理的底层工作交给系统。&lt;/li&gt;
&lt;li&gt;Grand Central Dispatch: 也是基于任务的 API，功能更强大，队列的使用更加灵活，强烈推荐。&lt;/li&gt;
&lt;li&gt;Idle-time notifications: 如果一项任务较轻且优先级较低，可以趁着不忙的时候执行。使用通知中心的 &lt;code&gt;postNotification:&lt;/code&gt; 方法可以立即抛通知，这是个同步执行的方法。其实通知会先进入一个先入先出的通知队列中，出列后才会被分发到通知中心。可以使用 &lt;code&gt;NSNotificationQueue&lt;/code&gt; 的 &lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationqueue/1416340-enqueue&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;enqueueNotification:postingStyle:&lt;/code&gt;&lt;/a&gt; 方法异步发送通知，postingStyle 设为 &lt;a href=&quot;https://developer.apple.com/documentation/foundation/notificationqueue.postingstyle/1418001-whenidle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;NSPostWhenIdle&lt;/code&gt;&lt;/a&gt; 即可在 Runloop 空闲时发送通知。&lt;/li&gt;
&lt;li&gt;Asynchronous functions: 使用系统自带的异步函数，把线程创建和管理的工作交给系统。&lt;/li&gt;
&lt;li&gt;Timers: 使用定时器在主线程做一些微小的周期性任务，而无需手动创建线程。&lt;/li&gt;
&lt;li&gt;Separate processes: 如果任务跟应用关联不紧密、占用大量内存或是需要 root 权限，可以创建进程，而非线程。使用 &lt;code&gt;fork&lt;/code&gt; 函数创建进程后记得调用 &lt;code&gt;exec&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;苹果系统的支持&quot;&gt;&lt;a href=&quot;#苹果系统的支持&quot; class=&quot;headerlink&quot; title=&quot;苹果系统的支持&quot;&gt;&lt;/a&gt;苹果系统的支持&lt;/h3&gt;&lt;p&gt;macOS 和 iOS 提供了几种创建线程的技术，以及对线程之间管理和同步任务的支持。&lt;/p&gt;
&lt;h4 id=&quot;对线程的封装&quot;&gt;&lt;a href=&quot;#对线程的封装&quot; class=&quot;headerlink&quot; title=&quot;对线程的封装&quot;&gt;&lt;/a&gt;对线程的封装&lt;/h4&gt;&lt;p&gt;线程的底层实现是在 Mach 层的，虽然它提供了抢占式多任务处理模型和线程调度能力，但我们常用的还是 POSIX API 及其衍生出来的 API：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cocoa 线程: &lt;code&gt;NSThread&lt;/code&gt; 类以及 &lt;code&gt;NSObject&lt;/code&gt; 提供的线程 API。&lt;/li&gt;
&lt;li&gt;POSIX 线程: C 语言接口，比如创建线程的函数 &lt;code&gt;pthread_create&lt;/code&gt;。 &lt;code&gt;pthread_t&lt;/code&gt; 为线程句柄。&lt;/li&gt;
&lt;li&gt;Multiprocessing Services: 远古产物，弃用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同系统中线程的生命周期都差不多，在线程退出之前，会在运行(running)、阻塞(blocked)、准备(ready)状态之间切换。创建线程需要指定其入口函数，入口函数 &lt;code&gt;return&lt;/code&gt; 后会终止线程，线程会被系统回收。创建线程会占内存和 CPU 资源，所以在入口函数里执行比较重的任务才值当。或者可以用 Runloop 做一些循环的任务。&lt;/p&gt;
&lt;h4 id=&quot;Run-Loops&quot;&gt;&lt;a href=&quot;#Run-Loops&quot; class=&quot;headerlink&quot; title=&quot;Run Loops&quot;&gt;&lt;/a&gt;Run Loops&lt;/h4&gt;&lt;p&gt;run loop 管理了线程接收的事件。它监听事件 source，有事件发生时，系统会唤起线程并将事件发送给 run loop，然后调用事件对应的 handler 函数。没有事件发生时会让线程休眠。&lt;/p&gt;
&lt;p&gt;如果没有 run loop，线程的入口函数 &lt;code&gt;return&lt;/code&gt; 后就会终止线程。run loop 可以让线程保活的同时消耗最少的资源。它在没有事件发生时会让线程休眠，而不是让 CPU 空转。run loop 与线程是一对一的关系，线程创建时默认是没有 run loop 的。&lt;/p&gt;
&lt;p&gt;系统的主线程自动配置好了 run loop，可以通过 &lt;code&gt;CFRunLoopGetMain()&lt;/code&gt; 获得。其他线程可以使用 &lt;code&gt;CFRunLoopGetCurrent()&lt;/code&gt; 获得对应的 run loop 对象，在第一次执行 &lt;code&gt;CFRunLoopGetCurrent()&lt;/code&gt; 时，线程才会创建它的 run loop。获得 run loop 对象后，可以配置其事件处理函数，并运行 run loop。&lt;/p&gt;
&lt;p&gt;run loop 对应的 API 有两种：&lt;code&gt;NSRunLoop&lt;/code&gt; 和 &lt;code&gt;CFRunLoop&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NSRunLoop&lt;/code&gt; Cocoa 的 API,非线程安全，必须在当前线程上下文中调用。它是对 &lt;code&gt;CFRunLoop&lt;/code&gt; 的封装。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CFRunLoop&lt;/code&gt; 为 &lt;code&gt;Core Foundation&lt;/code&gt; 框架的 C 语言 API，线程安全。使用 &lt;code&gt;CFRunLoopRef&lt;/code&gt; 引用 run loop 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;同步工具&quot;&gt;&lt;a href=&quot;#同步工具&quot; class=&quot;headerlink&quot; title=&quot;同步工具&quot;&gt;&lt;/a&gt;同步工具&lt;/h4&gt;&lt;p&gt;多线程操作同一资源时要注意同步的问题，可以使用加锁、条件变量、原子操作等技术进行同步。&lt;/p&gt;
&lt;p&gt;加锁可以确保一段代码在某一时刻只能在一个线程中执行，最基本的是互斥锁(mutex, mutual exclusion)。Cocoa 提供了很多种锁来满足各种场景。&lt;/p&gt;
&lt;p&gt;当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。条件变量通过阻塞线程的方式确保了任务按正确的顺序执行，POSIX 层和 Foundation 框架都有 条件变量对应的 API。此外，Cocoa 提供的 operation objects 也能设置任务执行的顺序。&lt;/p&gt;
&lt;p&gt;原子操作适合同步多线程对标量数据类型的数学和逻辑运算，它跟锁相比，采用硬件指令优化，是一种轻量级同步工具。&lt;/p&gt;
&lt;h4 id=&quot;跨线程通信&quot;&gt;&lt;a href=&quot;#跨线程通信&quot; class=&quot;headerlink&quot; title=&quot;跨线程通信&quot;&gt;&lt;/a&gt;跨线程通信&lt;/h4&gt;&lt;p&gt;因为线程之间共用它们所属进程的相同空间，所以跨线程通信的方法有很多。它们各有优劣，按复杂度从低到高排列如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接发消息: &lt;code&gt;performSelector:onThread:withObject:waitUntilDone:modes:&lt;/code&gt; 等方法。&lt;/li&gt;
&lt;li&gt;全局变量，共用内存和对象: 相比直接发消息更快更容易，但也更脆弱。需要加锁之类的同步机制来确保代码的正确性，否则可能会导致竞态条件、错乱数据和crash。&lt;/li&gt;
&lt;li&gt;条件变量: 之前说过它也是一种线程同步工具，只有当符合某个条件时才让线程执行下去，相当于守门员的作用。&lt;/li&gt;
&lt;li&gt;Run loop sources: run loop input sources 有两种：port-based和 custom。这里说的是使用 custom run loop source 在某个线程上接收应用特定的消息。整个事件分发机制需要自己实现，包括设置 handler 函数，为 custom run loop source 提供数据，并手动给它发信号（signal）。&lt;/li&gt;
&lt;li&gt;端口和套接字: 基于端口的跨线程通信技术更复杂但也更可靠。更重要的是端口和套接字也可以与外部实体通信，比如其他进程和服务。为了高效，端口使用 port-based run loop sources 实现。&lt;/li&gt;
&lt;li&gt;消息队列: 古老的 Multiprocessing Services 定义了一个简单方便的 FIFO 队列来管理数据进出，但没其他跨线程通信技术效率高。&lt;/li&gt;
&lt;li&gt;Cocoa distributed objects: 对端口通信进行高级封装的 Cocoa API，其开销之大更适合跨进程通信。不建议用于跨线程通信，杀鸡用牛刀。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;设计秘籍&quot;&gt;&lt;a href=&quot;#设计秘籍&quot; class=&quot;headerlink&quot; title=&quot;设计秘籍&quot;&gt;&lt;/a&gt;设计秘籍&lt;/h3&gt;&lt;p&gt;这些建议和经验可以帮助开发者确保代码逻辑正确，性能更佳。&lt;/p&gt;
&lt;h4 id=&quot;避免直接创建线程&quot;&gt;&lt;a href=&quot;#避免直接创建线程&quot; class=&quot;headerlink&quot; title=&quot;避免直接创建线程&quot;&gt;&lt;/a&gt;避免直接创建线程&lt;/h4&gt;&lt;p&gt;手动创建线程很蛋疼还容易出错，所以要用其他 API 隐式实现并发，之前也提到了一些替代技术。建议使用 GCD 和 operation objects，可以根据当前系统负载自动调整活跃线程数量。&lt;/p&gt;
&lt;h4 id=&quot;让线程占用率适当&quot;&gt;&lt;a href=&quot;#让线程占用率适当&quot; class=&quot;headerlink&quot; title=&quot;让线程占用率适当&quot;&gt;&lt;/a&gt;让线程占用率适当&lt;/h4&gt;&lt;p&gt;手动创建管理线程时要注意线程消耗宝贵的系统资源，要做到物尽其所用，不能杀鸡用牛刀。更要毫不犹豫地终止大部分时间处于空闲状态的线程。线程占用的大量内存中有一部分是联动(wired)内存，所以释放那些使用率低的线程不仅可以减少应用的内存占用，也会为其他系统进程的运行释放更多物理内存。&lt;/p&gt;
&lt;p&gt;科普下苹果的内存使用相关术语：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wired(联动): 系统核心占用的，一直存在 RAM 上，永远不会被挪到硬盘中。联动内存占用跟使用的应用有关。&lt;/li&gt;
&lt;li&gt;Active(活跃): 表示这些内存数据正在使用中，或者刚被使用过。&lt;/li&gt;
&lt;li&gt;Inactive(非活跃): 表示这些内存中的数据是有效的，但是最近没有被使用。如果打开一个应用再退出，其所占用内存会变为非活跃内存，再次打开这个应用时如果那块内存没被其他应用使用，那么会那块非活跃内存会变为活跃内存（无需从硬盘加载），使得应用打开速度更快。&lt;/li&gt;
&lt;li&gt;Free(可用空间): RAM 中没被使用的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在终止线程前需要记录下当前的性能指标，并在终止线程之后再次记录，参照对比下是否真的提升了性能。&lt;/p&gt;
&lt;h4 id=&quot;避免共用数据结构&quot;&gt;&lt;a href=&quot;#避免共用数据结构&quot; class=&quot;headerlink&quot; title=&quot;避免共用数据结构&quot;&gt;&lt;/a&gt;避免共用数据结构&lt;/h4&gt;&lt;p&gt;避免线程相关资源冲突最简单的方法是每个线程都拷贝一份需要用的数据。线程之间通讯越少越好。&lt;/p&gt;
&lt;p&gt;即便对所有多线程场景下的共用数据加锁，就算再怎么仔细，代码可能依然在语义上不安全。比如代码逻辑要求用特定的顺序修改公用的数据结构，否则就会出问题。使用基于事务模型的代码可以弥补这个缺陷，但会进而抵消了多线程的性能优势。将资源竞争消灭在萌芽之中才会让方案更简单，性能更出众。&lt;/p&gt;
&lt;h4 id=&quot;线程与用户界面&quot;&gt;&lt;a href=&quot;#线程与用户界面&quot; class=&quot;headerlink&quot; title=&quot;线程与用户界面&quot;&gt;&lt;/a&gt;线程与用户界面&lt;/h4&gt;&lt;p&gt;建议在接受跟用户相关的事件和更新界面时使用主线程。因为 Cocoa 跟 UI 相关的 API 使用了一些全局变量，如果在其他线程去更新 UI 或者处理用户事件，就会发生一些同步问题。&lt;/p&gt;
&lt;p&gt;当然这个『在主线程更新界面』的规则也有些例外，比如在次级线程进行图像处理可以显著地提升性能。如果拿不准主意，那就干脆全在主线程去做吧。这样代码逻辑简单，易维护。&lt;/p&gt;
&lt;p&gt;Cocoa 图形绘制可以参考 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cocoa Drawing Guide&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;退出应用时注意线程的行为&quot;&gt;&lt;a href=&quot;#退出应用时注意线程的行为&quot; class=&quot;headerlink&quot; title=&quot;退出应用时注意线程的行为&quot;&gt;&lt;/a&gt;退出应用时注意线程的行为&lt;/h4&gt;&lt;p&gt;POSIX 线程按照资源释放方式分两种：joinable(non-detached) 和 detached。&lt;/p&gt;
&lt;p&gt;detached 类型的线程结束之后系统会自动回收其资源。假如在 A 线程中使用 &lt;code&gt;pthread_create&lt;/code&gt; 创建线程 B，不传入线程属性的话默认是 joinable 类型的线程。需要在线程 A 调用 &lt;code&gt;pthread_join&lt;/code&gt; 来连接，这样才会在线程 B 结束后回收其资源。&lt;/p&gt;
&lt;p&gt;默认情况下只有主线程是 joinable 的，当所有 joinable 线程都结束了，它们所属的进程也就终止执行了。因为系统会认为 detached 线程做的都是可选的任务，所以当用户退出了一个应用时，通常会立刻结束所有的 detached 线程。&lt;/p&gt;
&lt;p&gt;如果想让线程在后台做一些诸如保存数据到磁盘之类的重要工作，需要使用 joinable 类型的线程，以防止应用退出时数据丢失。但大多数的对线程高层封装的 API 不会默认创建 joinable 线程，所以需要使用 POSIX API 的 &lt;code&gt;pthread_create&lt;/code&gt; 创建 joinable 线程。&lt;/p&gt;
&lt;p&gt;在使用 Cocoa API 时，&lt;code&gt;applicationShouldTerminate:&lt;/code&gt; delegate 方法可以延迟一阵子退出应用或取消退出。如果需要延迟退出程序，还要在所有关键线程完成任务之后调用 &lt;code&gt;replyToApplicationShouldTerminate:&lt;/code&gt; 方法告诉 &lt;code&gt;NSApplication&lt;/code&gt; 对象是否可以真的退出了。&lt;/p&gt;
&lt;h4 id=&quot;处理异常&quot;&gt;&lt;a href=&quot;#处理异常&quot; class=&quot;headerlink&quot; title=&quot;处理异常&quot;&gt;&lt;/a&gt;处理异常&lt;/h4&gt;&lt;p&gt;每个线程都负责捕获和处理其调用栈上抛出的异常，任何线程上没被捕获的异常都能终止其所属进程。不能将没捕获的线程抛给其他线程处理。&lt;/p&gt;
&lt;p&gt;如果想要通知其他线程有异常，应该先捕获异常，然后给其他线程发消息。异常被捕获后可能会继续执行，或者等待命令，或者退出。&lt;/p&gt;
&lt;p&gt;Cocoa 的 &lt;code&gt;NSException&lt;/code&gt; 被捕获后可以在线程之间传递。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@synchronized&lt;/code&gt; 会自动捕获和处理异常。&lt;/p&gt;
&lt;h4 id=&quot;干净利落地终止线程&quot;&gt;&lt;a href=&quot;#干净利落地终止线程&quot; class=&quot;headerlink&quot; title=&quot;干净利落地终止线程&quot;&gt;&lt;/a&gt;干净利落地终止线程&lt;/h4&gt;&lt;p&gt;最好是让线程运行结束后自动退出，如果万不得已非要立刻终止线程，会导致线程没有释放和清理它占用的资源，比如：创建的内存、打开的文件以及获得的其他资源。无法回收这些资源意味着内存泄露和其他潜在的问题。&lt;/p&gt;
&lt;h4 id=&quot;Library-中的线程安全&quot;&gt;&lt;a href=&quot;#Library-中的线程安全&quot; class=&quot;headerlink&quot; title=&quot;Library 中的线程安全&quot;&gt;&lt;/a&gt;Library 中的线程安全&lt;/h4&gt;&lt;p&gt;开发第三方库的时候必须假设调用方随时都会处于多线程环境中，代码中的关键部分一定要加锁。虽然可以监听 &lt;code&gt;NSWillBecomeMultiThreadedNotification&lt;/code&gt; 通知来获知应用处于多线程，但可能 library 被调用之前就已经发过通知了。别指望当调用方处于多线程环境时才创建锁，而是需要在调用初始化 library 的方法中就提前创建好锁对象。但如果在 library 的静态初始化中创建锁会延长 library 的加载时间，影响性能。&lt;/p&gt;
&lt;p&gt;互斥锁的加锁和解锁操作要成对出现，不要指望调用方提供一个线程安全的环境，对数据结构该用锁就用。&lt;/p&gt;
&lt;h2 id=&quot;线程管理&quot;&gt;&lt;a href=&quot;#线程管理&quot; class=&quot;headerlink&quot; title=&quot;线程管理&quot;&gt;&lt;/a&gt;线程管理&lt;/h2&gt;&lt;p&gt;每个进程都至少有一个线程，每个线程代表了一条执行代码的独立路径。应用从一个线程的 &lt;code&gt;main&lt;/code&gt; 函数开始运行，然后产生新的线程。每个线程在进程内部都是独立的实体，具有自己的调用栈，并由内核做时分调度。线程可以与其他线程和进程通信，执行 I/O 操作等。一个应用进程内部的所有现场共享虚拟内存空间，并与进程拥有相同的访问权限。&lt;/p&gt;
&lt;h3 id=&quot;线程成本&quot;&gt;&lt;a href=&quot;#线程成本&quot; class=&quot;headerlink&quot; title=&quot;线程成本&quot;&gt;&lt;/a&gt;线程成本&lt;/h3&gt;&lt;p&gt;使用线程对应用和系统来说都是有成本的，具体体现在内存使用和性能上。每个线程需要占用内核内存空间和程序内存空间。内核会使用联动(wired)内存为线程创建用于管理线程和协调调度的数据结构。线程的栈空间和数据存储在程序的内存空间中。这些数据结构大部分会在创建线程的时候初始化，进程也因与内核有必要的交互而成本变得相对更高。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成本项&lt;/th&gt;
&lt;th&gt;大致成本&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;内核数据结构&lt;/td&gt;
&lt;td&gt;大约 1 KB&lt;/td&gt;
&lt;td&gt;用于存储线程数据结构和属性的内存，很多都是联动（wired）内存，所以不能在磁盘上分页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;栈空间&lt;/td&gt;
&lt;td&gt;次级线程：512 KB ; macOS 主线程：8 MB ; iOS 主线程：1 MB&lt;/td&gt;
&lt;td&gt;次级线程的栈空间最小为 16 KB，且必须是 4 KB 的整数倍。创建线程的时候可以设置栈空间的大小，但是只有在需要用它的时候才会创建真的分页内存。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;大约 90 微秒（macOS 10.5，2 GHz Core Duo CPU，1 GB RAM）&lt;/td&gt;
&lt;td&gt;从开始创建线程到线程入口函数开始执行的耗时，是个粗略的估值。处理器负载、计算机速度、系统和程序可用内存都会对创建时间造成较大的影响。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于底层内核的支持，operation objects 经常可以更快地创建线程。它使用内核线程池中已经存在的线程来节省创建时间，而不是每次都从零开始创建线程。&lt;/p&gt;
&lt;p&gt;写线程相关代码也是一种生产成本。设计多线程程序又是需要对应用数据结构的组织方式进行彻底的改变。避免使用同步，因为它在设计较差的应用上会严重降低性能。设计数据结构和 debug 线程相关代码都会增加开发成本。&lt;/p&gt;
&lt;h3 id=&quot;创建线程&quot;&gt;&lt;a href=&quot;#创建线程&quot; class=&quot;headerlink&quot; title=&quot;创建线程&quot;&gt;&lt;/a&gt;创建线程&lt;/h3&gt;&lt;p&gt;创建线程需要指定入口主函数，并可设置一些线程的配置项。最后调用运行线程的方法。下面介绍几种创建线程的技术。&lt;/p&gt;
&lt;h4 id=&quot;使用-NSThread&quot;&gt;&lt;a href=&quot;#使用-NSThread&quot; class=&quot;headerlink&quot; title=&quot;使用 NSThread&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;NSThread&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;使用 &lt;code&gt;NSThread&lt;/code&gt; 创建线程有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;detachNewThreadSelector:toTarget:withObject:&lt;/code&gt; 类方法产生新的线程&lt;/li&gt;
&lt;li&gt;创建一个新的 &lt;code&gt;NSThread&lt;/code&gt; 对象，并调用它的 &lt;code&gt;start&lt;/code&gt; 方法。仅支持 iOS 和 macOS 10.5 以后的版本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种方法都会创建一个 detached 线程，它退出后系统会自动回收其资源，无需手动 join 操作。&lt;/p&gt;
&lt;p&gt;下面两种创建线程的代码是等效的，但是推荐使用第二种方式。因为它支持在运行线程之前设置各种线程属性，不像第一种方式那样创建线程的时候必须立刻运行。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 方式 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; detachNewThreadSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(myThreadMainMethod:) toTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; withObject:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 方式 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt;* myThread = [[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(myThreadMainMethod:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[myThread start];  &lt;span class=&quot;comment&quot;&gt;// Actually create the thread&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果不想使用 &lt;code&gt;initWithTarget:selector:object:&lt;/code&gt; 方法传入线程的入口函数，也可以继承 &lt;code&gt;NSThread&lt;/code&gt;，并覆写子类的 &lt;code&gt;main&lt;/code&gt; 方法（不用调用 &lt;code&gt;super&lt;/code&gt; 方法）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;performSelector:onThread:withObject:waitUntilDone:&lt;/code&gt; 方法可以在正在运行的线程发送消息，前提是这个线程必须有运行中的 run loop，因为消息会在线程的 run loop 日常处理过程中被执行。注意使用此方法进行跨线程通信时需要有同步机制。此方法并不适合用于实现时间紧要和频繁的跨线程通信。&lt;/p&gt;
&lt;h4 id=&quot;使用-POSIX-线程&quot;&gt;&lt;a href=&quot;#使用-POSIX-线程&quot; class=&quot;headerlink&quot; title=&quot;使用 POSIX 线程&quot;&gt;&lt;/a&gt;使用 POSIX 线程&lt;/h4&gt;&lt;p&gt;iOS 和 macOS 提供了基于 C 语言的 POSIX 线程 API 来创建线程，优点是跨平台。创建线程的函数是 &lt;code&gt;pthread_create&lt;/code&gt;，默认创建的是 joinable 线程，所以需要设置线程属性来将其创建为 detached 线程，这样当线程退出的时候其资源就会立刻被系统回收利用了：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 线程入口主程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;PosixThreadMainRoutine&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* data)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在这里加代码.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LaunchThread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Create the thread using POSIX routines.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pthread_attr_t&lt;/span&gt;  attr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pthread_t&lt;/span&gt;       posixThreadID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;             returnVal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    returnVal = pthread_attr_init(&amp;amp;attr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert(!returnVal);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    returnVal = pthread_attr_setdetachstate(&amp;amp;attr, PTHREAD_CREATE_DETACHED);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert(!returnVal);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 因为 PosixThreadMainRoutine 函数没有参数，所以 pthread_create 最后一个参数传 NULL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;     threadError = pthread_create(&amp;amp;posixThreadID, &amp;amp;attr, &amp;amp;PosixThreadMainRoutine, NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    returnVal = pthread_attr_destroy(&amp;amp;attr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert(!returnVal);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (threadError != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;// Report an error.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于 C 语言的应用，可以使用端口、条件变量s 或共用内存来跨线程通信。跨线程通信有便于主线程检查其他线程的状态，在应用退出时做一些操作。&lt;/p&gt;
&lt;p&gt;关于 POSIX 线程函数可以翻阅 pthread man page。&lt;/p&gt;
&lt;h4 id=&quot;使用-NSObject-产生线程&quot;&gt;&lt;a href=&quot;#使用-NSObject-产生线程&quot; class=&quot;headerlink&quot; title=&quot;使用 NSObject 产生线程&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;NSObject&lt;/code&gt; 产生线程&lt;/h4&gt;&lt;p&gt;iOS 和 macOS 10.5 之后 &lt;code&gt;NSObject&lt;/code&gt; 提供了&lt;code&gt;performSelectorInBackground:withObject:&lt;/code&gt; 方法，可以让所有对象都创建 detached 线程，并传入 &lt;code&gt;selector&lt;/code&gt; 作为入口函数。跟它等效的方法是 &lt;code&gt;NSThread&lt;/code&gt; 的 &lt;code&gt;detachNewThreadSelector:toTarget:withObject:&lt;/code&gt;。在 &lt;code&gt;selector&lt;/code&gt; 方法里可以继续配置线程，比如添加 &lt;code&gt;autoreleasepool&lt;/code&gt; 和 run loop。&lt;/p&gt;
&lt;h4 id=&quot;在-Cocoa-应用中使用-POSIX-线程&quot;&gt;&lt;a href=&quot;#在-Cocoa-应用中使用-POSIX-线程&quot; class=&quot;headerlink&quot; title=&quot;在 Cocoa 应用中使用 POSIX 线程&quot;&gt;&lt;/a&gt;在 Cocoa 应用中使用 POSIX 线程&lt;/h4&gt;&lt;p&gt;在 Cocoa 中使用 POSIX 线程需要注意它们之间的交互，并遵守以下原则。&lt;/p&gt;
&lt;h5 id=&quot;保护-Cocoa-框架&quot;&gt;&lt;a href=&quot;#保护-Cocoa-框架&quot; class=&quot;headerlink&quot; title=&quot;保护 Cocoa 框架&quot;&gt;&lt;/a&gt;保护 Cocoa 框架&lt;/h5&gt;&lt;p&gt;Cocoa 框架使用加锁之类的同步机制来确保多线程工作正常，但只有在第一次使用 &lt;code&gt;NSThread&lt;/code&gt; 产生新线程的时候才会真的创建锁。这可以避免单线程情况下加锁会降低性能。但如果只使用 POSIX API 来产生新线程，Cocoa 就不会收到应用转换为多线程的通知，进而导致应用不稳定，甚至 crash。可以用 &lt;code&gt;NSThread&lt;/code&gt; 创建一个新线程，入口函数啥都不做，这样线程就会立刻退出。这样 Cocoa 就知道应用处于多线程了，加锁也会生效。PS：这么抖机灵的做法当然也会产生创建线程的开销，有些违背之前说的不要随意创建线程的原则。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSThread&lt;/code&gt; 的 &lt;code&gt;isMultiThreaded&lt;/code&gt; 方法可以检查应用是否是多线程。&lt;/p&gt;
&lt;h5 id=&quot;混合使用-POSIX-和-Cocoa-锁&quot;&gt;&lt;a href=&quot;#混合使用-POSIX-和-Cocoa-锁&quot; class=&quot;headerlink&quot; title=&quot;混合使用 POSIX 和 Cocoa 锁&quot;&gt;&lt;/a&gt;混合使用 POSIX 和 Cocoa 锁&lt;/h5&gt;&lt;p&gt;在一个应用中混合使用 POSIX 和 Cocoa 两套 API 的锁是安全的，因为后者实质上只是对前者的封装。但不能用一种 API 的方法操作另一种 API 创建的锁。比如不能使用 &lt;code&gt;NSLock&lt;/code&gt; 对象操作 &lt;code&gt;pthread_mutex_init&lt;/code&gt; 函数创建的互斥锁，反之亦然。&lt;/p&gt;
&lt;h3 id=&quot;配置线程属性&quot;&gt;&lt;a href=&quot;#配置线程属性&quot; class=&quot;headerlink&quot; title=&quot;配置线程属性&quot;&gt;&lt;/a&gt;配置线程属性&lt;/h3&gt;&lt;h4 id=&quot;配置线程的栈尺寸&quot;&gt;&lt;a href=&quot;#配置线程的栈尺寸&quot; class=&quot;headerlink&quot; title=&quot;配置线程的栈尺寸&quot;&gt;&lt;/a&gt;配置线程的栈尺寸&lt;/h4&gt;&lt;p&gt;创建线程后系统会为其创建一块内存作为栈空间，开发者可以在创建线程前配置这块空间的尺寸。所有的线程技术都会提供某种设置栈尺寸的方法，但 &lt;code&gt;NSThread&lt;/code&gt; 只有在 iOS 和 macOS 10.5 之后支持设置栈的尺寸。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;技术&lt;/th&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Cocoa&lt;/td&gt;
&lt;td&gt;前提是不要使用 &lt;code&gt;detachNewThreadSelector:toTarget:withObject:&lt;/code&gt; 创建线程。创建线程对象后，在调用线程对象的 &lt;code&gt;start&lt;/code&gt; 方法之前，使用 &lt;code&gt;setStackSize:&lt;/code&gt; 方法指定栈的大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POSIX&lt;/td&gt;
&lt;td&gt;创建 &lt;code&gt;pthread_attr_t&lt;/code&gt; 栈属性结构体并使用 &lt;code&gt;pthread_attr_setstacksize&lt;/code&gt; 函数修改默认的栈尺寸。在使用 &lt;code&gt;pthread_create&lt;/code&gt; 函数创建线程时将属性结构体传入。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Multiprocessing Services&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;MPCreateTask&lt;/code&gt; 函数创建线程时可以传入栈尺寸。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;配置-TLS-Thread-Local-Storage&quot;&gt;&lt;a href=&quot;#配置-TLS-Thread-Local-Storage&quot; class=&quot;headerlink&quot; title=&quot;配置 TLS(Thread-Local Storage)&quot;&gt;&lt;/a&gt;配置 TLS(Thread-Local Storage)&lt;/h4&gt;&lt;p&gt;每个线程都维护了一个存储键值对的字典，在线程内随处都能存取。可以用它记录一些贯穿于线程执行过程中的信息，比如 run loop 迭代次数。&lt;/p&gt;
&lt;p&gt;Cocoa 与 POSIX 存储线程字典的方式不同，所以两种技术的 API 不能混用。只要你始终用其中一种技术，最后结果都差不多。具体方式如下：&lt;/p&gt;
&lt;p&gt;Cocoa: &lt;code&gt;NSThread&lt;/code&gt; 的 &lt;code&gt;threadDictionary&lt;/code&gt; 方法获取 &lt;code&gt;NSMutableDictionary&lt;/code&gt; 字典对象，然后进行存取。&lt;br&gt;POSIX: 直接用 &lt;code&gt;pthread_setspecific&lt;/code&gt; 和 &lt;code&gt;pthread_getspecific&lt;/code&gt; 函数存取字典。&lt;/p&gt;
&lt;h4 id=&quot;设置线程的-Detached-状态&quot;&gt;&lt;a href=&quot;#设置线程的-Detached-状态&quot; class=&quot;headerlink&quot; title=&quot;设置线程的 Detached 状态&quot;&gt;&lt;/a&gt;设置线程的 Detached 状态&lt;/h4&gt;&lt;p&gt;大部分高级线程技术创建的线程默认都是 detached 状态，这是因为大部分场景下都需要系统在线程执行完成后立刻回收资源。好处是代码干净，是否获取线程执行结果可以自行决定。&lt;/p&gt;
&lt;p&gt;joinable 线程需要其他线程调用 &lt;code&gt;pthread_join&lt;/code&gt; 函数对其进行 join 操作之后才能被系统回收资源。joinable 线程可以向 &lt;code&gt;pthread_exit&lt;/code&gt; 函数传入数据，其他线程可以在调用 &lt;code&gt;pthread_join&lt;/code&gt; 函数的时候获得此数据。参考 &lt;a href=&quot;https://stackoverflow.com/questions/8513894/pthread-join-and-pthread-exit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pthread_join() and pthread_exit()&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;应用退出时，detached 线程可以立刻结束，但是 joinable 线程必须全都被 join 后进程才能退出。因此 joinable 线程适用于执行不能中断的重要工作，比如向磁盘写入数据。&lt;/p&gt;
&lt;p&gt;只能用 POSIX API 来创建 joinable 线程，如果不设置线程属性，默认就是 joinable 线程。可以在创建线程之前调用 &lt;code&gt;pthread_attr_setdetachstate&lt;/code&gt; 函数修改线程 detached 状态。在线程开始运行之后，可以调用 &lt;code&gt;pthread_detach&lt;/code&gt; 函数将一个 joinable 线程变成 detached 线程。&lt;/p&gt;
&lt;h4 id=&quot;设置线程优先级&quot;&gt;&lt;a href=&quot;#设置线程优先级&quot; class=&quot;headerlink&quot; title=&quot;设置线程优先级&quot;&gt;&lt;/a&gt;设置线程优先级&lt;/h4&gt;&lt;p&gt;任何新创建的线程都有个默认优先级。内核的调度算法在决定运行哪个线程的时候都会考虑到线程优先级，优先级越高越可能先运行。拥有更高优先级的线程并不保证有特定的运行时间，只是在与低优先级线程比较时更容易被调度算法选中罢了。&lt;/p&gt;
&lt;p&gt;最好让你创建的线程保持默认优先级。提升一些线程的优先级也会提升低优先级线程饥饿的可能性。如果高优先级线程和低优先级线程之间有交互，低优先级线程饥饿可能会阻塞其他线程，并造成性能瓶颈。&lt;/p&gt;
&lt;p&gt;设置线程优先级的方式如下：&lt;/p&gt;
&lt;p&gt;Cocoa: &lt;code&gt;NSThread&lt;/code&gt; 的 &lt;code&gt;setThreadPriority:&lt;/code&gt; 类方法可以设置当前线程的优先级。&lt;br&gt;POSIX: &lt;code&gt;pthread_setschedparam&lt;/code&gt; 函数设置优先级。&lt;/p&gt;
&lt;h3 id=&quot;编写线程入口程序&quot;&gt;&lt;a href=&quot;#编写线程入口程序&quot; class=&quot;headerlink&quot; title=&quot;编写线程入口程序&quot;&gt;&lt;/a&gt;编写线程入口程序&lt;/h3&gt;&lt;p&gt;各平台上的线程入口函数结构都差不多，一般都会初始化数据结构，执行一些工作，或者使用 run loop 保活，最后在工作完成后清理占用的资源。这里讲一下编写线程入口程序需要做的一些额外步骤。&lt;/p&gt;
&lt;h4 id=&quot;创建自动释放池&quot;&gt;&lt;a href=&quot;#创建自动释放池&quot; class=&quot;headerlink&quot; title=&quot;创建自动释放池&quot;&gt;&lt;/a&gt;创建自动释放池&lt;/h4&gt;&lt;p&gt;使用 Objective-C 框架的应用必须确保每条线程至少有一个自动释放池。如果开启垃圾回收机制，自动释放池会失效。PS: 垃圾回收很早就被苹果弃用了。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;@autoreleasepool&lt;/code&gt; 创建自动释放池比 &lt;code&gt;NSAutoreleasePool&lt;/code&gt; 更方便。而且 &lt;code&gt;NSAutoreleasePool&lt;/code&gt; 不能在 ARC 下使用。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;selector-tag&quot;&gt;myThreadMainRoutine&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;comment&quot;&gt;// Do thread work here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时需要创建更多的自动释放池，比如在循环内部使用自动释放池降低内存开销。&lt;/p&gt;
&lt;p&gt;关于自动释放池的使用，不再赘述。&lt;/p&gt;
&lt;h4 id=&quot;设置-Exception-Handler&quot;&gt;&lt;a href=&quot;#设置-Exception-Handler&quot; class=&quot;headerlink&quot; title=&quot;设置 Exception Handler&quot;&gt;&lt;/a&gt;设置 Exception Handler&lt;/h4&gt;&lt;p&gt;没被捕获的异常会导致应用崩溃，虽然最好应该在异常发生的地方进行异常处理，但是在线程的入口函数再加上个 try/catch 比较好。&lt;/p&gt;
&lt;p&gt;更多内容参考 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012i&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Exception Programming Topics&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;设置-Run-Loop&quot;&gt;&lt;a href=&quot;#设置-Run-Loop&quot; class=&quot;headerlink&quot; title=&quot;设置 Run Loop&quot;&gt;&lt;/a&gt;设置 Run Loop&lt;/h4&gt;&lt;p&gt;编写线程上运行的代码有两种选择：1. 代码简单粗暴，任务执行完线程就退出了；2. 设置线程的 run loop，处理不断到来的请求。&lt;/p&gt;
&lt;p&gt;macOS 和 iOS 内置了 run loop 的实现，应用的主线程自动开启 run loop。开发者创建的次级线程需要手动配置和开启 run loop。&lt;/p&gt;
&lt;h3 id=&quot;终止线程&quot;&gt;&lt;a href=&quot;#终止线程&quot; class=&quot;headerlink&quot; title=&quot;终止线程&quot;&gt;&lt;/a&gt;终止线程&lt;/h3&gt;&lt;p&gt;建议让线程的入口函数正常退出。虽然 Cocoa，POSIX 和 Multiprocessing Services 提供了直接杀线程的方法，但强烈不建议使用。强杀线程会导致无法回收资源，可能导致内存泄露、资源没被正确清理，进而导致后续的隐患。&lt;/p&gt;
&lt;p&gt;如果预料到需要中途结束线程，设计线程之初就应该响应到取消或退出的消息。带有 run loop 这种周期操作的线程可以每次查看是否收到退出的消息。如果需要退出线程，则可以清理线程资源后退出；否则继续处理其他工作。&lt;/p&gt;
&lt;p&gt;run loop 可以使用 input source 接受其他线程发的消息，但需要为 &lt;code&gt;NSRunLoop&lt;/code&gt; 配置 &lt;code&gt;CFRunLoopSourceRef&lt;/code&gt;，假设这部分代码在 &lt;code&gt;myInstallCustomInputSource&lt;/code&gt; 已经实现好了。下面的代码还省略了自动释放池和 &lt;code&gt;while&lt;/code&gt; 主循环中做的实际工作。将标记是否需要退出线程的局部变量 &lt;code&gt;exitNow&lt;/code&gt; 的值放在 TLS 中同步是为了方便 input source 的事件处理函数对 &lt;code&gt;exitNow&lt;/code&gt; 的存取，因为事件处理是在另外一个函数，不能直接存取 &lt;code&gt;exitNow&lt;/code&gt;，需要经过 TLS。当 input source 收到退出消息后，对应的事件处理函数便可以清理线程的资源，准备退出。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)threadMainRoutine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; moreWorkToDo = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; exitNow = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt;* runLoop = [&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Add the exitNow BOOL to the thread dictionary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt;* threadDict = [[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; currentThread] threadDictionary];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [threadDict setValue:[&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; numberWithBool:exitNow] forKey:&lt;span class=&quot;string&quot;&gt;@&quot;ThreadShouldExitNow&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Install an input source.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; myInstallCustomInputSource];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (moreWorkToDo &amp;amp;&amp;amp; !exitNow)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Do one chunk of a larger body of work here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Change the value of the moreWorkToDo Boolean when done.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Run the run loop but timeout immediately if the input source isn&#39;t waiting to fire.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [runLoop runUntilDate:[&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; date]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Check to see if an input source handler changed the exitNow value.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        exitNow = [[threadDict valueForKey:&lt;span class=&quot;string&quot;&gt;@&quot;ThreadShouldExitNow&quot;&lt;/span&gt;] boolValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1&quot;&gt;Threading Programming Guide&lt;/a&gt; 的学习笔记&amp;amp;翻译，第一部分。&lt;/p&gt;
&lt;p&gt;其实苹果建议使用对线程的高级封装，比如 operation objects and Grand Central Dispatch，它们使用方便更加高效，可以参考 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091&quot;&gt;Concurrency Programming Guide&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但了解更底层一些的内容其实更有趣，难道不是么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/&quot;&gt;Threading Programming Guide(2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/&quot;&gt;Threading Programming Guide(3)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yulingtianxia.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s New in LLVM</title>
    <link href="http://yulingtianxia.com/blog/2017/07/17/What-s-New-in-LLVM-2017/"/>
    <id>http://yulingtianxia.com/blog/2017/07/17/What-s-New-in-LLVM-2017/</id>
    <published>2017-07-16T16:04:37.000Z</published>
    <updated>2017-09-09T15:40:06.000Z</updated>
    
    <content type="html">&lt;p&gt;这&lt;strong&gt;绝不仅仅&lt;/strong&gt;是一篇 WWDC 2017 Session 411 学习笔记。除了有关 LLVM  9.0 的新特性之外，还有关于静态分析器和 Clang 5 Objective-C ARC 的一点看法和经验。&lt;/p&gt;
&lt;p&gt;我觉得 LLVM 9 的亮点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持 Objective-C API 可用性检查&lt;/li&gt;
&lt;li&gt;新增一些对隐患代码的静态分析检查和 warning&lt;/li&gt;
&lt;li&gt;更快的 LTO，使其可以真正使用&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;API-Availability-Checking-for-Objective-C&quot;&gt;&lt;a href=&quot;#API-Availability-Checking-for-Objective-C&quot; class=&quot;headerlink&quot; title=&quot;API Availability Checking for Objective-C&quot;&gt;&lt;/a&gt;API Availability Checking for Objective-C&lt;/h2&gt;&lt;p&gt;在低版本系统上调用高版本 SDK 的 API 会引发 crash，所以在兼容多版本系统时需要谨慎判断系统版本，然后使用对应的 API。这些在运行时才能生效的代码很容易编写出错，而且需要测试人员付出很大工作量来覆盖到各个版本的系统。检查类、实例方法、类方法等是否可用时需要写的代码也不同，很蛋疼呦。&lt;/p&gt;
&lt;p&gt;Swift 3 加入了 &lt;code&gt;#available&lt;/code&gt; 语法来检查 API 是否可用，在编译阶段就可以发现哪里漏掉了 API 可用性检查。如今，Objective-C 也有这项功能啦。&lt;/p&gt;
&lt;h3 id=&quot;Objective-C&quot;&gt;&lt;a href=&quot;#Objective-C&quot; class=&quot;headerlink&quot; title=&quot;Objective-C&quot;&gt;&lt;/a&gt;Objective-C&lt;/h3&gt;&lt;p&gt;假设加入 App 支持的最低版本是 iOS 10，但是直接调用了 iOS 11 的 API，那么编译器会告警，提醒开发者某个 API 只能用于较新版本的系统上。这时需要通过 &lt;code&gt;@available&lt;/code&gt; 语法来判断平台和版本：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;variable&quot;&gt;@available&lt;/span&gt;(iOS &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, *)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// iOS 11 以上以及其他所有平台&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 相当于通配符，代表所有其他平台都可用。&lt;/p&gt;
&lt;p&gt;说完了如何检查 API 可用性后，再来谈谈声明 API 可用性的问题：&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;name&quot;&gt;void&lt;/span&gt;)foo API_AVAILABLE(&lt;span class=&quot;name&quot;&gt;ios&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11.0&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码声明了调用 &lt;code&gt;foo&lt;/code&gt; 方法需要 iOS 11 以上，而 &lt;code&gt;foo&lt;/code&gt; 方法内部的实现中调用 iOS 11 的 API 时无需再用 &lt;code&gt;@available&lt;/code&gt; 检查。&lt;/p&gt;
&lt;p&gt;声明一个类的可用性也很简单，并且无需给类中的每个方法再次声明可用性，只需要用到 &lt;code&gt;API_AVAILABLE&lt;/code&gt; 宏：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;API_&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;(ios(&lt;span class=&quot;number&quot;&gt;11.0&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyClassForiOS11OrNewer&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实类似的有关 API 兼容版本的宏还有好几个：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;API_DEPRECATED&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;API_UNAVAILABLE&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;API_DEPRECATED_WITH_REPLACEMENT&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;C-amp-C&quot;&gt;&lt;a href=&quot;#C-amp-C&quot; class=&quot;headerlink&quot; title=&quot;C &amp;amp; C++&quot;&gt;&lt;/a&gt;C &amp;amp; C++&lt;/h3&gt;&lt;p&gt;如果是想在 C 或 C++ 中查询 API 的可用性，可以使用 LLVM 新加的 &lt;code&gt;__builtin_available()&lt;/code&gt; 函数：&lt;/p&gt;
&lt;figure class=&quot;highlight gcode&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;(__builtin_available(iOS 11, macOS 10.13, *)&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// iOS 11 以上或 macOS 10.13 以上平台，以及其他所有平台&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 C 或 C++ 中使用 &lt;code&gt;API_AVAILABLE&lt;/code&gt; 宏之前需要引入头文件&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;os/availability.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; API_AVAILABLE(ios(&lt;span class=&quot;number&quot;&gt;11.0&lt;/span&gt;)) MyClassForiOS11OrNewer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;适用范围&quot;&gt;&lt;a href=&quot;#适用范围&quot; class=&quot;headerlink&quot; title=&quot;适用范围&quot;&gt;&lt;/a&gt;适用范围&lt;/h3&gt;&lt;p&gt;对于旧工程，LLVM 只会对新的 API 进行告警(包含 iOS 11,tvOS 11,macOS 10.13,watchOS 4 以上)。旧的 API 不会被编译器告警，所以不用担心旧项目中已有的代码会产生一大片 warning，只需在采用新 API 的时候加上 &lt;code&gt;@available&lt;/code&gt; 或 &lt;code&gt;API_AVAILABLE&lt;/code&gt;。也可以选择在 Build Settings 中设置 &lt;code&gt;Unguarded availability&lt;/code&gt; 为 &lt;code&gt;YES(All Versions)&lt;/code&gt; 来检查所有的 API。Xcode 9 新建工程 &lt;code&gt;Unguarded availability&lt;/code&gt; 项默认为 &lt;code&gt;YES(All Versions)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Static-Analyzer-Checks&quot;&gt;&lt;a href=&quot;#Static-Analyzer-Checks&quot; class=&quot;headerlink&quot; title=&quot;Static Analyzer Checks&quot;&gt;&lt;/a&gt;Static Analyzer Checks&lt;/h2&gt;&lt;p&gt;除了在 Xcode-&amp;gt;Product-&amp;gt;Analyze 中开启静态分析检查外，也可以在 Build 过程中进行静态分析检查。只需在编译设置中将 &lt;code&gt;Analyse During &amp;#39;Build&amp;#39;&lt;/code&gt; 设为 &lt;code&gt;YES&lt;/code&gt;。 &lt;/p&gt;
&lt;p&gt;苹果补充了一些检查项，看了下还都是一不留神就容易犯或者根本没注意到的细节。&lt;/p&gt;
&lt;h3 id=&quot;比较-NSNumber&quot;&gt;&lt;a href=&quot;#比较-NSNumber&quot; class=&quot;headerlink&quot; title=&quot;比较 NSNumber&quot;&gt;&lt;/a&gt;比较 NSNumber&lt;/h3&gt;&lt;p&gt;稍有经验的老司机都懂得 NSNumber 不能直接跟 raw value 直接比较，毕竟前者是类的实例对象，后者是基本类型。然而还是有人会弄错：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSNumber *&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; = @&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSNumber *check = @YES&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;肯定会进到这里，因为 count 不为 nil&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (check) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;肯定会进到这里，因为 check 不为 nil&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在 LLVM 可以检查出这种情况，也可以关闭这项检查：在编译设置中将 &lt;code&gt;Suspicious Conversions of NSNumber and CFNumberRef&lt;/code&gt; 设为 &lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;dispatch-once&quot;&gt;&lt;a href=&quot;#dispatch-once&quot; class=&quot;headerlink&quot; title=&quot;dispatch_once()&quot;&gt;&lt;/a&gt;&lt;code&gt;dispatch_once()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Xcode 的 code snippet 很好用，我觉得正常人不会把 &lt;code&gt;dispatch_once()&lt;/code&gt; 写错吧。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static &lt;span class=&quot;keyword&quot;&gt;dispatch_once_t &lt;/span&gt;onceToken&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;dispatch_once(&amp;amp;onceToken, &lt;/span&gt;^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   foo()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;onceToken&lt;/code&gt; 只能是全局变量或静态变量，使得指针地址的唯一性保证了 &lt;code&gt;foo()&lt;/code&gt; 只执行一次。但总有奇葩把 &lt;code&gt;onceToken&lt;/code&gt; 声明成成员变量，使得指针地址可能会重复，无法保证线程安全地只执行一次。而现在 LLVM 可以检查出这种不规范的使用方式。&lt;/p&gt;
&lt;p&gt;当然，想实现线程安全地只执行一次方法，也可以通过加锁和判断标志位的方式来实现。&lt;/p&gt;
&lt;h3 id=&quot;NSMutable-类型的属性使用-copy-内存管理语义&quot;&gt;&lt;a href=&quot;#NSMutable-类型的属性使用-copy-内存管理语义&quot; class=&quot;headerlink&quot; title=&quot;NSMutable 类型的属性使用 copy 内存管理语义&quot;&gt;&lt;/a&gt;&lt;code&gt;NSMutable&lt;/code&gt; 类型的属性使用 &lt;code&gt;copy&lt;/code&gt; 内存管理语义&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *array;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;内存管理语义帮开发者自动合成了 &lt;code&gt;set&lt;/code&gt; 方法的实现，但是当 &lt;code&gt;copy&lt;/code&gt; 应用到了 &lt;code&gt;NSMutable&lt;/code&gt; 系列的类上，就会产生问题。因为我们想要的是把新的值 &lt;code&gt;mutableCopy&lt;/code&gt; 后赋值给属性，然而内存管理语义中只有 &lt;code&gt;copy&lt;/code&gt; 却没有 &lt;code&gt;mutableCopy&lt;/code&gt;。而现在 LLVM 可以检查出这种情况。&lt;/p&gt;
&lt;p&gt;重写 &lt;code&gt;set&lt;/code&gt; 方法可以解决此问题:&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setArray:(NSMutableArray *)&lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _array = [&lt;span class=&quot;keyword&quot;&gt;array&lt;/span&gt; mutableCopy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;一些建议&quot;&gt;&lt;a href=&quot;#一些建议&quot; class=&quot;headerlink&quot; title=&quot;一些建议&quot;&gt;&lt;/a&gt;一些建议&lt;/h3&gt;&lt;p&gt;静态分析能做到在编译阶段发现一些程序员容易疏忽的地方，它只能检查特定场景下的一些被认为不符合规范的行为。也就是说它维护了一个 List，编译的时候一项一项检查是否合符规范，但是这个 List 之外的行为并不能被检查出来，这也就是为什么 LLVM 每年都在向这个 List 新增内容。这个 List 包含了程序员容易犯的代码问题，并且这些问题暗涵很严重的逻辑错误。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随着 Check List 的不断膨胀，静态分析耗时会增加，对于大中型项目，我并不建议开启每次编译时都进行静态分析检查。建议在每个版本测试阶段定期做静态分析检查。&lt;/li&gt;
&lt;li&gt;不要过于相信静态分析检查。首先它会漏检，Check List 之外的情况根本检查不出来。如果将一些 API 包含在宏定义中或者封装在 C 函数中调用，导致语法复杂，静态分析甚至还会误报。（我曾经碰见过几次静态分析检查出 MRC 下一些内存泄露，但其实间接调用了 &lt;code&gt;autorelease&lt;/code&gt; 的，根本不会泄露，改为直接调用 &lt;code&gt;autorelease&lt;/code&gt; 就 OK 了）&lt;/li&gt;
&lt;li&gt;程序员自身应该有一份 Check List，在平时变成变成过程中不断约束自己。比如判断 &lt;code&gt;NSString&lt;/code&gt; 是否有内容时直接看 &lt;code&gt;length&lt;/code&gt; 是否大于 0，而不是判断是否为 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;@&amp;quot;&amp;quot;&lt;/code&gt;。这跟打游戏是否有意识差不多，写代码也要有『意识流』。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;New-Warnings&quot;&gt;&lt;a href=&quot;#New-Warnings&quot; class=&quot;headerlink&quot; title=&quot;New Warnings&quot;&gt;&lt;/a&gt;New Warnings&lt;/h2&gt;&lt;p&gt;Xcode 9 的 LLVM 又新增了一百多个 error 和 warning，然而大多数程序员还不是照样忽视 warning 么？可以在编译设置中将 warning 升级成 error。如果是旧的工程，需要升级工程文件到 Xcode 9，然后才能看到这些新增的 warning 设置项。（点击工程-&amp;gt;Editor-&amp;gt;Validate Settings）&lt;/p&gt;
&lt;h3 id=&quot;ARC-中的-Block-捕获参数&quot;&gt;&lt;a href=&quot;#ARC-中的-Block-捕获参数&quot; class=&quot;headerlink&quot; title=&quot;ARC 中的 Block 捕获参数&quot;&gt;&lt;/a&gt;ARC 中的 Block 捕获参数&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)validateDictionary:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; *)dict error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [dict enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull key, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull obj, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; * _Nonnull stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                *error = [&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; errorWithDomain:&lt;span class=&quot;string&quot;&gt;@&quot;FishDomain&quot;&lt;/span&gt; code:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ARC 会将 &lt;code&gt;(NSError **)error&lt;/code&gt; 这种 “out-parameter” 隐式修饰为 &lt;code&gt;__autoreleasing&lt;/code&gt;，也就是其实会被转化成 &lt;code&gt;(NSError * __autoreleasing *)error&lt;/code&gt;。（PS：相关知识参考 &lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#indirect-parameters&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Indirect parameters&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;给 &lt;code&gt;*error&lt;/code&gt; 赋值时，因为它被 &lt;code&gt;__autoreleasing&lt;/code&gt; 修饰，所以 ARC 下的 Clang 会隐式调用 &lt;code&gt;retain&lt;/code&gt; 和 &lt;code&gt;autorelease&lt;/code&gt;。 PS: 相关知识参考 &lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#semantics&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Semantics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;enumerateKeysAndObjectsUsingBlock:&lt;/code&gt; 方法会在 &lt;code&gt;@autoreleasepool&lt;/code&gt; 里面执行 Block，在迭代逻辑中这样做有助于减少内存峰值。&lt;/p&gt;
&lt;p&gt;于是 &lt;code&gt;*error&lt;/code&gt; 就在 Block 里提前被释放了。Xcode 9 会针对这种情况发出 warning：”Block captures an autoreleasing out-parameter, which may result in use-after-free bugs”。解决方案：”Declare the parameter &lt;strong&gt;strong or capture a &lt;/strong&gt;block __strong variable to keep values alive across autorelease pools”&lt;/p&gt;
&lt;p&gt;第一个解决方案简单地把参数 &lt;code&gt;(NSError **)error&lt;/code&gt; 改成 &lt;code&gt;(NSError *__strong *)error&lt;/code&gt;，这要求调用方也使用 ARC。第二个解决方案是利用 &lt;code&gt;__block&lt;/code&gt; 让 Block 捕获外部变量，默认是强引用：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)validateDictionary:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt; *)dict error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *strongError = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [dict enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull key, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull obj, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; * _Nonnull stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            strongError = [&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; errorWithDomain:&lt;span class=&quot;string&quot;&gt;@&quot;FishDomain&quot;&lt;/span&gt; code:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *error = strongError;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于 Clang 隐式调用 &lt;code&gt;retain&lt;/code&gt; 和 &lt;code&gt;autorelease&lt;/code&gt; 更深入的细节如下：&lt;/p&gt;
&lt;h4 id=&quot;Clang-5-中的-Objective-C-ARC-方法家族&quot;&gt;&lt;a href=&quot;#Clang-5-中的-Objective-C-ARC-方法家族&quot; class=&quot;headerlink&quot; title=&quot;Clang 5 中的 Objective-C ARC 方法家族&quot;&gt;&lt;/a&gt;Clang 5 中的 Objective-C ARC 方法家族&lt;/h4&gt;&lt;p&gt;Objective-C 中有&lt;a href=&quot;http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-method-families&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;五大方法家族&lt;/a&gt;，每个家族都有自己的规矩：&lt;code&gt;alloc/new/copy/mutableCopy&lt;/code&gt; 四个家族的方法返回的是 “a retainable object pointer”，而 &lt;code&gt;init&lt;/code&gt; 家族方法要求必须是实例方法，必须返回 Objective-C 对象。&lt;/p&gt;
&lt;p&gt;把一个方法划归到某个方法家族有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按照命名惯例划分方法家族&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;__attribute__((objc_method_family( somefamily )))&lt;/code&gt; 直接指定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果某个方法不遵循所在家族的规矩，会影响到内存管理，造成内存泄露等后果。（PS：如果是使用第二种方式把不守规矩的方法划归到家族，Clang 会报错。）&lt;/p&gt;
&lt;p&gt;ARC 下遵循一套内存管理原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;alloc/new/copy/mutableCopy&lt;/code&gt; 家族的方法创建的对象是自己持有的，会被 Clang 隐式标记为 &lt;code&gt;__attribute__((ns_returns_retained))&lt;/code&gt;。等效于 Foundation 中的宏 &lt;code&gt;NS_RETURNS_RETAINED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; 家族会被 Clang 隐式标记为 &lt;code&gt;__attribute__((ns_consumes_self))&lt;/code&gt; 和 &lt;code&gt;__attribute__((ns_returns_retained))&lt;/code&gt;，用 &lt;code&gt;NS_REPLACES_RECEIVER&lt;/code&gt; 宏也是等效的。&lt;/li&gt;
&lt;li&gt;不属于任何方法家族的方法会被 Clang 隐式标记为 &lt;code&gt;__attribute__((ns_returns_not_retained))&lt;/code&gt;，等效于 Foundation 中的宏 &lt;code&gt;NS_RETURNS_NOT_RETAINED&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般情况下 Clang 会帮我们做这些事情，不必给方法声明手动标记这些属性。而且 Clang 会对最终生成的汇编指令进行优化，去掉多余的 &lt;code&gt;retain&lt;/code&gt; 和 &lt;code&gt;autorelease&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;ARC 会&lt;strong&gt;视情况&lt;/strong&gt;在调用方法时&lt;strong&gt;可能会&lt;/strong&gt;添加 &lt;code&gt;retain&lt;/code&gt;，在方法内部返回时&lt;strong&gt;可能会&lt;/strong&gt;添加 &lt;code&gt;autorelease&lt;/code&gt;，经过优化后很可能会抵消。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; 其实并不是 Objective-C 的语法，而是 Clang 的属性。有关 Clang 的各种属性定义，请查看 &lt;a href=&quot;http://clang.llvm.org/docs/AttributeReference.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Attributes in Clang&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;探索方法返回值内存管理的奥秘&quot;&gt;&lt;a href=&quot;#探索方法返回值内存管理的奥秘&quot; class=&quot;headerlink&quot; title=&quot;探索方法返回值内存管理的奥秘&quot;&gt;&lt;/a&gt;探索方法返回值内存管理的奥秘&lt;/h4&gt;&lt;p&gt;先做两种情况的实验，查看汇编代码，并总结：&lt;/p&gt;
&lt;h5 id=&quot;方法为-alloc-new-copy-mutableCopy-家族或方法声明使用-NS-RETURNS-RETAINED&quot;&gt;&lt;a href=&quot;#方法为-alloc-new-copy-mutableCopy-家族或方法声明使用-NS-RETURNS-RETAINED&quot; class=&quot;headerlink&quot; title=&quot;方法为 alloc/new/copy/mutableCopy 家族或方法声明使用 NS_RETURNS_RETAINED&quot;&gt;&lt;/a&gt;方法为 &lt;code&gt;alloc/new/copy/mutableCopy&lt;/code&gt; 家族或方法声明使用 &lt;code&gt;NS_RETURNS_RETAINED&lt;/code&gt;&lt;/h5&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)newFoo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)foo &lt;span class=&quot;built_in&quot;&gt;NS_RETURNS_RETAINED&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)newFoo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;debug 时从汇编中可以看出：调用方无操作，方法返回时无操作。这显然是优化后的结果。虽然两种方式都能达到优化效果，但更推荐采用让方法加入方法家族，而不是直接使用 &lt;code&gt;NS_RETURNS_RETAINED&lt;/code&gt; 宏。&lt;/p&gt;
&lt;h5 id=&quot;普通方法&quot;&gt;&lt;a href=&quot;#普通方法&quot; class=&quot;headerlink&quot; title=&quot;普通方法&quot;&gt;&lt;/a&gt;普通方法&lt;/h5&gt;&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt; (id)foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt; (id)foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return [NSObject new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;debug 时从汇编中可以看出：调用方调用 &lt;code&gt;objc_retainAutoreleasedReturnValue()&lt;/code&gt;，方法返回时调用 &lt;code&gt;objc_autoreleaseReturnValue()&lt;/code&gt;（如果返回值没有赋值给变量，会调用 &lt;code&gt;objc_unsafeClaimAutoreleasedReturnValue()&lt;/code&gt;）。&lt;/p&gt;
&lt;h5 id=&quot;优化过程及原理&quot;&gt;&lt;a href=&quot;#优化过程及原理&quot; class=&quot;headerlink&quot; title=&quot;优化过程及原理&quot;&gt;&lt;/a&gt;优化过程及原理&lt;/h5&gt;&lt;p&gt;&lt;code&gt;objc_retainAutoreleasedReturnValue(value)&lt;/code&gt; 会尝试将之前调用 &lt;code&gt;objc_autoreleaseReturnValue(value)&lt;/code&gt; 时传入参数 &lt;code&gt;value&lt;/code&gt; 的所有权（retain count）传递过来。如果没有在 &lt;code&gt;value&lt;/code&gt; 上调用过 &lt;code&gt;objc_autoreleaseReturnValue(value)&lt;/code&gt;，那就调用 &lt;code&gt;retain&lt;/code&gt;。具体原理通过查看 Objective-C 源码可以得出(我列举的是 objc-709)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_autoreleaseReturnValue()&lt;/code&gt; 试图优化流程，如果上一层调用方会调用 &lt;code&gt;objc_retainAutoreleasedReturnValue()&lt;/code&gt; 则直接返回参数，否则调用 &lt;code&gt;autorelease&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;id &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;objc_autoreleaseReturnValue&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;id obj&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// ReturnAtPlus1 表示倾向直接把对象返回，这样就不需要调用 objc_autorelease()，优化性能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (prepareOptimizedReturn(ReturnAtPlus1)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ALWAYS_INLINE &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;prepareOptimizedReturn&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;ReturnDisposition disposition&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert(getReturnDisposition() == ReturnAtPlus0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// __builtin_return_address(0) 获取当前函数返回地址，传入 callerAcceptsOptimizedReturn 判断调用方是否紧接着调用了 objc_retainAutoreleasedReturnValue 或者 objc_unsafeClaimAutoreleasedReturnValue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (callerAcceptsOptimizedReturn(__builtin_return_address(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将标志位 disposition 写入 TLS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (disposition) setReturnDisposition(disposition);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ALWAYS_INLINE &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;setReturnDisposition&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;ReturnDisposition disposition&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;// 向 TLS 中写入 Disposition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tls_set_direct(RETURN_DISPOSITION_KEY, (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;*)(uintptr_t)disposition);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ALWAYS_INLINE ReturnDisposition &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;getReturnDisposition&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;// 从 TLS 中读取 Disposition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (ReturnDisposition)(uintptr_t)tls_get_direct(RETURN_DISPOSITION_KEY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;callerAcceptsOptimizedReturn()&lt;/code&gt; 函数在不同架构的 CPU 上实现也是不一样的，这是因为不同架构 CPU 的对齐方式不同，偏移量也不同。比如在 arm64 上由于指令对齐方式较好，只需判断函数返回的地址指向的值是不是 &lt;code&gt;0xaa1d03fd&lt;/code&gt; 即可；而在 x86_64 平台上则要用一大坨代码来判断。有兴趣的可以查看 objc-object.h 文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_retainAutoreleasedReturnValue()&lt;/code&gt; 试图查看是否已优化过并直接返回参数，否则 &lt;code&gt;retain&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;id obj&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;   &lt;span class=&quot;comment&quot;&gt;// 如果之前 objc_autoreleaseReturnValue() 存入的标志位为 ReturnAtPlus1，则直接返回对象，无需调用 objc_retain()，优化性能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (acceptOptimizedReturn() == ReturnAtPlus1) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_retain(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 负责从 TLS 中取标志位 ReturnDisposition，然后将其重置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ALWAYS_INLINE ReturnDisposition &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;acceptOptimizedReturn&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ReturnDisposition disposition = getReturnDisposition();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setReturnDisposition(ReturnAtPlus0);  &lt;span class=&quot;comment&quot;&gt;// reset to the unoptimized state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; disposition;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;TLS 全称为 Thread Local Storage，是每个线程专有的键值存储。在某个线程上的函数调用栈上相邻两个函数对 TLS 进行了存取，这中间肯定不会有别的程序『插手』。所以 &lt;code&gt;getReturnDisposition()&lt;/code&gt; 和 &lt;code&gt;setReturnDisposition()&lt;/code&gt; 的实现比较简单，不需要判断考虑是针对哪个对象的 Disposition 进行存取，因为当前线程上下文中只处理唯一的对象，保证不会乱掉。&lt;/p&gt;
&lt;h3 id=&quot;无参数函数的声明&quot;&gt;&lt;a href=&quot;#无参数函数的声明&quot; class=&quot;headerlink&quot; title=&quot;无参数函数的声明&quot;&gt;&lt;/a&gt;无参数函数的声明&lt;/h3&gt;&lt;p&gt;如果函数没有参数，需要用 &lt;code&gt;void&lt;/code&gt; 显式声明。否则可能调用方会传入其他类型和数量的参数，在运行时引发 crash。如果用 &lt;code&gt;void&lt;/code&gt; 显式声明，在编译阶段就会产生 error。&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; foo() &lt;span class=&quot;comment&quot;&gt;// warning:This function declaration is not a prototype&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; foo(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// OK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;C-Refactoring&quot;&gt;&lt;a href=&quot;#C-Refactoring&quot; class=&quot;headerlink&quot; title=&quot;C++ Refactoring&quot;&gt;&lt;/a&gt;C++ Refactoring&lt;/h2&gt;&lt;p&gt;对于一个带有 C++ 或 Objective-C++ 代码的工程来说，想重命名某个类名真的是艰难，Xcode 会提示不支持 C++！现在，各种操作也支持 C++ 咯：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/LLVM/C++%20Refactoring.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;LLVM 的重构代码功能极大节省了开发者的时间。&lt;/p&gt;
&lt;h2 id=&quot;Features-from-C-17&quot;&gt;&lt;a href=&quot;#Features-from-C-17&quot; class=&quot;headerlink&quot; title=&quot;Features from C++17&quot;&gt;&lt;/a&gt;Features from C++17&lt;/h2&gt;&lt;p&gt;其实这些都是 C++17 的新特性罢了，LLVM 9.0 积极响应支持。可以在编译选项 C++ Language Dialect 中选择使用的 C++ 标准库。GNU++17 比 C++17 多了语言扩展。&lt;/p&gt;
&lt;h3 id=&quot;Structured-Binding&quot;&gt;&lt;a href=&quot;#Structured-Binding&quot; class=&quot;headerlink&quot; title=&quot;Structured Binding&quot;&gt;&lt;/a&gt;Structured Binding&lt;/h3&gt;&lt;p&gt;解析 Tuple 可以一句搞定了：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::tuple&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;gt; compute();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; [a, b, c] = compute();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;甚至也可以解析类似 tuple 的类型：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Point &amp;#123; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; y; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; z; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Point &lt;span class=&quot;title&quot;&gt;computeMidPoint&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Point p1, Point p2)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; [x, y, z] = computeMidPoint(src, dest);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更多内容详见 C++17 的 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stuctured Binding&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;在条件判断语句中声明初始化变量&quot;&gt;&lt;a href=&quot;#在条件判断语句中声明初始化变量&quot; class=&quot;headerlink&quot; title=&quot;在条件判断语句中声明初始化变量&quot;&gt;&lt;/a&gt;在条件判断语句中声明初始化变量&lt;/h3&gt;&lt;p&gt;在判断某个条件之前，可能会产生一些中间变量，如果变量名与外界的有冲突，还会造成一些影响。所以需要一种只在条件判断语句范围内生效的局部变量，避免与无关逻辑代码有冲突：&lt;/p&gt;
&lt;figure class=&quot;highlight gcode&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;(auto a = getNumber()&lt;/span&gt;; a &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	foo&lt;span class=&quot;comment&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// error! a 只在上面的 if 作用域中有效。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;constexpr-if&quot;&gt;&lt;a href=&quot;#constexpr-if&quot; class=&quot;headerlink&quot; title=&quot;constexpr if&quot;&gt;&lt;/a&gt;constexpr if&lt;/h3&gt;&lt;p&gt;以 &lt;code&gt;if constexpr&lt;/code&gt; 开始的语句被称为 &lt;code&gt;constexpr if&lt;/code&gt; 语句。– &lt;a href=&quot;http://zh.cppreference.com/w/cpp/language/if&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cppreference.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;code&gt;advance&lt;/code&gt; 函数可以向前或向后迭代指定步数，但对于字符串和数组来说有更快的方式：无需一步步迭代，可以直接访问。但 &lt;code&gt;advance&lt;/code&gt; 的参数是通用的，编译不通过：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/LLVM/constexpr%20if%200.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;传统解决方法是 Compile Time Dispatch：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/LLVM/constexpr%20if%201.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;C++17 的 &lt;code&gt;constexpr if&lt;/code&gt; 可以一行搞定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/LLVM/constexpr%20if%202.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;详见 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0292r2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;constexpr if&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;string-view&quot;&gt;&lt;a href=&quot;#string-view&quot; class=&quot;headerlink&quot; title=&quot;string_view&quot;&gt;&lt;/a&gt;string_view&lt;/h3&gt;&lt;p&gt;简单来说它是指向字符串的指针，但不会拷贝一份字符串。一旦指向的字符串被修改或者被释放了，&lt;code&gt;string_view&lt;/code&gt; 的内容也会跟跟着变，毕竟是同一份内存。所以，虽然会优化性能，慎用。就像 OC 中的字符串和数组传递赋值时一般都 &lt;code&gt;copy&lt;/code&gt;，string_view 相当于是 &lt;code&gt;assign&lt;/code&gt;，搞不好野指针呢。&lt;/p&gt;
&lt;p&gt;详见 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html#string.view&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;string_view&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Link-Time-Optimization&quot;&gt;&lt;a href=&quot;#Link-Time-Optimization&quot; class=&quot;headerlink&quot; title=&quot;Link-Time Optimization&quot;&gt;&lt;/a&gt;Link-Time Optimization&lt;/h2&gt;&lt;p&gt;去年搞了个 LTO 和 增量 LTO，今年优化得编译速度更快了，于是建议我们打开 增量 LTO 啊：在编译选项中 Code Generation-&amp;gt;Link-Time Optimization&lt;/p&gt;
&lt;p&gt;其实我看了 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/405/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2016 年的 What’s New in LLVM&lt;/a&gt;, LTO 确实占了很大篇幅，不过当时还不建议开启。经过一年的优化后算是修成正果了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这&lt;strong&gt;绝不仅仅&lt;/strong&gt;是一篇 WWDC 2017 Session 411 学习笔记。除了有关 LLVM  9.0 的新特性之外，还有关于静态分析器和 Clang 5 Objective-C ARC 的一点看法和经验。&lt;/p&gt;
&lt;p&gt;我觉得 LLVM 9 的亮点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持 Objective-C API 可用性检查&lt;/li&gt;
&lt;li&gt;新增一些对隐患代码的静态分析检查和 warning&lt;/li&gt;
&lt;li&gt;更快的 LTO，使其可以真正使用&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Core ML and Vision Framework on iOS 11</title>
    <link href="http://yulingtianxia.com/blog/2017/06/19/Core-ML-and-Vision-Framework-on-iOS-11/"/>
    <id>http://yulingtianxia.com/blog/2017/06/19/Core-ML-and-Vision-Framework-on-iOS-11/</id>
    <published>2017-06-19T02:05:41.000Z</published>
    <updated>2017-07-05T15:04:45.000Z</updated>
    
    <content type="html">&lt;p&gt;机器学习和计算机视觉在 iOS 上虽然早已有了系统级的支持，但 WWDC 17 发布的 iOS 11 将它们的使用门槛大大降低。苹果提供了设计合理且容易上手的 API，让那些对基础理论知识一窍不通的门外汉也能玩转高大上的前沿科技，这是苹果一贯的风格。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这是一篇 WWDC 2017 Session 506，608，703 和 710 的学习笔记，以及分享自己尝试写的 Demo &lt;a href=&quot;https://github.com/yulingtianxia/Core-ML-Sample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core-ML-Sample&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/Core-ML-Sample/blob/master/coreml.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Core-ML&quot;&gt;&lt;a href=&quot;#Core-ML&quot; class=&quot;headerlink&quot; title=&quot;Core ML&quot;&gt;&lt;/a&gt;Core ML&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Core ML 大大降低了开发者在苹果设备上使用机器学习技术预测模型的门槛和成本。苹果制定了自己的模型文件格式，统一的格式和全新的 API 设计使得 Core ML 支持苹果生态下多个平台。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/coreml1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;将数据经过预处理后输入 MLMODEL 文件，输出为模型的预测结果。使用 Core ML 只需要很少的代码就可以构建起一个机器学习的应用。只需关注代码即可，无需关注模型的定义，网络的构成。这跟以前写 MPS 代码时构成了强烈的反差：开发者需要写大量 MPS 代码用于构建和描述一个完整的网络，而加载的文件仅仅是模型的权重而已。MLMODEL 文件包含了权重和模型结构等信息，并可以自动生成相关的代码，节省开发者大量时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/coreml2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Model-转换工具&quot;&gt;&lt;a href=&quot;#Model-转换工具&quot; class=&quot;headerlink&quot; title=&quot;Model 转换工具&quot;&gt;&lt;/a&gt;Model 转换工具&lt;/h3&gt;&lt;p&gt;苹果提供了一个 Python 工具，可以将业内一些常用的机器学习框架导出的 Model 转成 MLMODEL 文件。代码会编译成可执行二进制文件，而 MLMODEL 会编译成 Bundle 文件，在代码文件中可以直接调用 MLMODEL 生成的类，这些都是需要 Xcode 9 做支撑，也就是说，现阶段并不支持动态下发 MLMODEL 文件。Core ML 的预测过程全都在客户端进行，保证用户隐私不会泄露。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/coreml4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Core ML 支持 DNN,RNN,CNN,SVM,Tree ensembles,Generalized linear models,Pipeline models 等，对应的模型转换工具 &lt;a href=&quot;https://pypi.python.org/pypi/coremltools&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core ML Tools&lt;/a&gt; 也支持了一些常用机器学习框架模型的转换。虽然目前没有直接支持 Google 的 TensorFlow，但可以使用 Keras 曲线救国。&lt;code&gt;coremltools&lt;/code&gt; 已经开源，并提供可拓展性的底层接口，可以编写适配其他机器学习框架模型的转换工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/coreml3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;MLMODEL 文件中还包含了很多元数据，比如作者，License，输入输出的描述文字。这些元数据都可以通过 &lt;code&gt;coremltools&lt;/code&gt; 的接口进行设置。&lt;code&gt;coremltools&lt;/code&gt; 上手很简单，可以查看完整详细的&lt;a href=&quot;https://pythonhosted.org/coremltools/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;把 MLMODEL 文件拖拽到 Xcode 工程中后，记得要勾选对应的 target，这样 Xcode 才会自动生成对应的代码。生成的类名就是 MLMODEL 文件名，输入和输出的变量名和类型也可以在 Xcode 中查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/coreml5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;底层计算性能&quot;&gt;&lt;a href=&quot;#底层计算性能&quot; class=&quot;headerlink&quot; title=&quot;底层计算性能&quot;&gt;&lt;/a&gt;底层计算性能&lt;/h3&gt;&lt;p&gt;Core ML 的底层是 Accelerate BNNS 和 MPS，并可以根据实际情况进行无缝切换。比如在处理图片的场景下使用 MPS，处理文字场景下使用 Accelerate，甚至可以在同一个 model 的不同层使用不同的底层技术来预测。Vision 和 NLP 可以结合 Core ML 一起使用。Core ML 对硬件做了性能优化，而且支持的模型种类更多，开发者不用关注底层的一些细节，苹果全都封装好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/coreml6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，这些也都是建立在 MPS 更新的基础上，MPS 在 iOS 11 中拓展了支持向量和矩阵的数据结构 &lt;code&gt;MPSVector&lt;/code&gt; 与 &lt;code&gt;MPSMatrix&lt;/code&gt;，以及它们之间相乘的 API。而且提供了更多的神经网络类型（比如 RNN 等），在卷积神经网络中也提供了更多种类的卷积核，用于满足更多特殊场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/608_using_metal_2_for_compute_%E9%A1%B5%E9%9D%A2_065.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;苹果在 Metal 2 中补充 MPS 大量功能的同时，也提供了用于描述神经网络结构的语言：Neural Network Graph API。使用它可以极大简化代码逻辑，代码量缩减到以前的四分之一（以 Inception V3 为例）。并且使用 NN Graph API 可以并行使用 CPU 和 GPU。这种图语言跟主流的分布式机器学习框架的使用很像：先用简单的 Python 语言描述好网络结构，定义好输入输出格式，然后一次性提交到后端去执行。后端对底层性能做了很多细节优化，然而开发者完全不用关心这些。新增的 &lt;code&gt;MPSNNGraph&lt;/code&gt; 提供了异步接口使得 CPU 不用再等待 GPU 的执行结果，性能也得到提升。&lt;/p&gt;
&lt;p&gt;Metal 2 使用 MPS 进行图像处理的性能也得到了提升，在不同的设备上大约提升了百分之二十多。&lt;/p&gt;
&lt;h3 id=&quot;Demo-数据预处理&quot;&gt;&lt;a href=&quot;#Demo-数据预处理&quot; class=&quot;headerlink&quot; title=&quot;Demo: 数据预处理&quot;&gt;&lt;/a&gt;Demo: 数据预处理&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/Core-ML-Sample&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core-ML-Sample&lt;/a&gt; 使用了 Core ML 和 Vision 技术实现对摄像头拍摄的图像实时预测物体种类。因为图像来源是摄像头，所以需要将 &lt;code&gt;CMSampleBuffer&lt;/code&gt; 转成 &lt;code&gt;CVPixelBuffer&lt;/code&gt;。因为 Xcode 9 已经生成好了代码，直接调用 &lt;code&gt;Inceptionv3&lt;/code&gt; 类的 &lt;code&gt;prediction&lt;/code&gt; 方法即可完成预测。生成的 &lt;code&gt;Inceptionv3Output&lt;/code&gt; 类含有 &lt;code&gt;classLabel&lt;/code&gt; 和 &lt;code&gt;classLabelProbs&lt;/code&gt; 两个属性，可以获取预测的分类标签名以及每种标签的可能性。可以点击 Xcode Model View 中 Model Class 的生成源码箭头来查看这些类的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; inceptionv3model = &lt;span class=&quot;type&quot;&gt;Inceptionv3&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleImageBufferWithCoreML&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(imageBuffer: CMSampleBuffer)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pixelBuffer = &lt;span class=&quot;type&quot;&gt;CMSampleBufferGetImageBuffer&lt;/span&gt;(imageBuffer) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; prediction = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.inceptionv3model.prediction(image: &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.resize(pixelBuffer: pixelBuffer)!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;type&quot;&gt;DispatchQueue&lt;/span&gt;.main.async &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; prob = prediction.classLabelProbs[prediction.classLabel] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.predictLabel.text = &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(prediction.classLabel)&lt;/span&gt; &lt;span class=&quot;subst&quot;&gt;\(String(describing: prob)&lt;/span&gt;)&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; error &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;NSError&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Unexpected error ocurred: &lt;span class=&quot;subst&quot;&gt;\(error.localizedDescription)&lt;/span&gt;.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 Xcode Model View 中可以看到 Inceptionv3 模型的输入图片为 &lt;code&gt;Image&amp;lt;RGB,299,299&amp;gt;&lt;/code&gt;，所以需要对摄像头采集到的图像进行预处理。我的转换流程是：&lt;code&gt;CVPixelBuffer-&amp;gt;CVPixelBuffer-&amp;gt;CIImage-&amp;gt;CIImage(resized)-&amp;gt;CVPixelBuffer&lt;/code&gt;。最后一步 &lt;code&gt;CIImage&lt;/code&gt; 转 &lt;code&gt;CVPixelBuffer&lt;/code&gt; 是通过 &lt;code&gt;CIContext&lt;/code&gt; 渲染完成。&lt;/p&gt;
&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// resize CVPixelBuffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - Parameter pixelBuffer: CVPixelBuffer by camera output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - Returns: CVPixelBuffer with size (299, 299)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func resize(pixelBuffer: CVPixelBuffer) -&amp;gt; CVPixelBuffer? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   let imageSide = &lt;span class=&quot;number&quot;&gt;299&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var ciImage = CIImage(cvPixelBuffer: pixelBuffer, options: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   let transform = CGAffineTransform(scaleX: CGFloat(imageSide) / CGFloat(CVPixelBufferGetWidth(pixelBuffer)), y: CGFloat(imageSide) / CGFloat(CVPixelBufferGetHeight(pixelBuffer)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ciImage = ciImage.applying(transform).cropping(to: CGRect(x: 0, y: 0, width: imageSide, height: imageSide))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   let ciContext = CIContext()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var resizeBuffer: CVPixelBuffer?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   CVPixelBufferCreate(kCFAllocatorDefault, imageSide, imageSide, CVPixelBufferGetPixelFormatType(pixelBuffer), nil, &amp;amp;resizeBuffer)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ciContext.render(ciImage, to: resizeBuffer!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; resizeBuffer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了图片需要预处理外，其他数据可能也需要预处理。这需要看训练的模型的输入是什么形式，比如分析一段文本所表达的情绪是开心还是沮丧，可能需要写个预处理程序统计词频，然后输入到训练好的模型中进行预测。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Model 极速集成&lt;/li&gt;
&lt;li&gt;支持多种数据类型&lt;/li&gt;
&lt;li&gt;硬件优化&lt;/li&gt;
&lt;li&gt;适配主流机器学习框架&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Vision&quot;&gt;&lt;a href=&quot;#Vision&quot; class=&quot;headerlink&quot; title=&quot;Vision&quot;&gt;&lt;/a&gt;Vision&lt;/h2&gt;&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;人脸检测：支持检测笑脸、侧脸、局部遮挡脸部、戴眼镜和帽子等场景，可以标记出人脸的矩形区域&lt;/li&gt;
&lt;li&gt;人脸特征点：可以标记出人脸和眼睛、眉毛、鼻子、嘴、牙齿的轮廓，以及人脸的中轴线&lt;/li&gt;
&lt;li&gt;图像配准&lt;/li&gt;
&lt;li&gt;矩形检测&lt;/li&gt;
&lt;li&gt;二维码/条形码检测&lt;/li&gt;
&lt;li&gt;文字检测&lt;/li&gt;
&lt;li&gt;目标跟踪：脸部，矩形和通用模板&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Vision-使用姿势&quot;&gt;&lt;a href=&quot;#Vision-使用姿势&quot; class=&quot;headerlink&quot; title=&quot;Vision 使用姿势&quot;&gt;&lt;/a&gt;Vision 使用姿势&lt;/h3&gt;&lt;p&gt;将各种功能的 Request 提供给一个 RequestHandler，Handler 持有图片信息，并将处理结果分发给每个 Request 的 completion Block 中。可以从 &lt;code&gt;results&lt;/code&gt; 属性中得到 Observation 数组，然后进行更新 UI 等操作。因为 completion Block 所执行的队列跟 perform request 的队列相同，所以更新 UI 时记得使用主队列。&lt;/p&gt;
&lt;p&gt;Vision 操作流水线分为两类：分析图片和跟踪队列。可以使用图片检测出的物体或矩形结果（Observation）来作为跟踪队列请求（Request）的参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/506_vision_framework_building_on_core_ml_%E9%A1%B5%E9%9D%A2_36.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/506_vision_framework_building_on_core_ml_%E9%A1%B5%E9%9D%A2_40.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vision 支持的图片数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CVPixelBufferRef&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGImageRef&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIImage&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSURL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSData&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几乎涵盖了 iOS 中图片相关的 API，很实用很强大。&lt;/p&gt;
&lt;p&gt;Vision 有三种 resize 图片的方式，无需使用者再次裁切缩放&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VNImageCropAndScaleOptionCenterCrop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VNImageCropAndScaleOptionScaleFit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VNImageCropAndScaleOptionScaleFill&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vision 与 iOS 上其他几种带人脸检测功能框架的对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/iOS11/506_vision_framework_building_on_core_ml_%E9%A1%B5%E9%9D%A2_72.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Demo-与-Core-ML-集成&quot;&gt;&lt;a href=&quot;#Demo-与-Core-ML-集成&quot; class=&quot;headerlink&quot; title=&quot;Demo: 与 Core ML 集成&quot;&gt;&lt;/a&gt;Demo: 与 Core ML 集成&lt;/h3&gt;&lt;p&gt;Core ML 具有更好的性能，Vision 可为其提供图片处理的流程。Core ML 生成的代码中含有 &lt;code&gt;MLModel&lt;/code&gt; 类型的 &lt;code&gt;model&lt;/code&gt; 对象，可以用它初始化 &lt;code&gt;VNCoreMLModel&lt;/code&gt; 对象，这样就将 Core ML 的 Model 集成进 Vision 框架中了：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; requests = [&lt;span class=&quot;type&quot;&gt;VNRequest&lt;/span&gt;]()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setupVision&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; visionModel = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;VNCoreMLModel&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;: inceptionv3model.model) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;can&#39;t load Vision ML model&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; classificationRequest = &lt;span class=&quot;type&quot;&gt;VNCoreMLRequest&lt;/span&gt;(model: visionModel) &amp;#123; (request: &lt;span class=&quot;type&quot;&gt;VNRequest&lt;/span&gt;, error: &lt;span class=&quot;type&quot;&gt;Error&lt;/span&gt;?) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; observations = request.results &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;no results:&lt;span class=&quot;subst&quot;&gt;\(error!)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; classifications = observations[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;...&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           .flatMap(&amp;#123; $&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;VNClassificationObservation&lt;/span&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           .&lt;span class=&quot;built_in&quot;&gt;filter&lt;/span&gt;(&amp;#123; $&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.confidence &amp;gt; &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           .&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(&amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\($&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.identifier)&lt;/span&gt; &lt;span class=&quot;subst&quot;&gt;\($&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.confidence)&lt;/span&gt;&quot;&lt;/span&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;type&quot;&gt;DispatchQueue&lt;/span&gt;.main.async &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.predictLabel.text = classifications.joined(separator: &lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   classificationRequest.imageCropAndScaleOption = &lt;span class=&quot;type&quot;&gt;VNImageCropAndScaleOptionCenterCrop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.requests = [classificationRequest]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码实现了 Vision 的工作流，并在 completion Block 中对预测结果进行了处理：从 top5 中筛选可能性大于 0.2 的结果，并转成文本描述。因为所有结果的可能性总和为 1，所以最终的结果不会达到 5 个，实际测试中其实结果往往只有 1-2 个。&lt;/p&gt;
&lt;p&gt;对摄像头传入的每帧图片进行预测。虽然 Vision 帮我们完成了预处理等流程上的工作，但是需要我们传入一些额外的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleImageBufferWithVision&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(imageBuffer: CMSampleBuffer)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; pixelBuffer = &lt;span class=&quot;type&quot;&gt;CMSampleBufferGetImageBuffer&lt;/span&gt;(imageBuffer) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; requestOptions:[&lt;span class=&quot;type&quot;&gt;VNImageOption&lt;/span&gt; : &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] = [:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; cameraIntrinsicData = &lt;span class=&quot;type&quot;&gt;CMGetAttachment&lt;/span&gt;(imageBuffer, kCMSampleBufferAttachmentKey_CameraIntrinsicMatrix, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       requestOptions = [.cameraIntrinsics:cameraIntrinsicData]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; imageRequestHandler = &lt;span class=&quot;type&quot;&gt;VNImageRequestHandler&lt;/span&gt;(cvPixelBuffer: pixelBuffer, orientation: &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.exifOrientationFromDeviceOrientation, options: requestOptions)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; imageRequestHandler.perform(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.requests)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(error)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要向图片传入 EXIF Orientation 信息：&lt;/p&gt;
&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; only support back camera&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;symbol&quot;&gt;exifOrientationFromDeviceOrientation:&lt;/span&gt; Int32 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   let &lt;span class=&quot;symbol&quot;&gt;exifOrientation:&lt;/span&gt; DeviceOrientation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DeviceOrientation&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Int32&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; top0ColLeft = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; top0ColRight = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; bottom0ColRight = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; bottom0ColLeft = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; left0ColTop = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; right0ColTop = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; right0ColBottom = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; left0ColBottom = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   switch UIDevice.current.orientation &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;symbol&quot;&gt;portraitUpsideDown:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       exifOrientation = .left0ColBottom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;symbol&quot;&gt;landscapeLeft:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       exifOrientation = .top0ColLeft&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; .&lt;span class=&quot;symbol&quot;&gt;landscapeRight:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       exifOrientation = .bottom0ColRight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;symbol&quot;&gt;default:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       exifOrientation = .right0ColTop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; exifOrientation.rawValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;总结-1&quot;&gt;&lt;a href=&quot;#总结-1&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Vision 是一个关于计算机视觉的顶层新框架。&lt;/li&gt;
&lt;li&gt;一个界面，多重跟踪检测&lt;/li&gt;
&lt;li&gt;集成 Core ML 轻松使用自己的 model&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;感受&quot;&gt;&lt;a href=&quot;#感受&quot; class=&quot;headerlink&quot; title=&quot;感受&quot;&gt;&lt;/a&gt;感受&lt;/h2&gt;&lt;p&gt;苹果为开发者带来了炫酷的功能，并且这些示例很有针对性，更实用。Vision 更像是一个工具库，对一些高频场景进行了封装，比如人脸、条形码、矩形和文字等，这些基于底层 API 封装的高级功能可以帮助开发者很快地完成老板的功能。而 Core ML 给出的 Model 也很有代表性，贴近实际应用场景，很容易激发开发者使用的热情。我想这正是苹果最擅长的，把复杂的事情简单化，提供极易上手的 Demo，并循序渐进，给予开发者更高深的玩法，不失拓展性和定制化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coremltools&lt;/code&gt; 肯定还存在一些兼容性问题，并且会随着各大机器学习框架的更新而不断更新，我想这也是为何苹果将其开源的原因吧。使用 python 也更方便维护，而且主流的机器学习框架都是用 python 作为前端语言。&lt;/p&gt;
&lt;p&gt;Core ML 功能强大，支持的模型种类很多。与此同时，MPS 在 iOS 11 也得到了升级，新增的数据类型更方便使用。总之其实还是新增了对底层数据和算法的封装，然后 Core ML 在此基础上又进行了一层高级的封装。可以看出苹果这一年在底层下的功夫确实不少，在这之后才有了更强大更全面的 API。我预测在这之后 Core ML 还会有更多的模型得到支持，Vision 也会加入更丰富的应用场景。&lt;/p&gt;
&lt;p&gt;如果苹果能够发挥硬件上性能的优势，可能在以后还会演示出更炫酷的 Demo，比如视频实时防抖的处理，更牛逼的滤镜效果。对高性能计算和 GPU 图像处理感兴趣的话，推荐看下 Metal 2 相关的 Session，尤其是 Session 608。&lt;/p&gt;
&lt;p&gt;同时也会发现苹果在机器学习的道路上避开了各个训练框架的锋芒，尤其是最近大红大紫的 Google TensorFlow。它选择另辟蹊径，在移动端模型预测性能优化和低成本接入的道路上另辟蹊径，充分发挥自身平台的优势。毕竟在移动端训练模型意义较小，还是交给服务端比较合理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习和计算机视觉在 iOS 上虽然早已有了系统级的支持，但 WWDC 17 发布的 iOS 11 将它们的使用门槛大大降低。苹果提供了设计合理且容易上手的 API，让那些对基础理论知识一窍不通的门外汉也能玩转高大上的前沿科技，这是苹果一贯的风格。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yulingtianxia.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Implementing CNN with MPS</title>
    <link href="http://yulingtianxia.com/blog/2017/05/30/Implementing-CNN-with-MPS/"/>
    <id>http://yulingtianxia.com/blog/2017/05/30/Implementing-CNN-with-MPS/</id>
    <published>2017-05-30T09:20:32.000Z</published>
    <updated>2017-06-17T02:55:01.000Z</updated>
    
    <content type="html">&lt;p&gt;最近一个月从零开始自学了下有关 iOS 上的机器学习相关知识，亲身实践了从数据采集到训练模型再到移动端预测的流程。理论知识学习路径为：&lt;strong&gt;机器学习-&amp;gt;深度学习-&amp;gt;迁移学习&lt;/strong&gt;；实践框架学习路径为：&lt;strong&gt;TensorFlow-&amp;gt;Keras-&amp;gt;MPS(iOS 10)&lt;/strong&gt;。最终完成一个简单的手势图像五分类问题，并预测 iOS 摄像头采集的图片。最终结果，训练集准确率 96.26%，交叉验证集准确率 73.86%。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a href=&quot;#理论基础&quot; class=&quot;headerlink&quot; title=&quot;理论基础&quot;&gt;&lt;/a&gt;理论基础&lt;/h2&gt;&lt;p&gt;虽然结果导向很重要，但是我还是想从基础学起，而不是去急于去网上找现成的解决方案来调参。毕竟我的目的是拓宽知识面，开新的技能树。&lt;/p&gt;
&lt;p&gt;第一周从零开始学习了 Coursera 上 Stanford Ng 教授的 &lt;a href=&quot;https://www.coursera.org/learn/machine-learning/home&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Machine Learning&lt;/a&gt; 经典课程，用 Matlab 编写了一些 Demo，用一周时间完成了原本需要 11 周时间的所有课程和考试，对机器学习的基础知识有了掌握。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/mw1024/642c5793ly1ff5ornniluj21kw0u3tn2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;机器学习大体可以分为有监督学习和无监督学习。带标签数据的有监督学习包含从最简单的线性回归到逻辑回归，再到神经网络和 SVM（支持向量机）。无监督学习包含大学竖直的 K-means 聚类，PCA(Principal Components Analysis) 降维。以及带标签数据的异常检测算法。为了确保机器学习的效果，需要通过看懂学习曲线决定下一步的工作，是解决 overfit 还是 underfit。使用交叉验证集和测试集评估模型时，如何平衡准确率和召回率，比如 F1 Score 指标。在数据预处理上要了解一些数据归一化标准化的方法。&lt;/p&gt;
&lt;p&gt;光掌握机器学习的基础知识显然不够，大而全不如专而精。深度学习在图像识别领域大放异彩，其实深度学习是机器学习的一个分支，而深度学习领域最近在图像识别上应用最火的可能就是 CNN 了。所以在狂学深度学习的时候重点研究了下 CNN。&lt;/p&gt;
&lt;h3 id=&quot;卷积神经网络简介&quot;&gt;&lt;a href=&quot;#卷积神经网络简介&quot; class=&quot;headerlink&quot; title=&quot;卷积神经网络简介&quot;&gt;&lt;/a&gt;卷积神经网络简介&lt;/h3&gt;&lt;p&gt;全连接网络权重过多，而卷积神经网络可以实现权值共享，引入了深度，数据为 3D 的。推荐查看 Stanford 的 &lt;a href=&quot;http://cs231n.github.io/convolutional-networks/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Convolutional Neural Networks (CNNs / ConvNets)&lt;/a&gt;，中文翻译：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22038289&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CS231n课程笔记翻译：卷积神经网络笔记&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;卷积核一般为奇数，常用的都是小卷积核，比如 1x1,3x3,5x5。&lt;a href=&quot;https://zh.wikipedia.org/wiki/卷积&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;卷积&lt;/a&gt;是一种数学运算，卷积核在扫描数据的时候，正好做的就是卷积运算。卷积核其实就是个滤波器，通过平移点积运算处理数据。一个卷积层可以有多个卷积核，也就是多个滤波器，每种滤波器所『感受』的内容不同，结果也很有意思。可以看看这篇文章：&lt;a href=&quot;https://blog.keras.io/how-convolutional-neural-networks-see-the-world.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How convolutional neural networks see the world&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;CNN 中不仅有 Convolution，还有 Pooling，Activation，Fully Connected等层级。&lt;/p&gt;
&lt;p&gt;Pooling 就是 downsampling，减小数据尺寸，常用的有有 max，average 等运算。&lt;br&gt;Activation 就是激活函数，常用的有 sigmoid，ReLU 等。&lt;br&gt;Fully Connected 也叫 Dense，因为全连接权重密度很大。其实就是个卷积核宽高等于输入数据宽高的特殊卷积层。卷积层和全连接层可以等效转换。&lt;/p&gt;
&lt;p&gt;如果卷积核尺寸不是 1x1，或平移的步长不是 1x1，那么卷积运算后的结果肯定比原尺寸要小，所以padding 规则就很重要。一般常用的『Same』规则就是在数据周围填充一些 0，使得卷积运算后的数据宽和高跟输入数据一样。&lt;/p&gt;
&lt;h3 id=&quot;图片分类常用的数据和预设网络模型&quot;&gt;&lt;a href=&quot;#图片分类常用的数据和预设网络模型&quot; class=&quot;headerlink&quot; title=&quot;图片分类常用的数据和预设网络模型&quot;&gt;&lt;/a&gt;图片分类常用的数据和预设网络模型&lt;/h3&gt;&lt;p&gt;图片分类使用已经打好标签的数据库来进行有监督学习，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Dataset&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Training Set Size&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Testing Set Size&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Number of Classes&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Comments&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://www.cs.toronto.edu/~kriz/cifar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cifar10&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;60k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;32x32 color&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MNIST&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;60k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;28x28 gray&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://www.image-net.org/challenges/LSVRC/2012/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageNet&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1.2M&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;50k&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1000&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Various sizes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MNIST&lt;/a&gt; 算是深度学习领域的 HelloWorld 了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CIFAR&lt;/a&gt; 小尺寸图片数据库，包含 CIFAR10 和 CIFAR100。&lt;/p&gt;
&lt;p&gt;在图像识别领域，&lt;a href=&quot;http://image-net.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageNet&lt;/a&gt; 是非常有名的数据库，历年挑战中都有新的更复杂的神经网络跑出更好的结果。下面的表是一些网络模型在 &lt;a href=&quot;http://image-net.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageNet&lt;/a&gt; Challenge 中的准确率以及 TF-Slim 源码和 checkpoint 文件，数据来源：&lt;a href=&quot;https://github.com/tensorflow/models/tree/master/slim&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TensorFlow-Slim image classification library&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Model&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;TF-Slim File&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Checkpoint&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Top-1 Accuracy&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Top-5 Accuracy&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1409.4842v1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V1&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_v1.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_v1_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_v1_2016_08_28.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;69.8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;89.6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1502.03167&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V2&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_v2_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_v2_2016_08_28.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;73.9&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;91.8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1512.00567&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V3&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_v3.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_v3_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_v3_2016_08_28.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;78.0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;93.9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1602.07261&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V4&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_v4.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_v4_2016_09_09.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_v4_2016_09_09.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;80.2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;95.2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1602.07261&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception-ResNet-v2&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/inception_resnet_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/inception_resnet_v2_2016_08_30.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;inception_resnet_v2.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;80.4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;95.3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V1 50&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v1.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v1_50_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v1_50.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;75.2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;92.2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V1 101&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v1.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v1_101_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v1_101.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;76.4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;92.9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V1 152&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v1.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v1_152_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v1_152.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;76.8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;93.2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1603.05027&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V2 50&lt;/a&gt;^&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v2_50_2017_04_14.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v2_50.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;75.6&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;92.8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1603.05027&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V2 101&lt;/a&gt;^&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v2_101_2017_04_14.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v2_101.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;77.0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;93.7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://arxiv.org/abs/1603.05027&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ResNet V2 152&lt;/a&gt;^&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/resnet_v2.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/resnet_v2_152_2017_04_14.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resnet_v2_152.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;77.8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;94.1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1409.1556.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VGG 16&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/vgg.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/vgg_16_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vgg_16.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;71.5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;89.8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://arxiv.org/abs/1409.1556.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VGG 19&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/tensorflow/models/blob/master/slim/nets/vgg.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Code&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;http://download.tensorflow.org/models/vgg_19_2016_08_28.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vgg_19.tar.gz&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;71.1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;89.8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;推荐一个还算不错的机器学习的数据网站：&lt;a href=&quot;https://www.kaggle.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kaggle&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;迁移学习&quot;&gt;&lt;a href=&quot;#迁移学习&quot; class=&quot;headerlink&quot; title=&quot;迁移学习&quot;&gt;&lt;/a&gt;迁移学习&lt;/h3&gt;&lt;p&gt;从头开始训练一个复杂的网络是很费时费力的，需要获取符合目标的海量真实数据，并使用性能极强的集群来训练数据，并有足够的耐心等待训练结果。稍有不慎，还需要不断调参，重新再来。这是个枯燥乏味的体力活，并且是在有硬件经济实力的基础上才办得到的。总会看到一些论文里描述自己的模型用 Tesla KXX 跑了多久才训练出了结果，其实在机器学习领域，花费半年甚至更久的时间来调参优化模型是很正常的。&lt;/p&gt;
&lt;p&gt;所以基于已经训练好的模型参数来进行 fine-tuning 后应用到新的模型上是一个省时省力的方案，也被称之为迁移学习。大部分数据是存在相关性的，在图片分类问题中，即便现有模型不包含我们想要的分类，也可以利用已经训练好的权重来进行 fine-tuning，使其对新的类别进行分类。&lt;/p&gt;
&lt;p&gt;一般的做法是将已经训练好的模型权重加载，除去 top 部分（全连接层和 softmax 分类器等），冻结前面层级的权重，只保留想要 fine-tuning 的层级（一般是后面的卷积层），最后根据分类个数自己添加全连接层。训练时只有后面的层级权重才会被修改，前面已经训练好的权重不会改变。这样会很快将正确率提高到 90% 以上。&lt;/p&gt;
&lt;p&gt;详细内容可以参考这篇文章：(&lt;a href=&quot;https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;框架选择&quot;&gt;&lt;a href=&quot;#框架选择&quot; class=&quot;headerlink&quot; title=&quot;框架选择&quot;&gt;&lt;/a&gt;框架选择&lt;/h2&gt;&lt;p&gt;有一些知名的框架可供选择：TensorFlow, Torch, Caffee, Theano, Keras…&lt;/p&gt;
&lt;p&gt;不同框架所使用的数据格式不一样，主要区别在于 Channel  通道的位置是在最前还是最后。框架之间的学习成本都不一样，单拿 TensorFlow 来说，其最基础的语法需要一点点构建一张图，而其 &lt;code&gt;tf.contrib.learn&lt;/code&gt; 和 &lt;code&gt;tf.contrib.layers&lt;/code&gt; API 是更高一层的封装，还有 TF-Slim 这种更轻量级的高级封装，几行代码就能干好多事，看起来更屌。但其实目前由于 TensorFlow 的快速迭代，导致不能向下兼容，老代码运行不起来。单拿 TF-Slim 来说，官网 API 文档缺失，Github 的教程代码老旧无法运行，还在使用从 model 库 merge 到 tensorflow 之前的语法。我当时本想用 TF-Slim 快速验证一些模型，结果没想到反而浪费了大量时间，得不偿失。&lt;/p&gt;
&lt;p&gt;Keras 基于 TensorFlow 或 Theano，集成了大量功能，是一种方便快速验证 idea 的高层 API。 内置大量常用网络，很容易上手，语法简洁，功能强大又不失可定制性。强力推荐，官方文档：&lt;a href=&quot;https://keras.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras Documentation&lt;/a&gt;，中文文档：&lt;a href=&quot;http://keras-cn.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras 中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无论是哪种框架，几乎都是基于分布式设计的思想，先描述出计算图，然后再向图中填充数据流，使其运转起来，最后得到结果。虽然是使用 Python 语言来描述计算图，但是真正繁重的工作都会提交给底层的后端去处理。但这样也给 debug 带来了困难，因为描述计算图的时候并不能得到数据结果，只能检查出数据格式是否匹配。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;笼统的说，符号主义的计算首先定义各种变量，然后建立一个“计算图”，计算图规定了各个变量之间的计算关系。建立好的计算图需要编译以确定其内部细节，然而，此时的计算图还是一个“空壳子”，里面没有任何实际的数据，只有当你把需要运算的输入放进去后，才能在整个模型中形成数据流，从而形成输出值。&lt;br&gt;    就像用管道搭建供水系统，当你在拼水管的时候，里面是没有水的。只有所有的管子都接完了，才能送水。&lt;br&gt;    – 引自 &lt;a href=&quot;http://keras-cn.readthedocs.io/en/latest/for_beginners/concepts/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://keras-cn.readthedocs.io/en/latest/for_beginners/concepts/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据采集&quot;&gt;&lt;a href=&quot;#数据采集&quot; class=&quot;headerlink&quot; title=&quot;数据采集&quot;&gt;&lt;/a&gt;数据采集&lt;/h2&gt;&lt;p&gt;因为网上提供的一些用于训练的海量图片数据都是格式整齐像素较低的图片，比如28x28这种，且特征明显，都为某种物体，这种专用于比赛挑战的图片分类数量一般都是10，100，1000等，更专注于算法的准确率，忽视了真实的场景。&lt;/p&gt;
&lt;p&gt;为了模拟真实场景，我使用 Web 程序调用 iMac 前置摄像头采集 320x240 尺寸的照片。为了更高效采集图片数据，我采用连拍的方式拍摄并保存图片到本地：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MachineLearning/training_data.png&quot; alt=&quot;帅是我的无奈&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要去除少量过于模糊和手指不小心跑出屏幕外的图片，尽可能提高数据的质量。&lt;/p&gt;
&lt;p&gt;因为不同平台和浏览器对 Html5 规范支持程度不同，建议在 Mac 上使用 Firefox，Windows 上应该 Chrome 也好使，但没试过。&lt;/p&gt;
&lt;p&gt;图像采集的代码放在 &lt;a href=&quot;https://github.com/yulingtianxia/HandGestureCNN/tree/master/captureImages&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;captureImages&lt;/a&gt; 目录里。&lt;/p&gt;
&lt;h2 id=&quot;Inception-V3-pre-trained-network&quot;&gt;&lt;a href=&quot;#Inception-V3-pre-trained-network&quot; class=&quot;headerlink&quot; title=&quot;Inception V3 pre-trained network&quot;&gt;&lt;/a&gt;Inception V3 pre-trained network&lt;/h2&gt;&lt;p&gt;在 Keras Blog 中，&lt;a href=&quot;https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Building powerful image classification models using very little data&lt;/a&gt; 很好地介绍了如何针对小数据集利用现有的 VGG16 网络 fine-tuning，并在 &lt;a href=&quot;https://www.kaggle.com/c/dogs-vs-cats/data&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dogs vs. Cats&lt;/a&gt; 数据集上取得了 94% 的准确率。&lt;/p&gt;
&lt;p&gt;VGG 系列网络虽然结构简单易理解，但无论是加载权重的耗时还是预测耗时都要比 Inception 系列网络要长，这是因为其权重数据更多。虽然 Inception 系列更复杂，但鉴于其优秀的性能和更胜一筹的准确率，我决定在移动设备上使用 Inception 而非 VGG。&lt;/p&gt;
&lt;p&gt;其实苹果爸爸已经帮我们用 Swift 和 Metal Performance Shaders 实现了个使用 Inception V3 网络预测图像类别的 Demo:&lt;a href=&quot;https://developer.apple.com/library/content/samplecode/MetalImageRecognition/Introduction/Intro.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MetalImageRecognition: Performing Image Recognition with Inception_v3 Network using Metal Performance Shaders Convolutional Neural Network routines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我决定使用 &lt;a href=&quot;https://arxiv.org/pdf/1512.00567v3.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Inception V3 Network&lt;/a&gt; 来 fine-tuning，这样在后续的 MPS 代码编写上就会省很多时间。TensorFlow 官方也有相应 &lt;a href=&quot;https://www.tensorflow.org/tutorials/image_recognition#image-recognition&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;教程&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;bottleneck-features&quot;&gt;&lt;a href=&quot;#bottleneck-features&quot; class=&quot;headerlink&quot; title=&quot;bottleneck features&quot;&gt;&lt;/a&gt;bottleneck features&lt;/h3&gt;&lt;p&gt;下图展示了 Inception V3 网络的结构，其中的 top 部分就是 Final part 所指的部分，我们可以将其替换成我们自己的全连接层，利用前面 Input 预测的结果来作为输入数据，训练我们自己的分类器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MachineLearning/Inception V3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上图中的 Inception mudules 使用的是&lt;a href=&quot;https://arxiv.org/pdf/1512.00567v3.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;论文&lt;/a&gt;中提到的图 6 的结构，实际代码中则使用的图 5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Keras 有很多使用 ImageNet 预训练的模型，我们这里只需要 Inception V3 去掉 Final part 的剩余部分，一行代码搞定：&lt;/p&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;model&lt;/span&gt; = applications.InceptionV3(include_top=&lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;, weights=&lt;span class=&quot;string&quot;&gt;&#39;imagenet&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 TensorFlow 中读取文件数据需要通过 &lt;code&gt;QueueRunner&lt;/code&gt; 和 &lt;code&gt;Coordinator&lt;/code&gt; 构造队列来实现 data flow，比较麻烦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MachineLearning/AnimatedFileQueues.gif&quot; alt=&quot;图片来源 TensorFlow&quot;&gt;&lt;/p&gt;
&lt;p&gt;Keras 真是太方便了，用生成器把图片数据标准化，使用加载好的 &lt;code&gt;model&lt;/code&gt; 预测出结果，并保存到 npy 文件中。&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;datagen&lt;/span&gt; = ImageDataGenerator(&lt;span class=&quot;attr&quot;&gt;rescale=1.&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;generator&lt;/span&gt; = datagen.flow_from_directory(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   train_data_dir,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attr&quot;&gt;target_size=(img_width,&lt;/span&gt; img_height),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attr&quot;&gt;batch_size=batch_size,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attr&quot;&gt;class_mode=None,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;attr&quot;&gt;shuffle=False)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;bottleneck_features_train&lt;/span&gt; = model.predict_generator(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   generator, nb_train_samples // batch_size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;np.save(open(&#39;bottleneck_features_train.npy&#39;, &#39;w&#39;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       bottleneck_features_train)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里保存的结果并不是 one-hot 格式的分类结果，只是作为 Final part 的输入，所以叫做 bottleneck features。&lt;/p&gt;
&lt;p&gt;下一步就是构建自己的 Final part，比如我们这里想要做个五分类的模型：&lt;/p&gt;
&lt;figure class=&quot;highlight gams&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt; = Sequential()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Flatten(input_shape=train_data.shape[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dense(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;, activation=&lt;span class=&quot;string&quot;&gt;&#39;relu&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dropout(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dense(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, activation=&lt;span class=&quot;string&quot;&gt;&#39;softmax&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Flatten&lt;/code&gt; 和 &lt;code&gt;Dropout&lt;/code&gt; 层并不会改变数据，是没有权重的层。所以这里有两个全连接层，最后一层有五个节点，输出一个长度为 5 的 one-hot 格式向量。&lt;/p&gt;
&lt;p&gt;这里之所以使用 bottleneck features 作为输入数据来进行训练，是为了节省运算资源。如果采用冻结前面部分网络的方式，虽然被冻结的网络权重不会变，但每跑一次的运算量都很大，而且结果是相同的。所以采取预测一次 bottleneck features，离线保存的方式。在机器学习中减少 loss 提升准确率常用的方法就是梯度下降法，实际应用中使用 mini-batch 梯度下降法来平衡计算性能和 loss 收敛效果。这里的 batch_size 就是每次下降所使用数据批次的数量。&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;model.compile(&lt;span class=&quot;attr&quot;&gt;optimizer=optimizers.SGD(lr=1e-4,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;momentum=0.9),&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;attr&quot;&gt;loss=&#39;categorical_crossentropy&#39;,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;metrics=[&#39;accuracy&#39;])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.fit(train_data, train_labels,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attr&quot;&gt;epochs=epochs,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attr&quot;&gt;batch_size=batch_size,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attr&quot;&gt;validation_data=(validation_data,&lt;/span&gt; validation_labels))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.save_weights(top_model_weights_path)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里训练的是我们自己添加的两个全连接层，以便于拟合我们自己的数据。&lt;/p&gt;
&lt;p&gt;这部分的源码放在 &lt;a href=&quot;https://github.com/yulingtianxia/HandGestureCNN/blob/master/Train/bottleneck_features_train_inceptionv3.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bottleneck_features_train_inceptionv3.py&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Fine-tuning&quot;&gt;&lt;a href=&quot;#Fine-tuning&quot; class=&quot;headerlink&quot; title=&quot;Fine-tuning&quot;&gt;&lt;/a&gt;Fine-tuning&lt;/h3&gt;&lt;p&gt;为了达到更好的效果，可以解冻后面几层。看了下 Inception V3 的网络结构，最后一个 tower 拥有 9 个卷积层，比较复杂。虽然理论上 fine-tuneing 整个 tower 是可行的，但是计算开销很大，用我的 iMac 4 GHz Intel Core i7 八核跑一个月都不行。&lt;/p&gt;
&lt;p&gt;现在需要加载预训练网络的权重到 &lt;code&gt;base_model&lt;/code&gt; 中，并将其与 &lt;code&gt;top_model&lt;/code&gt; 拼在一起。Keras 中有两种描述模型，一种是 &lt;code&gt;Sequential&lt;/code&gt;，另一种是带有函数式 API 的 &lt;code&gt;Model&lt;/code&gt;。前者层与层之前连接的入度和出度都为 1，后者就很灵活很随意了。这里构建 &lt;code&gt;top_model&lt;/code&gt; 使用的 &lt;code&gt;Sequential&lt;/code&gt;，然后使用 &lt;code&gt;Model&lt;/code&gt; 统一输入和输出，起到连接的作用。最后通过设置 &lt;code&gt;trainable&lt;/code&gt; 属性来冻结部分网络。为了让准确率更高，会将上一步 bottleneck features 训练好的权重作为 &lt;code&gt;top_model&lt;/code&gt; 的初始权重。&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# build the InceptionV3 network&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;input_tensor&lt;/span&gt; = Input(&lt;span class=&quot;attr&quot;&gt;shape=(img_height,&lt;/span&gt; img_width, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;base_model&lt;/span&gt; = applications.InceptionV3(&lt;span class=&quot;attr&quot;&gt;weights=&#39;imagenet&#39;,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;include_top=False,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;input_tensor=input_tensor)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&#39;Model loaded.&#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# build a classifier model to put on top of the convolutional model&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;top_model&lt;/span&gt; = Sequential()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.add(Flatten(&lt;span class=&quot;attr&quot;&gt;input_shape=base_model.output_shape[1:]))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.add(Dense(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;activation=&#39;relu&#39;))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.add(Dropout(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.add(Dense(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;activation=&#39;softmax&#39;))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# note that it is necessary to start with a fully-trained&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# classifier, including the top classifier,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# in order to successfully do fine-tuning&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top_model.load_weights(top_model_weights_path)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# add the model on top of the convolutional base&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;model&lt;/span&gt; = Model(&lt;span class=&quot;attr&quot;&gt;inputs=base_model.input,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;outputs=top_model(base_model.output))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# set the first xx layers (up to the last conv block)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# to non-trainable (weights will not be updated)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for layer &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; model.layers[:len(base_model.layers)-&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer.&lt;span class=&quot;attr&quot;&gt;trainable&lt;/span&gt; = False&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有关 Keras 两种模型的概念可以查看 &lt;a href=&quot;https://keras.io/models/about-keras-models/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;About Keras models&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;可以通过设置数据生成器的一些参数来提升数据的随机性，降低过拟合。&lt;code&gt;ImageDataGenerator&lt;/code&gt; 针对图片有很多预设的处理方式，例如平移，旋转，缩放，反转等。TensorFlow 中也有类似的图片预处理功能，但 API 使用上没 Keras 便利。有关图片预处理的内容可以参考文档 &lt;a href=&quot;https://keras.io/preprocessing/image/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Image Preprocessing&lt;/a&gt;，这里仅针对某些方式进行随意预处理，提升数据：&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;train_datagen&lt;/span&gt; = ImageDataGenerator(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attr&quot;&gt;rescale=1./255,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;rotation_range=40,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;width_shift_range=0.2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;height_shift_range=0.2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;shear_range=0.2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;zoom_range=0.2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;horizontal_flip=True,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;attr&quot;&gt;fill_mode=&#39;nearest&#39;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Keras 可以根据数据的文件夹自动分类打标签，所以我将图片按文件夹归类就可以了，很方便。&lt;/p&gt;
&lt;p&gt;我一共使用了 1808 张图片作为训练集，192 张图片作为交叉验证集。经过了 50 个 epoch 后，训练集准确率 96.26%，交叉验证集准确率 73.86%。&lt;/p&gt;
&lt;p&gt;这部分源码放在 &lt;a href=&quot;https://github.com/yulingtianxia/HandGestureCNN/blob/master/Train/finetune_inceptionv3.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;finetune_inceptionv3.py&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Convert-HDF5-to-binary-dat-files&quot;&gt;&lt;a href=&quot;#Convert-HDF5-to-binary-dat-files&quot; class=&quot;headerlink&quot; title=&quot;Convert HDF5 to binary .dat files&quot;&gt;&lt;/a&gt;Convert HDF5 to binary .dat files&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HDF（英语：Hierarchical Data Format）指一种为存储和处理大容量科学数据设计的文件格式及相应库文件。HDF最早由NCSA开发，目前在非盈利组织 HDF 小组维护下继续发展。当前流行的版本是HDF5。&lt;br&gt;    – 维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hdfgroup.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF Group&lt;/a&gt; 提供了可视化查看 HDF 文件的工具：&lt;a href=&quot;https://support.hdfgroup.org/products/java/release/download.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDFView&lt;/a&gt;，因为是用 java 写的，所以是跨平台的。Mac 版本有个已知的 bug：双击一个 &lt;code&gt;.h5&lt;/code&gt; 文件后 HDFView 界面是空的，需要把 &lt;code&gt;.h5&lt;/code&gt; 文件拖动到 HDFView 左边栏才能打开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MachineLearning/HDFView.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Keras 可以将训练处的权重结果高存成 HDF5 格式，但苹果提供的 Demo 使用的权重文件是 memory-mapped 二进制文件，每层网络都对应一个 &lt;code&gt;.dat&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.hdfgroup.org/products/hdf5_tools/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SOFTWARE USING HDF5&lt;/a&gt; 列举了很多用于操作 HDF 文件和格式转换的工具。可以用一些工具将存有权重的 HDF 文件先转化成若干 &lt;code&gt;.dat&lt;/code&gt; 文件，然后再打包到 iOS App 中。还有一种做法是将 HDF 文件打包到 iOS App 中，然后在客户端完成格式导出。&lt;a href=&quot;https://github.com/aleph7/HDF5Kit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF5Kit&lt;/a&gt; 是对 &lt;a href=&quot;https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-1.10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF 源码&lt;/a&gt;的 Swift 封装，不过还有些 crash。我采用了第二种做法，因为我懒，替换权重文件的时候只需要一个 HDF 文件，不用替换一堆 &lt;code&gt;.dat&lt;/code&gt; 文件🙄。实际应用中千万别这么干。&lt;/p&gt;
&lt;p&gt;可以根据上图中 HDFView 展示的树状层级递归遍历 Group，并拼接好正确的名称。比如 “bias:0” 和 “kernel:0”。将 HDF5 转换成二进制文件的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Read parameters from HDF5 file and store to dat file in Tmp directory&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;extractHDF5&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(h5Name: String)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// MARK: Parse HDF5 file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; path = &lt;span class=&quot;type&quot;&gt;Bundle&lt;/span&gt;.main.path(forResource: h5Name, ofType: &lt;span class=&quot;string&quot;&gt;&quot;h5&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to get a path&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; file = &lt;span class=&quot;type&quot;&gt;File&lt;/span&gt;.open(path, mode: .readOnly) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open file at &lt;span class=&quot;subst&quot;&gt;\(path)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; layerNamesStringAttribute = file.openStringAttribute(&lt;span class=&quot;string&quot;&gt;&quot;layer_names&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open attribute &#39;layer_names&#39;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; layerNames = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;? layerNamesStringAttribute.read() &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to get layer names&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// count used for file name later&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; countOfConvLayer = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; countOfFcLayer   = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; partOfFileName = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; layerName &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; layerNames &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; layerGroup = file.openGroup(layerName) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open group of &lt;span class=&quot;subst&quot;&gt;\(layerName)&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; objectName &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; layerGroup.objectNames() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// only the layer that has parameters remain&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; wtDataset = layerGroup.openFloatDataset(objectName + &lt;span class=&quot;string&quot;&gt;&quot;/kernel:0&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open data set of &lt;span class=&quot;subst&quot;&gt;\(objectName)&lt;/span&gt;/kernel:0&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bsDataset = layerGroup.openFloatDataset(objectName + &lt;span class=&quot;string&quot;&gt;&quot;/bias:0&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to open data set of &lt;span class=&quot;subst&quot;&gt;\(objectName)&lt;/span&gt;/bias:0&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dimension = wtDataset.space.dims&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; wtArray = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;? wtDataset.read() &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to read data set of &lt;span class=&quot;subst&quot;&gt;\(objectName)&lt;/span&gt;/kernel:0&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bsArray = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;? bsDataset.read() &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed to read data set of &lt;span class=&quot;subst&quot;&gt;\(objectName)&lt;/span&gt;/bias:0&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; wtLength = wtArray.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bsLength = bsArray.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; dimension.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// weights for convolution layer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wtArray = &lt;span class=&quot;type&quot;&gt;SwapAxes&lt;/span&gt;.for4dFlatArray(originalArray: wtArray, axis1: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, axis2: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, dimensionOfArray: &amp;amp;dimension)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wtArray = &lt;span class=&quot;type&quot;&gt;SwapAxes&lt;/span&gt;.for4dFlatArray(originalArray: wtArray, axis1: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, axis2: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, dimensionOfArray: &amp;amp;dimension)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wtArray = &lt;span class=&quot;type&quot;&gt;SwapAxes&lt;/span&gt;.for4dFlatArray(originalArray: wtArray, axis1: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, axis2: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, dimensionOfArray: &amp;amp;dimension)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                countOfConvLayer += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                partOfFileName = &lt;span class=&quot;string&quot;&gt;&quot;conv&quot;&lt;/span&gt; + &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(countOfConvLayer)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; dimension.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// weights for fully connected layer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wtArray = &lt;span class=&quot;type&quot;&gt;SwapAxes&lt;/span&gt;.for2dFlatArray(originalArray: wtArray, axis1: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, axis2: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, dimensionOfArray: &amp;amp;dimension)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                countOfFcLayer += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                partOfFileName = &lt;span class=&quot;string&quot;&gt;&quot;fc&quot;&lt;/span&gt; + &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(countOfFcLayer)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;fatalError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Dataset&#39;s dimension is neither 4 (convolution layer) nor 2 (fully connected layer)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; wtData = &lt;span class=&quot;type&quot;&gt;NSData&lt;/span&gt;(bytes: &amp;amp;wtArray, length: wtLength * &lt;span class=&quot;type&quot;&gt;MemoryLayout&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Float&lt;/span&gt;&amp;gt;.size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bsData = &lt;span class=&quot;type&quot;&gt;NSData&lt;/span&gt;(bytes: &amp;amp;bsArray, length: bsLength * &lt;span class=&quot;type&quot;&gt;MemoryLayout&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Float&lt;/span&gt;&amp;gt;.size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 写入数据到文件...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Metal-Performance-Shaders&quot;&gt;&lt;a href=&quot;#Metal-Performance-Shaders&quot; class=&quot;headerlink&quot; title=&quot;Metal Performance Shaders&quot;&gt;&lt;/a&gt;Metal Performance Shaders&lt;/h2&gt;&lt;h3 id=&quot;MPS-简介&quot;&gt;&lt;a href=&quot;#MPS-简介&quot; class=&quot;headerlink&quot; title=&quot;MPS 简介&quot;&gt;&lt;/a&gt;MPS 简介&lt;/h3&gt;&lt;p&gt;Metal Performance Shaders 简称 MPS，可以为使用 Metal 技术的 App 提供底层高性能 GPU 运算接口。最初苹果提供的 Shader 语言本来是很底层很生涩的，后来为 iOS 提供了原生支持的 API，可以用 Swift 或 OC 来调用底层接口了。iOS 9 的 MPS 提供了图片特效处理和 Metal 纹理相关的 API，iOS 10 的 MPS 新增了有关 CNN 和矩阵乘法的 API。不过目前苹果只开放了 CNN 的预测功能，如果想要在 iOS 10 上训练一个 CNN，那就只能借助第三方工具了。&lt;/p&gt;
&lt;p&gt;苹果的 BNNS 同样提供了创建 CNN 的 API，而且也只能使用训练好的权重进行预测。但仅仅是对 CPU 进行了优化。因为 OpenGL 的限制，其性能与 Metal 相比并不占优势。OpenCL 在 iOS 上是私有框架。所以说目前看来，不考虑系统兼容性(iOS 10)和资源限制(arm64)，Metal 技术是发挥 GPU 运算优势的最好选择。&lt;/p&gt;
&lt;p&gt;MPS 系统原生支持不用担心安装包增量问题，并且使用 Metal 技术使用 GPU 加速运算，功耗发热少。MPS 目前的缺点是不支持网络的训练和必须 HardCode 网络结构，但面对复杂度较低的神经网络时还是很实用的。毕竟 TensorFlow 在 iOS 上只能用 CPU 计算，且编译费时费力，安装包增量巨大。&lt;/p&gt;
&lt;p&gt;MPS 在我的 iPhone 6s Plus 上性能很好，发热也少，可以通过神经网络实时预测出结果。这是 &lt;a href=&quot;https://github.com/shu223/iOS-10-Sampler&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS-10-Sampler&lt;/a&gt; 项目的效果，它是在苹果官方 Demo &lt;a href=&quot;https://developer.apple.com/library/content/samplecode/MetalImageRecognition/Introduction/Intro.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MetalImageRecognition&lt;/a&gt; 基础上稍微改进拍摄功能的用户体验，MPS 的部分未做任何改动。我基于它和 &lt;a href=&quot;https://github.com/kazoo-kmt/MPSCNNfeeder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MPSCNNfeeder&lt;/a&gt; 实现了 &lt;a href=&quot;https://github.com/yulingtianxia/HandGestureCNN/tree/master/HandGestureCNN&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HandGestureCNN&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/shu223/iOS-10-Sampler/blob/master/README_resources/imagerecog.gif?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;苹果给了一个 MPS 的 HelloWorld： &lt;a href=&quot;https://developer.apple.com/library/content/samplecode/MPSCNNHelloWorld/Introduction/Intro.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MPSCNNHelloWorld: Simple Digit Detection Convolution Neural Networks (CNN)&lt;/a&gt;，恰好对应着机器学习领域的 HelloWorld MNIST。可以通过查看这个 Demo 的源码来快速上手 MPS 的用法。&lt;/p&gt;
&lt;p&gt;其实总体来说并不是很复杂，但有几个重要的地方需要我们自己去解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据处理，也就是模型文件的数据格式需要自己去解析。不同深度学习框架导出的模型权重文件格式都不一样，会涉及到比较底层的位读写。这里有一定工作量。&lt;/li&gt;
&lt;li&gt;使用卷积神经网络预测模型的时候，会涉及到 padding，这部分需要自己计算。输出数据体在空间上的尺寸可以通过输入数据体尺寸（W），卷积层中神经元的感受野尺寸（F），步长（S）和零填充的数量（P）的函数来计算。输出数据体的空间尺寸为 (W-F +2P)/S+1。这里说的是某个维度，单指宽或长。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;MPSImage&lt;/code&gt; 是为了突破 &lt;code&gt;MTLTexture&lt;/code&gt; 最大维度为 4 （RGBA）的限制，搞了个 workaround，就是用多个切片模拟多维度。如果有 N 个维度，那么切片数量为 (N+3)/4。比如下图为 N = 9 的情况。所以涉及到数据对齐的事情，预测后的数据需要处理下。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://docs-assets.developer.apple.com/published/48ad0af3fd/b6d1d091-162c-418d-bc2e-0b6f3105c126.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好在苹果提供的 Demo 里已经对于后两个问题有了可以参考的代码，第一个问题其实是个矩阵转换的操作。 TensorFlow 卷积核权重的顺序为 [kH kW iC oC]，而 MPS 接受的权重为 [oC kH kW iC] 形式。而我使用 Keras 的时候将 TensorFlow 作为后端，所以需要转换下权重格式。矩阵转换在 python 里很容易，还好我找到了 Swift 版本的实现：&lt;a href=&quot;https://github.com/kazoo-kmt/MPSCNNfeeder/blob/master/swapaxes.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwapAxes&lt;/a&gt;，直接拿过来用了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: 科普下，[oC kH kW iC] 是四维数组（矩阵） [outputChannels][kernelHeight][kernelWidth][inputChannels/groups] 的 shape。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用-MPS-构建网络并预测&quot;&gt;&lt;a href=&quot;#使用-MPS-构建网络并预测&quot; class=&quot;headerlink&quot; title=&quot;使用 MPS 构建网络并预测&quot;&gt;&lt;/a&gt;使用 MPS 构建网络并预测&lt;/h3&gt;&lt;p&gt;MPS 预测的执行流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取可用的 device&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;device&lt;/code&gt; 获取 &lt;code&gt;commandQueue&lt;/code&gt;，从 &lt;code&gt;commandQueue&lt;/code&gt; 获取 &lt;code&gt;commandBuffer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构建网络模型和输入数据的 &lt;code&gt;MSPImage&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;调用网络每层的 &lt;code&gt;encode&lt;/code&gt; 方法，输入为 &lt;code&gt;commandBuffer&lt;/code&gt; 和上一层网络输出的 &lt;code&gt;MSPImage&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;提交 &lt;code&gt;commandBuffer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;等待输出结果，并处理成 one-hot 格式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;剩下的工作就是修改工程中的 &lt;code&gt;Inception3Net.swift&lt;/code&gt; 文件，使其网络结构与我们用 Keras 搭建的网络结构一样即可。前面提到过，&lt;code&gt;Flatten&lt;/code&gt; 和 &lt;code&gt;Dropout&lt;/code&gt; 没有权重，不改变数据。&lt;code&gt;Flatten&lt;/code&gt; 其实就是 &lt;code&gt;reshape&lt;/code&gt; 操作，在 MPS 中不需要特意做 &lt;code&gt;reshape&lt;/code&gt; 操作也没有 &lt;code&gt;Flatten&lt;/code&gt; 层，&lt;code&gt;MPSImage&lt;/code&gt; 被描述成什么 shape，数据就会被排列成那个 shape。&lt;code&gt;Dropout&lt;/code&gt; 层在训练的时候按一定几率丢弃结果，在预测模型的时候根本用不到。&lt;/p&gt;
&lt;p&gt;回顾下之前用 Keras 写的全连接层结构的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight gams&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt; = Sequential()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Flatten(input_shape=train_data.shape[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dense(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;, activation=&lt;span class=&quot;string&quot;&gt;&#39;relu&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dropout(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;model&lt;/span&gt;.add(Dense(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, activation=&lt;span class=&quot;string&quot;&gt;&#39;softmax&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;转换成 MPS 的代码后差不多是这个样子（省略无关代码）：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let device = inputCommandQueue.device&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let relu = MPSCNNNeuronReLU(&lt;span class=&quot;string&quot;&gt;device:&lt;/span&gt; device!, &lt;span class=&quot;string&quot;&gt;a:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let softmax = MPSCNNSoftMax(&lt;span class=&quot;string&quot;&gt;device:&lt;/span&gt; device!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let sftid = MPSImageDescriptor(&lt;span class=&quot;string&quot;&gt;channelFormat:&lt;/span&gt; textureFormat, &lt;span class=&quot;string&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;  , &lt;span class=&quot;string&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;  , &lt;span class=&quot;string&quot;&gt;featureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// logits&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let fc0 = SlimMPSCNNFullyConnected(&lt;span class=&quot;string&quot;&gt;kernelWidth:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             kernelHeight:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             inputFeatureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2048&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             outputFeatureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             neuronFilter:&lt;/span&gt; relu,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             device:&lt;/span&gt; device,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             kernelParamsBinaryName:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fc1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let fc1 = SlimMPSCNNFullyConnected(&lt;span class=&quot;string&quot;&gt;kernelWidth:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             kernelHeight:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             inputFeatureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             outputFeatureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             neuronFilter:&lt;/span&gt; nil,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             device:&lt;/span&gt; device,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;                             kernelParamsBinaryName:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fc2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let image10 = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let sftImage    = MPSImage(&lt;span class=&quot;string&quot;&gt;device:&lt;/span&gt; device!, &lt;span class=&quot;string&quot;&gt;imageDescriptor:&lt;/span&gt; sftid)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// MPSImageDescriptor for final logits generating layers&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let fc0id = MPSImageDescriptor(&lt;span class=&quot;string&quot;&gt;channelFormat:&lt;/span&gt; textureFormat, &lt;span class=&quot;string&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;featureChannels:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var fc0Image, &lt;span class=&quot;string&quot;&gt;fc1Image :&lt;/span&gt; MPSTemporaryImage!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func logits_layer(&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; MTLCommandBuffer)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// These images are only needed in this layer and will not be read by the CPU or&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// outside of the command bufer, so we can allocate them as MPSTemporaryImages and&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// save the CPU cost and memory size of allocating reserved storage for them.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// These objects can not be reused outside of the command buffer, which is why&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// we did not make them in the init(withDevice:commandQueue:) call.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Temporary images are designed to be efficiently created as needed, used a few times&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// and thrown away almost immediately&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fc0Image     = MPSTemporaryImage(&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;imageDescriptor:&lt;/span&gt; fc0id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fc1Image     = MPSTemporaryImage(&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;imageDescriptor:&lt;/span&gt; sftid)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// encode layers to metal commandBuffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fc0.encode    (&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;sourceImage:&lt;/span&gt; image10, &lt;span class=&quot;string&quot;&gt;destinationImage:&lt;/span&gt; fc0Image)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fc1.encode    (&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;sourceImage:&lt;/span&gt; fc0Image, &lt;span class=&quot;string&quot;&gt;destinationImage:&lt;/span&gt; fc1Image)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   softmax.encode(&lt;span class=&quot;string&quot;&gt;commandBuffer:&lt;/span&gt; commandBuffer, &lt;span class=&quot;string&quot;&gt;sourceImage:&lt;/span&gt; fc1Image, &lt;span class=&quot;string&quot;&gt;destinationImage:&lt;/span&gt; sftImage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;这是一篇行外人看不懂，行内人觉得水，我自己觉得收获满满的实践笔记。并没有花大量篇幅总结Machine Learning 的基础知识，也没有逐个讲述框架 API 的使用，更没有列一堆公式和数学定义。。。因为这种知识体系大而全的文章，网上不胜枚举，而且肯定比我总结的好。本着一个小白去探索世界的心态，把自己从理论学习到训练模型再到 iOS 上的预测的实践流程记录下来。很多枯燥耗时的学习 ML、TF 和配置环境的过程都省略掉了。&lt;/p&gt;
&lt;p&gt;最后建议如果有条件的话，还是用配置较高的集群或者云服务来训练模型，节省程序员宝贵的时间。如果不能做到自己提出创新有效的网络模型，其实深度学习的大量工作就是调参、采集数据、看别人论文如何改参数和网络结构，然后等待机器训练结果。。。反复循环。。。&lt;/p&gt;
&lt;p&gt;神经网络不是真的模拟出人脑的生物特征，CNN 跟人眼扫视世界或人脑辨别物体其实差很多，深度学习只是尽力让机器拟合出想要的结果罢了，离真正的人工智能还差远了。所以不要被铺天盖地的吹嘘洗脑了，一个 AlphaGo 就能又让一大堆所谓的科技媒体高潮出机器快要统治人类了，不要老想搞个大新闻！&lt;/p&gt;
&lt;p&gt;深度学习发展很快，要学习的内容还有很多。学习得越多，就发现自己越是无知，以至于怀疑自己的智商和精力了。&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/home&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Coursera Machine Learning&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.tensorflow.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TensorFlow&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://keras-cn.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras 中文文档&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://keras.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras Documentation&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://image-net.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageNet&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.kaggle.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kaggle&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://cs231n.stanford.edu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CS231n: Convolutional Neural Networks for Visual Recognition&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://cs231n.github.io/convolutional-networks/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Convolutional Neural Networks (CNNs / ConvNets)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://machinethink.net/blog/convolutional-neural-networks-on-the-iphone-with-vggnet/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Convolutional neural networks on the iPhone with VGGNet&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Building powerful image classification models using very little data&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.hdfgroup.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF Group&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/reference/metalperformanceshaders&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MetalPerformanceShaders&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/reference/accelerate/bnns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BNNS&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/aleph7/HDF5Kit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HDF5Kit&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/shu223/iOS-10-Sampler&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS-10-Sampler&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/kazoo-kmt/MPSCNNfeeder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MPSCNNfeeder&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近一个月从零开始自学了下有关 iOS 上的机器学习相关知识，亲身实践了从数据采集到训练模型再到移动端预测的流程。理论知识学习路径为：&lt;strong&gt;机器学习-&amp;gt;深度学习-&amp;gt;迁移学习&lt;/strong&gt;；实践框架学习路径为：&lt;strong&gt;TensorFlow-&amp;gt;Keras-&amp;gt;MPS(iOS 10)&lt;/strong&gt;。最终完成一个简单的手势图像五分类问题，并预测 iOS 摄像头采集的图片。最终结果，训练集准确率 96.26%，交叉验证集准确率 73.86%。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yulingtianxia.com/tags/iOS/"/>
    
      <category term="Machine Leaning" scheme="http://yulingtianxia.com/tags/Machine-Leaning/"/>
    
      <category term="Metal" scheme="http://yulingtianxia.com/tags/Metal/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Method Swizzling</title>
    <link href="http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/"/>
    <id>http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/</id>
    <published>2017-04-16T16:11:48.000Z</published>
    <updated>2017-04-16T16:15:35.000Z</updated>
    
    <content type="html">&lt;p&gt;Objective-C 中的 Hook 又被称作 Method Swizzling，这是动态语言大都具有的特性。在 Objective-C 中经常会把 Hook 的逻辑写在 &lt;code&gt;+ load&lt;/code&gt; 方法中，这是利用它调用时机较提前等性质。&lt;/p&gt;
&lt;p&gt;有时候需要 Hook 子类和父类的同一个方法，但是它们的 &lt;code&gt;+ load&lt;/code&gt; 方法调用顺序不同。一个常见的顺序可能是：父类-&amp;gt;子类-&amp;gt;子类类别-&amp;gt;父类类别。所以 Hook 的顺序并不能保证，就不能保证 Hook 后方法调用的顺序是对的。而且使用不同方法 Method Swizzling 也会带来不同的结果。本文将会对这些情况下的 Hook 结果进行分析和总结。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Method-Swizzling-常用实现方案&quot;&gt;&lt;a href=&quot;#Method-Swizzling-常用实现方案&quot; class=&quot;headerlink&quot; title=&quot;Method Swizzling 常用实现方案&quot;&gt;&lt;/a&gt;Method Swizzling 常用实现方案&lt;/h2&gt;&lt;p&gt;目前有两类常用的 Method Swizzling 实现方案，诸如 &lt;a href=&quot;https://github.com/rabovik/RSSwizzle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RSSwizzle&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/rentzsch/jrswizzle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jrswizzle&lt;/a&gt; 这种较为复杂且周全的一些实现方案这里暂且不提。&lt;/p&gt;
&lt;h3 id=&quot;方案-A&quot;&gt;&lt;a href=&quot;#方案-A&quot; class=&quot;headerlink&quot; title=&quot;方案 A&quot;&gt;&lt;/a&gt;方案 A&lt;/h3&gt;&lt;p&gt;如果类中没有实现 Original &lt;code&gt;selector&lt;/code&gt; 对应的方法，那就先添加 &lt;code&gt;Method&lt;/code&gt;，并将其 &lt;code&gt;IMP&lt;/code&gt; 映射为 Swizzle 的实现。然后替换 Swizzle &lt;code&gt;selector&lt;/code&gt; 的 &lt;code&gt;IMP&lt;/code&gt; 为 Original 的实现；否则交换二者 &lt;code&gt;IMP&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (void)load&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static &lt;span class=&quot;keyword&quot;&gt;dispatch_once_t &lt;/span&gt;onceToken&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;dispatch_once(&amp;amp;onceToken, &lt;/span&gt;^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class aClass = [self class]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SEL &lt;span class=&quot;keyword&quot;&gt;originalSelector &lt;/span&gt;= @selector(method_original:)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SEL &lt;span class=&quot;keyword&quot;&gt;swizzledSelector &lt;/span&gt;= @selector(method_swizzle:)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Method &lt;span class=&quot;keyword&quot;&gt;originalMethod &lt;/span&gt;= class_getInstanceMethod(aClass, &lt;span class=&quot;keyword&quot;&gt;originalSelector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        Method &lt;span class=&quot;keyword&quot;&gt;swizzledMethod &lt;/span&gt;= class_getInstanceMethod(aClass, &lt;span class=&quot;keyword&quot;&gt;swizzledSelector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;keyword&quot;&gt;BOOL &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;didAddMethod &lt;/span&gt;=&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        class_addMethod(aClass,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;originalSelector,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;                        method_getImplementation(&lt;span class=&quot;keyword&quot;&gt;swizzledMethod),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;                        method_getTypeEncoding(&lt;span class=&quot;keyword&quot;&gt;swizzledMethod));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (&lt;span class=&quot;keyword&quot;&gt;didAddMethod) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            class_replaceMethod(aClass,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                               &lt;span class=&quot;keyword&quot;&gt;swizzledSelector,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;                                               method_getImplementation(&lt;span class=&quot;keyword&quot;&gt;originalMethod),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;                                               method_getTypeEncoding(&lt;span class=&quot;keyword&quot;&gt;originalMethod));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            method_exchangeImplementations(&lt;span class=&quot;keyword&quot;&gt;originalMethod, &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;swizzledMethod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时为了避免方法命名冲突和参数 &lt;code&gt;_cmd&lt;/code&gt; 被篡改，也会使用下面这种『静态方法版本』的 Method Swizzle。CaptainHook 中的宏定义也是采用这种方式，比较推荐：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; IMP *I&lt;span class=&quot;built_in&quot;&gt;MPPointer&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; MethodSwizzle(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, SEL _cmd, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; arg1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*MethodOriginal)(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, SEL _cmd, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; arg1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; MethodSwizzle(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, SEL _cmd, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; arg1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// do custom work&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MethodOriginal(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, _cmd, arg1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, I&lt;span class=&quot;built_in&quot;&gt;MPPointer&lt;/span&gt; store) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IMP imp = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method method = class_getInstanceMethod(class, original);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (method) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *type = method_getTypeEncoding(method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        imp = class_replaceMethod(class, original, replacement, type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!imp) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            imp = method_getImplementation(method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (imp &amp;amp;&amp;amp; store) &amp;#123; *store = imp; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (imp != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)swizzle:(SEL)original with:(IMP)replacement store:(I&lt;span class=&quot;built_in&quot;&gt;MPPointer&lt;/span&gt;)store &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; class_swizzleMethodAndStore(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, original, replacement, store);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)load &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; swizzle:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(originalMethod:) with:(IMP)MethodSwizzle store:(IMP *)&amp;amp;MethodOriginal];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而上面的代码依然不是 Method Swizzling 的最佳实现。&lt;/p&gt;
&lt;h3 id=&quot;方案-B&quot;&gt;&lt;a href=&quot;#方案-B&quot; class=&quot;headerlink&quot; title=&quot;方案 B&quot;&gt;&lt;/a&gt;方案 B&lt;/h3&gt;&lt;p&gt;其实就是方案 A 的阉割版：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (void)load&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static &lt;span class=&quot;keyword&quot;&gt;dispatch_once_t &lt;/span&gt;onceToken&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;dispatch_once(&amp;amp;onceToken, &lt;/span&gt;^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class aClass = [self class]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SEL &lt;span class=&quot;keyword&quot;&gt;originalSelector &lt;/span&gt;= @selector(method_original:)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SEL &lt;span class=&quot;keyword&quot;&gt;swizzledSelector &lt;/span&gt;= @selector(method_swizzle:)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Method &lt;span class=&quot;keyword&quot;&gt;originalMethod &lt;/span&gt;= class_getInstanceMethod(aClass, &lt;span class=&quot;keyword&quot;&gt;originalSelector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        Method &lt;span class=&quot;keyword&quot;&gt;swizzledMethod &lt;/span&gt;= class_getInstanceMethod(aClass, &lt;span class=&quot;keyword&quot;&gt;swizzledSelector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;       method_exchangeImplementations(&lt;span class=&quot;keyword&quot;&gt;originalMethod, &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;swizzledMethod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;直接交换 &lt;code&gt;IMP&lt;/code&gt; 是很危险的。因为如果这个类中没有实现这个方法，&lt;code&gt;class_getInstanceMethod()&lt;/code&gt; 返回的是某个父类的 &lt;code&gt;Method&lt;/code&gt; 对象，这样 &lt;code&gt;method_exchangeImplementations()&lt;/code&gt; 就把父类的原始实现（&lt;code&gt;IMP&lt;/code&gt;）跟这个类的 Swizzle 实现交换了。这样其他父类及其其他子类的方法调用就会出问题，最严重的就是 Crash。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但如果这个类中实现了此方法，那么方案 A 等价于方案 B&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;研究背景&quot;&gt;&lt;a href=&quot;#研究背景&quot; class=&quot;headerlink&quot; title=&quot;研究背景&quot;&gt;&lt;/a&gt;研究背景&lt;/h2&gt;&lt;p&gt;这里对本文的研究背景进行一些假设和约定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有三个类，Child 类继承 Super 类，Super 类继承 Base 类。&lt;/li&gt;
&lt;li&gt;我们 Hook 了 Child 和 Super 的某个方法（而且是同一个方法）。&lt;/li&gt;
&lt;li&gt;为了方便表示，Child 的原始方法被称作 &lt;code&gt;Child_Original&lt;/code&gt;，Hook 后的方法被称作 &lt;code&gt;Child_Swizzle&lt;/code&gt;。Super 以此类推。&lt;/li&gt;
&lt;li&gt;为了让 Swizzle 的实现调用 Original 实现，&lt;code&gt;Child_Swizzle&lt;/code&gt; 的  IMP 中会调用 &lt;code&gt;Child_Swizzle&lt;/code&gt; 的 &lt;code&gt;selector&lt;/code&gt;。Super 以此类推。&lt;/li&gt;
&lt;li&gt;我们期望执行 Child 对象的 &lt;code&gt;Child_Original&lt;/code&gt; 方法时的 IMP 执行顺序是：&lt;code&gt;Child_Swizzle&lt;/code&gt;-&amp;gt;&lt;code&gt;Child_Original&lt;/code&gt;-&amp;gt;&lt;code&gt;Super_Swizzle&lt;/code&gt;-&amp;gt;&lt;code&gt;Super_Original&lt;/code&gt;-&amp;gt;&lt;code&gt;Base&lt;/code&gt;。我们只需关注其中 Swizzle 的部分，所以约定简写为：Child-&amp;gt;Super-&amp;gt;Base。&lt;/li&gt;
&lt;li&gt;本文会按 Hook 顺序、类是否实现方法、Hook 方案(A/B) 来细分不同情况下的结果。一共细分为 18 种情况。&lt;/li&gt;
&lt;li&gt;本文会使用图例表示每种情况下的方法调用和映射关系，分为三个维度（Super/Child;Original/Swizzle;&lt;code&gt;Selector&lt;/code&gt;/&lt;code&gt;Method&lt;/code&gt;/&lt;code&gt;IMP&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/模板.png&quot; alt=&quot;模板&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下文中的图例均为 Hook 后的结果(Hook 前的太简单了懒得画)。如果不理解 &lt;code&gt;Selector&lt;/code&gt;,&lt;code&gt;Method&lt;/code&gt; 与 &lt;code&gt;IMP&lt;/code&gt; 三者的关系，甚至不理解 Method Swizzling 原理，请先阅读 &lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot;&gt;Objective-C Runtime&lt;/a&gt;！如果还是看不懂，那就再看一遍吧！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Hook-顺序：先-Child-后-Super&quot;&gt;&lt;a href=&quot;#Hook-顺序：先-Child-后-Super&quot; class=&quot;headerlink&quot; title=&quot;Hook 顺序：先 Child 后 Super&quot;&gt;&lt;/a&gt;Hook 顺序：先 Child 后 Super&lt;/h2&gt;&lt;p&gt;这个顺序本身就不被大众认可却又不得不广泛被使用，因为很多想 Hook 系统 API 只能从 Category 下手。当子类同样的方法也被 Hook 后，奇怪的事情便发生了。&lt;/p&gt;
&lt;h3 id=&quot;Super-未实现方法-Child-未实现方法&quot;&gt;&lt;a href=&quot;#Super-未实现方法-Child-未实现方法&quot; class=&quot;headerlink&quot; title=&quot;Super 未实现方法,Child 未实现方法&quot;&gt;&lt;/a&gt;Super 未实现方法,Child 未实现方法&lt;/h3&gt;&lt;h4 id=&quot;Super-Plan-A-Child-Plan-A&quot;&gt;&lt;a href=&quot;#Super-Plan-A-Child-Plan-A&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan A,Child:Plan A&quot;&gt;&lt;/a&gt;Super:Plan A,Child:Plan A&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/CS_SuperAChildA.png&quot; alt=&quot;CS_SuperAChildA&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象：Child-&amp;gt;Base (Super 被忽略)&lt;/li&gt;
&lt;li&gt;Super 和 Base 对象均正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Super-Plan-B-Child-Plan-A&quot;&gt;&lt;a href=&quot;#Super-Plan-B-Child-Plan-A&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan B,Child:Plan A&quot;&gt;&lt;/a&gt;Super:Plan B,Child:Plan A&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/CS_SuperBChildA.png&quot; alt=&quot;CS_SuperBChildA&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象：Child-&amp;gt;Base (Super 被忽略)&lt;/li&gt;
&lt;li&gt;Super 对象正常&lt;/li&gt;
&lt;li&gt;Base 对象产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常，此情况亦等同于：在子类类别中 Hook 了子类未实现而父类实现了的方法。（Super 是 Base 的子类）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Super-Plan-A-Child-Plan-B&quot;&gt;&lt;a href=&quot;#Super-Plan-A-Child-Plan-B&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan A,Child Plan B&quot;&gt;&lt;/a&gt;Super:Plan A,Child Plan B&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/CS_SuperAChildB.png&quot; alt=&quot;CS_SuperAChildB&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象：Child-&amp;gt;Base (Super 被忽略)&lt;/li&gt;
&lt;li&gt;Super 对象：如果 Super_Swizzle 与 Child_Swizzle 的 &lt;code&gt;selector&lt;/code&gt; 不同，则会产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常；如果两个 &lt;code&gt;selector&lt;/code&gt; 相同则会一直调用 Child_Swizzle 进入死循环&lt;/li&gt;
&lt;li&gt;Base 对象产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常，此情况亦间接等同于：在子类类别中 Hook 了子类未实现而父类实现了的方法。（Super 是 Base 的子类）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Super-Plan-B-Child-Plan-B&quot;&gt;&lt;a href=&quot;#Super-Plan-B-Child-Plan-B&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan B,Child Plan B&quot;&gt;&lt;/a&gt;Super:Plan B,Child Plan B&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/CS_SuperBChildB.png&quot; alt=&quot;CS_SuperBChildB&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象：Super-&amp;gt;Child-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 对象：如果 Super_Swizzle 与 Child_Swizzle 的 &lt;code&gt;selector&lt;/code&gt; 不同，则会产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常；如果两个 &lt;code&gt;selector&lt;/code&gt; 相同则会一直调用 Child_Swizzle 进入死循环&lt;/li&gt;
&lt;li&gt;Base 对象产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Super-实现方法-Child-未实现方法&quot;&gt;&lt;a href=&quot;#Super-实现方法-Child-未实现方法&quot; class=&quot;headerlink&quot; title=&quot;Super 实现方法,Child 未实现方法&quot;&gt;&lt;/a&gt;Super 实现方法,Child 未实现方法&lt;/h3&gt;&lt;p&gt;由于 Super 类被 Hook 的方法已经被实现，所以只需区分 Child 的 Hook 方案。&lt;/p&gt;
&lt;h4 id=&quot;Child-Plan-A&quot;&gt;&lt;a href=&quot;#Child-Plan-A&quot; class=&quot;headerlink&quot; title=&quot;Child:Plan A&quot;&gt;&lt;/a&gt;Child:Plan A&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/CS_ChildA.png&quot; alt=&quot;CS_ChildA&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象：Child-&amp;gt;Base (Super 被忽略)&lt;/li&gt;
&lt;li&gt;Super 和 Base 对象均正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Child-Plan-B&quot;&gt;&lt;a href=&quot;#Child-Plan-B&quot; class=&quot;headerlink&quot; title=&quot;Child:Plan B&quot;&gt;&lt;/a&gt;Child:Plan B&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/CS_ChildB.png&quot; alt=&quot;CS_ChildB&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象：Super-&amp;gt;Child-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 对象：如果 Super_Swizzle 与 Child_Swizzle 的 &lt;code&gt;selector&lt;/code&gt; 不同，则会产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常；如果两个 &lt;code&gt;selector&lt;/code&gt; 相同则会一直调用 Child_Swizzle 进入死循环&lt;/li&gt;
&lt;li&gt;Base 对象正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Super-未实现方法-Child-实现方法&quot;&gt;&lt;a href=&quot;#Super-未实现方法-Child-实现方法&quot; class=&quot;headerlink&quot; title=&quot;Super 未实现方法,Child 实现方法&quot;&gt;&lt;/a&gt;Super 未实现方法,Child 实现方法&lt;/h3&gt;&lt;p&gt;由于 Child 类被 Hook 的方法已经被实现，所以只需区分 Super 的 Hook 方案。&lt;/p&gt;
&lt;h4 id=&quot;Super-Plan-A&quot;&gt;&lt;a href=&quot;#Super-Plan-A&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan A&quot;&gt;&lt;/a&gt;Super:Plan A&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/CS_SuperA.png&quot; alt=&quot;CS_SuperA&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果（一切正常）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 和 Base 对象均正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Super-Plan-B&quot;&gt;&lt;a href=&quot;#Super-Plan-B&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan B&quot;&gt;&lt;/a&gt;Super:Plan B&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/CS_SuperB.png&quot; alt=&quot;CS_SuperB&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 对象正常：Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Base 对象产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常，此情况亦等同于：在子类类别中 Hook 了子类未实现而父类实现了的方法。（Super 是 Base 的子类）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Super-实现方法-Child-实现方法&quot;&gt;&lt;a href=&quot;#Super-实现方法-Child-实现方法&quot; class=&quot;headerlink&quot; title=&quot;Super 实现方法,Child 实现方法&quot;&gt;&lt;/a&gt;Super 实现方法,Child 实现方法&lt;/h3&gt;&lt;p&gt;相当于 Super 和 Child 都使用方案 B 进行 Hook，所以只有一种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/CS_Perfect.png&quot; alt=&quot;CS_Perfect&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果（一切正常）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 和 Base 对象均正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Hook-顺序：先-Super-后-Child&quot;&gt;&lt;a href=&quot;#Hook-顺序：先-Super-后-Child&quot; class=&quot;headerlink&quot; title=&quot;Hook 顺序：先 Super 后 Child&quot;&gt;&lt;/a&gt;Hook 顺序：先 Super 后 Child&lt;/h2&gt;&lt;p&gt;并不是 Hook 顺序对了就能保平安，姿势也同样重要。&lt;/p&gt;
&lt;h3 id=&quot;Super-未实现方法-Child-未实现方法-1&quot;&gt;&lt;a href=&quot;#Super-未实现方法-Child-未实现方法-1&quot; class=&quot;headerlink&quot; title=&quot;Super 未实现方法,Child 未实现方法&quot;&gt;&lt;/a&gt;Super 未实现方法,Child 未实现方法&lt;/h3&gt;&lt;h4 id=&quot;Super-Plan-A-Child-Plan-A-1&quot;&gt;&lt;a href=&quot;#Super-Plan-A-Child-Plan-A-1&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan A,Child:Plan A&quot;&gt;&lt;/a&gt;Super:Plan A,Child:Plan A&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/SC_SuperAChildA.png&quot; alt=&quot;SC_SuperAChildA&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果（一切正常）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 和 Base 对象均正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Super-Plan-B-Child-Plan-A-1&quot;&gt;&lt;a href=&quot;#Super-Plan-B-Child-Plan-A-1&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan B,Child:Plan A&quot;&gt;&lt;/a&gt;Super:Plan B,Child:Plan A&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/SC_SuperBChildA.png&quot; alt=&quot;SC_SuperBChildA&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 对象正常：Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Base 对象产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常，此情况亦等同于：在子类类别中 Hook 了子类未实现而父类实现了的方法。（Super 是 Base 的子类）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Super-Plan-A-Child-Plan-B-1&quot;&gt;&lt;a href=&quot;#Super-Plan-A-Child-Plan-B-1&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan A,Child Plan B&quot;&gt;&lt;/a&gt;Super:Plan A,Child Plan B&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/SC_SuperAChildB.png&quot; alt=&quot;SC_SuperAChildB&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 对象：如果 Super_Swizzle 与 Child_Swizzle 的 &lt;code&gt;selector&lt;/code&gt; 不同，则会产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常；如果两个 &lt;code&gt;selector&lt;/code&gt; 相同则 Child-&amp;gt;Base (Super 被忽略)&lt;/li&gt;
&lt;li&gt;Base 对象正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Super-Plan-B-Child-Plan-B-1&quot;&gt;&lt;a href=&quot;#Super-Plan-B-Child-Plan-B-1&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan B,Child Plan B&quot;&gt;&lt;/a&gt;Super:Plan B,Child Plan B&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/SC_SuperBChildB.png&quot; alt=&quot;SC_SuperBChildB&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 对象：如果 Super_Swizzle 与 Child_Swizzle 的 &lt;code&gt;selector&lt;/code&gt; 不同，则会产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常；如果两个 &lt;code&gt;selector&lt;/code&gt; 相同则 Child-&amp;gt;Base (Super 被忽略)&lt;/li&gt;
&lt;li&gt;Base 对象产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Super-实现方法-Child-未实现方法-1&quot;&gt;&lt;a href=&quot;#Super-实现方法-Child-未实现方法-1&quot; class=&quot;headerlink&quot; title=&quot;Super 实现方法,Child 未实现方法&quot;&gt;&lt;/a&gt;Super 实现方法,Child 未实现方法&lt;/h3&gt;&lt;p&gt;由于 Super 类被 Hook 的方法已经被实现，所以只需区分 Child 的 Hook 方案。&lt;/p&gt;
&lt;h4 id=&quot;Child-Plan-A-1&quot;&gt;&lt;a href=&quot;#Child-Plan-A-1&quot; class=&quot;headerlink&quot; title=&quot;Child:Plan A&quot;&gt;&lt;/a&gt;Child:Plan A&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/SC_ChildA.png&quot; alt=&quot;SC_ChildA&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果（一切正常）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 和 Base 对象均正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Child-Plan-B-1&quot;&gt;&lt;a href=&quot;#Child-Plan-B-1&quot; class=&quot;headerlink&quot; title=&quot;Child:Plan B&quot;&gt;&lt;/a&gt;Child:Plan B&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/SC_ChildB.png&quot; alt=&quot;SC_ChildB&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 对象：如果 Super_Swizzle 与 Child_Swizzle 的 &lt;code&gt;selector&lt;/code&gt; 不同，则会产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常；如果两个 &lt;code&gt;selector&lt;/code&gt; 相同则 Child-&amp;gt;Base (Super 被忽略)&lt;/li&gt;
&lt;li&gt;Base 对象正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Super-未实现方法-Child-实现方法-1&quot;&gt;&lt;a href=&quot;#Super-未实现方法-Child-实现方法-1&quot; class=&quot;headerlink&quot; title=&quot;Super 未实现方法,Child 实现方法&quot;&gt;&lt;/a&gt;Super 未实现方法,Child 实现方法&lt;/h3&gt;&lt;p&gt;由于 Child 类被 Hook 的方法已经被实现，所以只需区分 Super 的 Hook 方案。&lt;/p&gt;
&lt;h4 id=&quot;Super-Plan-A-1&quot;&gt;&lt;a href=&quot;#Super-Plan-A-1&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan A&quot;&gt;&lt;/a&gt;Super:Plan A&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/SC_SuperA.png&quot; alt=&quot;SC_SuperA&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果（一切正常）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 和 Base 对象均正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Super-Plan-B-1&quot;&gt;&lt;a href=&quot;#Super-Plan-B-1&quot; class=&quot;headerlink&quot; title=&quot;Super:Plan B&quot;&gt;&lt;/a&gt;Super:Plan B&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/SC_SuperB.png&quot; alt=&quot;SC_SuperB&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 对象正常：Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Base 对象产生 &lt;code&gt;unrecognized selector&lt;/code&gt; 异常，此情况亦等同于：在子类类别中 Hook 了子类未实现而父类实现了的方法。（Super 是 Base 的子类）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Super-实现方法-Child-实现方法-1&quot;&gt;&lt;a href=&quot;#Super-实现方法-Child-实现方法-1&quot; class=&quot;headerlink&quot; title=&quot;Super 实现方法,Child 实现方法&quot;&gt;&lt;/a&gt;Super 实现方法,Child 实现方法&lt;/h3&gt;&lt;p&gt;相当于 Super 和 Child 都使用方案 B 进行 Hook，所以只有一种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MethodSwizzling/SC_Perfect.png&quot; alt=&quot;SC_Perfect&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法执行结果（一切正常）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 对象正常：Child-&amp;gt;Super-&amp;gt;Base&lt;/li&gt;
&lt;li&gt;Super 和 Base 对象均正常&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;h3 id=&quot;Hook-顺序：先-Child-类后-Super-类&quot;&gt;&lt;a href=&quot;#Hook-顺序：先-Child-类后-Super-类&quot; class=&quot;headerlink&quot; title=&quot;Hook 顺序：先 Child 类后 Super 类&quot;&gt;&lt;/a&gt;Hook 顺序：先 Child 类后 Super 类&lt;/h3&gt;&lt;p&gt;为了保证 Hook 后方法调用顺序是对的，需要同时满足以下两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Child 类实现被 Hook 的方法&lt;/li&gt;
&lt;li&gt;Super 类实现被 Hook 的方法或使用 A 方案 Hook&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Hook-顺序：先-Super-类后-Child-类&quot;&gt;&lt;a href=&quot;#Hook-顺序：先-Super-类后-Child-类&quot; class=&quot;headerlink&quot; title=&quot;Hook 顺序：先 Super 类后 Child 类&quot;&gt;&lt;/a&gt;Hook 顺序：先 Super 类后 Child 类&lt;/h3&gt;&lt;p&gt;因为 Hook 的顺序是正确的，所以只需满足以下任意一个条件即可：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现被 Hook 的方法&lt;/li&gt;
&lt;li&gt;使用方案 A 进行 Hook&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Objective-C-Method-Swizzling-最佳实践&quot;&gt;&lt;a href=&quot;#Objective-C-Method-Swizzling-最佳实践&quot; class=&quot;headerlink&quot; title=&quot;Objective-C Method Swizzling 最佳实践&quot;&gt;&lt;/a&gt;Objective-C Method Swizzling 最佳实践&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Hook 顺序并不能保证结果一定正确，但先 Super 后 Child 效果更佳&lt;/li&gt;
&lt;li&gt;方案 A 明显优于方案 B&lt;/li&gt;
&lt;li&gt;方案 A 中的『静态方法版本』固然更缜密，但操作复杂。为了提升开发效率，建议参考 CaptainHook 的宏定义实现。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rabovik/RSSwizzle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RSSwizzle&lt;/a&gt; 被很多人推荐，它用很复杂的方式解决了 &lt;a href=&quot;http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What are the Dangers of Method Swizzling in Objective C?&lt;/a&gt; 中提到的一系列问题。不过引入它还是有一些成本的，建议在本文列举的那些极端特殊情况下才使用它，毕竟方案 A 已经能 Cover 到大部分情况了。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rentzsch/jrswizzle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jrswizzle&lt;/a&gt; 尝试解决在不同平台和系统版本上的 Method Swizzling 与类继承关系的冲突。对各平台低版本系统兼容性较强。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我觉得最适合项目的方案才是最佳实践。&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What are the Dangers of Method Swizzling in Objective C?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C 中的 Hook 又被称作 Method Swizzling，这是动态语言大都具有的特性。在 Objective-C 中经常会把 Hook 的逻辑写在 &lt;code&gt;+ load&lt;/code&gt; 方法中，这是利用它调用时机较提前等性质。&lt;/p&gt;
&lt;p&gt;有时候需要 Hook 子类和父类的同一个方法，但是它们的 &lt;code&gt;+ load&lt;/code&gt; 方法调用顺序不同。一个常见的顺序可能是：父类-&amp;gt;子类-&amp;gt;子类类别-&amp;gt;父类类别。所以 Hook 的顺序并不能保证，就不能保证 Hook 后方法调用的顺序是对的。而且使用不同方法 Method Swizzling 也会带来不同的结果。本文将会对这些情况下的 Hook 结果进行分析和总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yulingtianxia.com/tags/Objective-C/"/>
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>如何在逆向工程中 Hook 得更准 - 微信屏蔽好友&amp;群消息实战</title>
    <link href="http://yulingtianxia.com/blog/2017/03/06/How-to-hook-the-correct-method-in-reverse-engineering/"/>
    <id>http://yulingtianxia.com/blog/2017/03/06/How-to-hook-the-correct-method-in-reverse-engineering/</id>
    <published>2017-03-05T16:06:51.000Z</published>
    <updated>2017-03-23T04:58:56.000Z</updated>
    
    <content type="html">&lt;p&gt;在逆向工程中往往需要针对想要做的功能 Hook 到相应的方法和属性，小白面对 &lt;code&gt;class-dump&lt;/code&gt; 后的大量头文件表示只能靠『猜』。这里我分享下逆向微信实现屏蔽群消息和好友消息的实战经验，适用于&lt;strong&gt;非越狱机&lt;/strong&gt;，项目 GitHub 地址: &lt;a href=&quot;https://github.com/yulingtianxia/FishChat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FishChat&lt;/a&gt;。为了能读懂此文，建议先阅读我的上一篇文章：&lt;a href=&quot;http://yulingtianxia.com/blog/2017/02/28/Make-WeChat-Great-Again/&quot;&gt;Make WeChat Great Again&lt;/a&gt;。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;从-UI-猜&quot;&gt;&lt;a href=&quot;#从-UI-猜&quot; class=&quot;headerlink&quot; title=&quot;从 UI 猜&quot;&gt;&lt;/a&gt;从 UI 猜&lt;/h2&gt;&lt;p&gt;先用 &lt;code&gt;Cycript&lt;/code&gt; 或 Reveal 获取视图层级信息，然后从 &lt;code&gt;View&lt;/code&gt; 和 &lt;code&gt;ViewController&lt;/code&gt; 的头文件中寻找信息。然后就凭编程经验去猜了，比如一些方法属性的命名，一些常用的代码设计等等套路。&lt;/p&gt;
&lt;p&gt;比如现在我想在群信息页面和个人聊天详情页面增加个屏蔽消息的开关，先找到对应的 &lt;code&gt;ViewController&lt;/code&gt; 类，然后到头文件中去找信息。因为这都是两个列表 UI，这种信息页面的列表 Cell 一般不需要重用的，直接数据配置即可。然后很容易发现这两个 &lt;code&gt;ViewController&lt;/code&gt; 都有 &lt;code&gt;m_tableViewInfo&lt;/code&gt; 这个属性，类型为 &lt;code&gt;MMTableViewInfo&lt;/code&gt;。接着顺藤摸瓜，发现其与 &lt;code&gt;MMTableViewSectionInfo&lt;/code&gt; 和 &lt;code&gt;MMTableViewCellInfo&lt;/code&gt; 这两个类构成了整个列表的数据。Table-Section-Cell 这三个层级的的数据对应着 UI，熟悉 iOS 的很容易看懂。进而使用这三个类的方法来修改 &lt;code&gt;m_tableViewInfo&lt;/code&gt; 中的数据，实现修改 UI 的目的。因为是列表数据，凭经验应该是 &lt;code&gt;reloadData&lt;/code&gt; 的时候去做修改。恰好这两个 &lt;code&gt;ViewController&lt;/code&gt; 中都有 &lt;code&gt;reloadTableData&lt;/code&gt; 方法，Hook 后果然生效，效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Images/weichat_ignore_chatroom.PNG?raw=true&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Images/wechat_ignore_somone.PNG?raw=true&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;逆向的时候需要处处为对方着想，换位思考。如果仅想着 Hook 系统的 API 来修改 UI，在这个例子里显然要多走些弯路。&lt;/p&gt;
&lt;p&gt;剩下的就是获取好友 ID 和群 ID，用一个字典存储是否屏蔽的标记，在操作开关的时候对字典赋值。这些功能也能够通过分析 UI 逆向实现。&lt;/p&gt;
&lt;h2 id=&quot;关联相关类一起猜&quot;&gt;&lt;a href=&quot;#关联相关类一起猜&quot; class=&quot;headerlink&quot; title=&quot;关联相关类一起猜&quot;&gt;&lt;/a&gt;关联相关类一起猜&lt;/h2&gt;&lt;p&gt;在我之前写的 &lt;a href=&quot;http://yulingtianxia.com/blog/2017/02/28/Make-WeChat-Great-Again/&quot;&gt;Make WeChat Great Again&lt;/a&gt; 里有提到 &lt;code&gt;CMessageMgr&lt;/code&gt; 这个类，它是个管理消息的单例，而消息被包装成 &lt;code&gt;CMessageWrap&lt;/code&gt; 对象来传递。在 &lt;code&gt;CMessageMgr&lt;/code&gt; 中搜索 getmsg 会发现有好几个方法。因为 &lt;code&gt;CMessageWrap&lt;/code&gt; 中包含 &lt;code&gt;m_uiMesLocalID&lt;/code&gt; 和 &lt;code&gt;m_n64MesSvrID&lt;/code&gt; 属性，所以锁定目标为 &lt;code&gt;- (id)GetMsg:n64SvrID:&lt;/code&gt; 和 &lt;code&gt;- (id)GetMsg:LocalID:&lt;/code&gt;，经过验证后发现获取消息时调用的是后者。PS：进入聊天窗口时其实还调用了 &lt;code&gt;- (id)GetMsgByCreateTime:FromID:FromCreateTime:Limit:LeftCount:FromSequence:&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;不过，Hook &lt;code&gt;- (id)GetMsg:LocalID:&lt;/code&gt; 之后发现即便不调用原始方法的实现，直接返回 &lt;code&gt;nil&lt;/code&gt;，也依然不能屏蔽消息。这时需要找到调用它的上层方法，然后继续寻找真正处理消息的逻辑。&lt;/p&gt;
&lt;h2 id=&quot;逆向工程绝不仅仅靠猜&quot;&gt;&lt;a href=&quot;#逆向工程绝不仅仅靠猜&quot; class=&quot;headerlink&quot; title=&quot;逆向工程绝不仅仅靠猜&quot;&gt;&lt;/a&gt;逆向工程绝不仅仅靠猜&lt;/h2&gt;&lt;p&gt;初步思路是获取到方法的调用栈，然后查找上一层的方法，并将方法调用的地址换算成 Hopper 反汇编后的地址，这样就能获取到方法名了，然后进行 Hook。&lt;/p&gt;
&lt;h3 id=&quot;获取方法的-IMP&quot;&gt;&lt;a href=&quot;#获取方法的-IMP&quot; class=&quot;headerlink&quot; title=&quot;获取方法的 IMP&quot;&gt;&lt;/a&gt;获取方法的 IMP&lt;/h3&gt;&lt;p&gt;如果是越狱手机，直接 ssh 到手机执行 &lt;code&gt;debugserver&lt;/code&gt;，然后就可以像平时 debug 那样用 lldb 尽情调戏程序了。而我这里因为是非越狱机，只能打 Log 了。&lt;/p&gt;
&lt;p&gt;WeChat 可执行文件和我注入的 FishChat.dylib 文件加载的地址是随机的，而且我打的 Log 都是在 FishChat.dylib 中已经 Hook 过的方法中。熟悉 image 加载过程和 Hook 概念很重要，后面会用到。可以参考这篇文章：&lt;a href=&quot;http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/&quot;&gt;优化 App 的启动时间&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果是自己用 Method Swizzling 写的 Hook 逻辑，很容易拿到原始方法的 &lt;code&gt;IMP&lt;/code&gt;。但这里是使用 &lt;code&gt;CaptainHook&lt;/code&gt;，是对 Method Swizzling 的宏定义封装而已，创建了很多内联函数。所谓的 Method Swizzling 其实也就是 &lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot;&gt;Objective-C Runtime&lt;/a&gt; 的一种应用而已。&lt;/p&gt;
&lt;p&gt;那么该如何找到 &lt;code&gt;CaptainHook&lt;/code&gt; 为我们保存的原始的方法 IMP 呢？&lt;/p&gt;
&lt;p&gt;首先先新建一个 &lt;code&gt;hook.m&lt;/code&gt; 文件，内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;CaptainHook.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CHDeclareMethod2(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, CMessageMgr, GetMsg, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, arg1, LocalID, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, arg2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用 &lt;code&gt;clang -E hook.m -o hook.c&lt;/code&gt; 命令将宏展开，因为文件内容很多，只截取其中比较有意义的部分：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static id (*$CMessageMgr_GetMsg$LocalID$_super)(CMessageMgr * &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, SEL _cmd, id arg1, unsigned int arg2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static id $CMessageMgr_GetMsg$LocalID$_closure(CMessageMgr * &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, SEL _cmd, id arg1, unsigned int arg2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    typedef id (*supType)(CMessageMgr *, SEL, id arg1, unsigned int arg2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    supType supFn = (supType)class_getMethodImplementation(CMessageMgr$.superClass&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;, _cmd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; supFn (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, _cmd, arg1, arg2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static id $CMessageMgr_GetMsg$LocalID$_method(CMessageMgr * &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, SEL _cmd, id arg1, unsigned int arg2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__attribute_&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;((always_inline)) static inline void $CMessageMgr_GetMsg$LocalID$_register() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method method = class_getInstanceMethod(CMessageMgr$.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;, @selector(&lt;span class=&quot;symbol&quot;&gt;GetMsg:&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;LocalID:&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (method) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $CMessageMgr_GetMsg$LocalID$_super = (__typeof_&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;($CMessageMgr_GetMsg$LocalID$_super))method_getImplementation(method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (class_addMethod(CMessageMgr$.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt;, @selector(&lt;span class=&quot;symbol&quot;&gt;GetMsg:&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;LocalID:&lt;/span&gt;), (IMP)&amp;amp;$CMessageMgr_GetMsg$LocalID$_method, method_getTypeEncoding(method))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $CMessageMgr_GetMsg$LocalID$_super = &amp;amp;$CMessageMgr_GetMsg$LocalID$_closure;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            method_setImplementation(method, (IMP)&amp;amp;$CMessageMgr_GetMsg$LocalID$_method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; 省略&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结合 &lt;code&gt;CaptainHook.h&lt;/code&gt; 中的宏定义，不难找出 &lt;code&gt;$CMessageMgr_GetMsg$LocalID$_super&lt;/code&gt; 就是原始方法对应实现的函数指针，也就是 &lt;code&gt;IMP&lt;/code&gt;。&lt;code&gt;$CMessageMgr_GetMsg$LocalID$_method&lt;/code&gt; 是 Hook 过后方法的函数指针。&lt;/p&gt;
&lt;p&gt;这里真的不是靠猜，纯粹 &lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot;&gt;Objective-C Runtime&lt;/a&gt; 玩的熟。理解 &lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot;&gt;Objective-C Runtime&lt;/a&gt; 的一些概念和常用函数后很容易判断 Hook 的原始方法和新的方法。&lt;/p&gt;
&lt;p&gt;所以最后的代码如下。这里打印了方法传入的参数、原始方法的 &lt;code&gt;IMP&lt;/code&gt; 和方法调用栈。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CHDeclareMethod2(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, CMessageMgr, GetMsg, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, arg1, LocalID, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, arg2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;GetMsg:%@ LocalID:%d&quot;&lt;/span&gt;,arg1,arg2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;originalIMP:%p&quot;&lt;/span&gt;,$CMessageMgr_GetMsg$LocalID$_&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; callStackSymbols]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; CHSuper2(CMessageMgr, GetMsg, arg1, LocalID, arg2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Mar  &lt;span class=&quot;number&quot;&gt;2 00:37:36&lt;/span&gt; yangxiaoyude-iPhone WeChat(FishChat.dylib)[&lt;span class=&quot;number&quot;&gt;22880&lt;/span&gt;] &amp;lt;Notice&amp;gt;: GetMsg:weixin LocalID:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mar  &lt;span class=&quot;number&quot;&gt;2 00:37:36&lt;/span&gt; yangxiaoyude-iPhone WeChat(FishChat.dylib)[&lt;span class=&quot;number&quot;&gt;22880&lt;/span&gt;] &amp;lt;Notice&amp;gt;: originalIMP:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x&lt;span class=&quot;number&quot;&gt;1028821d4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mar  &lt;span class=&quot;number&quot;&gt;2 00:37:36&lt;/span&gt; yangxiaoyude-iPhone WeChat(FishChat.dylib)[&lt;span class=&quot;number&quot;&gt;22880&lt;/span&gt;] &amp;lt;Notice&amp;gt;: (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;   FishChat.dylib                      &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x000000010437dd08 _ZL35$CMessageMgr_GetMsg$LocalID$_methodP11CMessageMgrP13objc_selectorP11objc_objectj + &lt;span class=&quot;number&quot;&gt;224&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x0000000102afb960 _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;1218052&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x0000000102afe4b8 _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;1229148&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x000000&lt;span class=&quot;number&quot;&gt;01029f1554&lt;/span&gt; _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;127480&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x0000&lt;span class=&quot;number&quot;&gt;000102a47390&lt;/span&gt; _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;479284&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x0000000102ad4d64 _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;1059336&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x0000&lt;span class=&quot;number&quot;&gt;000102a52050&lt;/span&gt; _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;523508&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   Foundation                          &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x0000&lt;span class=&quot;number&quot;&gt;000194125048&lt;/span&gt; &amp;lt;redacted&amp;gt; + &lt;span class=&quot;number&quot;&gt;340&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   CoreFounda&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;将地址翻译成-Selector&quot;&gt;&lt;a href=&quot;#将地址翻译成-Selector&quot; class=&quot;headerlink&quot; title=&quot;将地址翻译成 Selector&quot;&gt;&lt;/a&gt;将地址翻译成 Selector&lt;/h3&gt;&lt;p&gt;这里分详细和快速两种方法来讲述如何通过内存地址找到对应的 &lt;code&gt;Selector&lt;/code&gt;。分步骤计算适合对操作系统原理不太熟悉的新手，老司机可以直接进入『快速计算方法』。&lt;/p&gt;
&lt;h4 id=&quot;分步详细剖析计算方法&quot;&gt;&lt;a href=&quot;#分步详细剖析计算方法&quot; class=&quot;headerlink&quot; title=&quot;分步详细剖析计算方法&quot;&gt;&lt;/a&gt;分步详细剖析计算方法&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;反汇编得出方法相对地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;记得在&lt;strong&gt;选择 FAT 架构时选择跟手机 CPU 相匹配的架构&lt;/strong&gt;，有 armv7 和 aarch64 两种可选。我这里以 aarch64 为例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-[CMessageMgr GetMsg:LocalID:]&lt;/code&gt; 在 Hopper 中的地址 &lt;code&gt;0x000000010280e1d4&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/reverse%20engineering/original_method_address@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;WeChat Mach-O 在 Hopper 中的基地址 &lt;code&gt;0x0000000100000000&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/reverse%20engineering/wechat_base_address@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;得出 &lt;code&gt;-[CMessageMgr GetMsg:LocalID:]&lt;/code&gt; 在 WeChat 中的相对地址为 &lt;code&gt;0x280E1D4&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x000000010280e1d4 - 0x0000000100000000 = 0x280E1D4&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算 Mach-O 文件加载的随机地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前打印 &lt;code&gt;-[CMessageMgr GetMsg:LocalID:]&lt;/code&gt; 原始实现的 &lt;code&gt;IMP&lt;/code&gt; 为 &lt;code&gt;0x1028821d4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;WeChat 文件在手机中加载的随机地址为 &lt;strong&gt;『原始 IMP 的地址 - 方法相对地址』&lt;/strong&gt;，结果为 &lt;code&gt;0x100074000&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x1028821d4 - 0x280E1D4 = 0x100074000&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;还原调用栈为相对地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将之前打印出调用栈上的地址转换成相对地址，再加上 Hopper 上的基地址 &lt;code&gt;0x0000000100000000&lt;/code&gt;，公式为 &lt;strong&gt;『调用栈上的地址 - WeChat 随机地址 + &lt;code&gt;0x0000000100000000&lt;/code&gt;』&lt;/strong&gt;，结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight basic&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;1 &lt;/span&gt;  WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x102A87960 _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;1218052&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;2 &lt;/span&gt;  WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x102A8A4B8 _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;1229148&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;3 &lt;/span&gt;  WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x10297D554 _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;127480&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;4 &lt;/span&gt;  WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x1029D3390 _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;479284&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;5 &lt;/span&gt;  WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x102A60D64 _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;1059336&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;6 &lt;/span&gt;  WeChat                              &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x1029DE050 _ZN16ClearSessionItem7compareERKNSt3__110shared_ptrIS_EES4_ + &lt;span class=&quot;number&quot;&gt;523508&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;快速计算方法&quot;&gt;&lt;a href=&quot;#快速计算方法&quot; class=&quot;headerlink&quot; title=&quot;快速计算方法&quot;&gt;&lt;/a&gt;快速计算方法&lt;/h4&gt;&lt;p&gt;已知条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;-[CMessageMgr GetMsg:LocalID:]&lt;/code&gt; 在 Hopper 反汇编后的地址 &lt;code&gt;0x10280e1d4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-[CMessageMgr GetMsg:LocalID:]&lt;/code&gt; 方法内存地址为 &lt;code&gt;0x1028821d4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-[CMessageMgr GetMsg:LocalID:]&lt;/code&gt; 在内存中 &lt;code&gt;0x102afb960&lt;/code&gt; 处被调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;求 &lt;code&gt;0x102afb960&lt;/code&gt; 对应 Hopper 反汇编后的地址？&lt;/p&gt;
&lt;p&gt;因为方法间的相对地址是不变的，所以：&lt;/p&gt;
&lt;p&gt;A 方法反汇编地址 - B 方法反汇编地址 = A 方法真实地址 - B 方法真实地址&lt;/p&gt;
&lt;p&gt;所以结果为 &lt;code&gt;0x102A87960&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x102afb960 - 0x1028821d4 + 0x10280e1d4 = 0x102A87960&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;跟之前的分步骤计算结果一样。&lt;/p&gt;
&lt;h4 id=&quot;还原-Selector&quot;&gt;&lt;a href=&quot;#还原-Selector&quot; class=&quot;headerlink&quot; title=&quot;还原 Selector&quot;&gt;&lt;/a&gt;还原 Selector&lt;/h4&gt;&lt;p&gt;根据反汇编地址在 Hopper 中定位方法名，快捷键 &lt;code&gt;G&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最终得到的方法调用栈如下，调用次序是自底向上：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-[CSyncBaseEvent &lt;span class=&quot;string&quot;&gt;BatchAddMsg:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;ShowPush:&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-[CSyncBaseEvent &lt;span class=&quot;string&quot;&gt;HandleBatch:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;ShowPush:&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-[NewSyncHandler &lt;span class=&quot;string&quot;&gt;HandleSyncResp:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;Push:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;ShowPush:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;ContinueFlag:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;Scene:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;syncKeyMd5:&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-[NewSyncService &lt;span class=&quot;string&quot;&gt;HandleSyncResp:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;Push:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;ShowPush:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;Scene:&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-[CNewSyncPrtl &lt;span class=&quot;string&quot;&gt;HandleResp:&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-[EventService &lt;span class=&quot;string&quot;&gt;HandleRespThread:&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;从汇编代码继续猜&quot;&gt;&lt;a href=&quot;#从汇编代码继续猜&quot; class=&quot;headerlink&quot; title=&quot;从汇编代码继续猜&quot;&gt;&lt;/a&gt;从汇编代码继续猜&lt;/h2&gt;&lt;p&gt;虽然可以锁定添加消息的实现逻辑在 &lt;code&gt;-[CSyncBaseEvent BatchAddMsg:ShowPush:]&lt;/code&gt; 方法里，但是查找头文件发现它的两个参数和一个返回值竟然都是 &lt;code&gt;BOOL&lt;/code&gt; 类型。直接 Hook 掉并返回 &lt;code&gt;NO&lt;/code&gt; 虽然可以屏蔽消息，但是却屏蔽了所有的消息，没有对消息来源进行筛选。可以肯定的是在其内部已经获取到了 &lt;code&gt;CMessageWrap&lt;/code&gt; 消息数组（Batch 暗示批量），然后才调用的 &lt;code&gt;-[CMessageMgr GetMsg:LocalID:]&lt;/code&gt; 方法。而真正添加消息的逻辑可能在 &lt;code&gt;-[CMessageMgr GetMsg:LocalID:]&lt;/code&gt; 调用之前，也可能在它调用之后。&lt;/p&gt;
&lt;p&gt;在不能反编译的情况下，只能浏览下方法的汇编代码中调用到什么其他方法。消息被封装成 &lt;code&gt;CMessageWrap&lt;/code&gt; 类，所以要格外注意这个类的一些属性名，或者 &lt;code&gt;MsgWrap&lt;/code&gt; 这个词。进而找到 &lt;code&gt;BatchAddMsgInfo&lt;/code&gt; 这个类有一些汇编中出现的消息处理的标志位（&lt;code&gt;isInsertNew&lt;/code&gt;,&lt;code&gt;isNeedChangeDisplay&lt;/code&gt;,&lt;code&gt;isNotify&lt;/code&gt;,&lt;code&gt;isCanAddDB&lt;/code&gt;） 和 &lt;code&gt;CMessageWrap&lt;/code&gt;。打开头文件，一眼就看到一个成员变量 &lt;code&gt;m_arrMsgList&lt;/code&gt;，果然是我我想要的消息数组，过滤下即可：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CHDeclareClass(CSyncBaseEvent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CHDeclareMethod2(&lt;span class=&quot;keyword&quot;&gt;BOOL, &lt;/span&gt;CSyncBaseEvent, &lt;span class=&quot;keyword&quot;&gt;BatchAddMsg, &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;BOOL, &lt;/span&gt;arg1, &lt;span class=&quot;keyword&quot;&gt;ShowPush, &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;BOOL, &lt;/span&gt;arg2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *msgList = [self valueForKeyPath:@&lt;span class=&quot;string&quot;&gt;&quot;m_arrMsgList&quot;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *msgListResult = filtMessageWrapArr(msgList)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self setValue:msgListResult forKeyPath:@&lt;span class=&quot;string&quot;&gt;&quot;m_arrMsgList&quot;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return CHSuper2(CSyncBaseEvent, &lt;span class=&quot;keyword&quot;&gt;BatchAddMsg, &lt;/span&gt;arg1, &lt;span class=&quot;keyword&quot;&gt;ShowPush, &lt;/span&gt;arg2)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;写过滤函数时注意 MRC 下的内存管理，不要产生内存泄露。拿到 &lt;code&gt;CMessageWrap&lt;/code&gt; 对象时判断消息来源是否需要被屏蔽，删掉数组中需要被屏蔽的消息对象。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; * filtMessageWrapArr(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *msgList) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *msgListResult = [msgList mutableCopy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; msgWrap &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; msgList) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Ivar nsFromUsrIvar = class_getInstanceVariable(objc_getClass(&lt;span class=&quot;string&quot;&gt;&quot;CMessageWrap&quot;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;m_nsFromUsr&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *m_nsFromUsr = object_getIvar(msgWrap, nsFromUsrIvar);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([FishConfigurationCenter sharedInstance].chatIgnoreInfo[m_nsFromUsr].boolValue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [msgListResult removeObject:msgWrap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [msgListResult autorelease];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终屏蔽消息功能大功告成。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;这里只是做个示范，并不代表我 Hook 得最准。因为条条大路通罗马，只要达到目的就好。本来逆向工程就是在没有源码的情况下揣测和分析，所以不同的人会给出不同的逆向过程，这就像从南坡和北坡一起爬山一样。&lt;/p&gt;
&lt;p&gt;由于篇幅有限，没能讲解实现屏蔽消息功能的所有代码。源码 GitHub 地址 &lt;a href=&quot;https://github.com/yulingtianxia/FishChat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FishChat&lt;/a&gt;，欢迎提 PR 一起切磋，钻研。&lt;/p&gt;
&lt;p&gt;本人是个 iOS 逆向新手，基本是现学现卖，如有疏漏，还请大牛们指正。&lt;/p&gt;
&lt;p&gt;本项目仅做学习研究用途，禁止用于黑产获利等行为。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在逆向工程中往往需要针对想要做的功能 Hook 到相应的方法和属性，小白面对 &lt;code&gt;class-dump&lt;/code&gt; 后的大量头文件表示只能靠『猜』。这里我分享下逆向微信实现屏蔽群消息和好友消息的实战经验，适用于&lt;strong&gt;非越狱机&lt;/strong&gt;，项目 GitHub 地址: &lt;a href=&quot;https://github.com/yulingtianxia/FishChat&quot;&gt;FishChat&lt;/a&gt;。为了能读懂此文，建议先阅读我的上一篇文章：&lt;a href=&quot;http://yulingtianxia.com/blog/2017/02/28/Make-WeChat-Great-Again/&quot;&gt;Make WeChat Great Again&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Make WeChat Great Again</title>
    <link href="http://yulingtianxia.com/blog/2017/02/28/Make-WeChat-Great-Again/"/>
    <id>http://yulingtianxia.com/blog/2017/02/28/Make-WeChat-Great-Again/</id>
    <published>2017-02-27T17:08:05.000Z</published>
    <updated>2017-03-23T04:58:56.000Z</updated>
    
    <content type="html">&lt;p&gt;关闭朋友圈有一年多了，突然有一天微信的策略变了，在关闭朋友圈的同时也不让别人查看自己的朋友圈了。有妹子表示看不到我朋友圈很不爽，于是我决定对微信进行一番改造！初步实现效果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关闭『发现』页面的『朋友圈』、『购物』和『游戏』入口&lt;/li&gt;
&lt;li&gt;修改微信运动步数&lt;/li&gt;
&lt;li&gt;去除各种小红点提示&lt;/li&gt;
&lt;li&gt;设置夜间模式&lt;/li&gt;
&lt;li&gt;阻止撤回消息&lt;/li&gt;
&lt;li&gt;屏蔽群&amp;amp;好友消息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;手机无需越狱&lt;/strong&gt;，项目 GitHub 地址: &lt;a href=&quot;https://github.com/yulingtianxia/FishChat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FishChat&lt;/a&gt;，Make WeChat Great Again！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;工欲善其事必先利其器&quot;&gt;&lt;a href=&quot;#工欲善其事必先利其器&quot; class=&quot;headerlink&quot; title=&quot;工欲善其事必先利其器&quot;&gt;&lt;/a&gt;工欲善其事必先利其器&lt;/h2&gt;&lt;p&gt;因为没有越狱手机，所以不是直接写 tweak 放手机里，而是需要将 &lt;code&gt;CaptainHook&lt;/code&gt; 工程编译出的 dylib 注入到已砸壳 app 的二进制文件中。同样因为没有越狱机，所以砸壳的文件只能从 某 P 助手下载了。&lt;/p&gt;
&lt;p&gt;我写了一个 Shell 脚本 &lt;a href=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Shell/autoswimfi.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;autoswimfi.sh&lt;/a&gt; 帮我完成一些重复性的任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查找可用的 iPhone 开发者证书&lt;/li&gt;
&lt;li&gt;解压 ipa 文件&lt;/li&gt;
&lt;li&gt;拷贝 mobileprovision 文件和要注入的 dylib 文件到 app 文件夹中&lt;/li&gt;
&lt;li&gt;向 app 中可执行文件的 &lt;code&gt;Load Commands&lt;/code&gt; 段中加入一条加载 dylib 的指令&lt;/li&gt;
&lt;li&gt;对 app 中所有的 app，appx，framework，dylib 文件用第 1 步获取的证书进行重签名&lt;/li&gt;
&lt;li&gt;打包签名好的 ipa 文件&lt;/li&gt;
&lt;li&gt;删除上述过程中产生的中间文件&lt;/li&gt;
&lt;li&gt;通过 USB 线安装 ipa 文件手机上&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Shell/autoswimfi.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;autoswimfi.sh&lt;/a&gt; 需要传入的三个参数分别为：已砸壳的 ipa 文件，没过期的 mobileprovision 文件，要注入的 dylib 文件。&lt;/p&gt;
&lt;p&gt;犹豫了很久，还是贴上脚本代码，壮气势充篇幅吧。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# !/bin/bash&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SOURCEIPA=&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$1&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MOBILEPROV=&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$2&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DYLIB=&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$3&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$&amp;#123;SOURCEIPA%/*&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;security find-identity -v -p codesigning &amp;gt; cers.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; IFS=&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt; -r line || [[ -n &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt;&quot;&lt;/span&gt; ]]; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; [[ &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt;&quot;&lt;/span&gt; =~ &lt;span class=&quot;string&quot;&gt;&quot;iPhone Developer&quot;&lt;/span&gt; ]]; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      DEVELOPER=&lt;span class=&quot;variable&quot;&gt;$&amp;#123;line:47:$&amp;#123;#line&amp;#125;&lt;/span&gt;-48&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt; &amp;lt; cers.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unzip -qo &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$SOURCEIPA&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;_&quot;&gt;-d&lt;/span&gt; extracted&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;APPLICATION=$(ls extracted/Payload/)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Copying dylib and mobileprovision&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cp &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$DYLIB&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;extracted/Payload/&lt;span class=&quot;variable&quot;&gt;$APPLICATION&lt;/span&gt;/&lt;span class=&quot;variable&quot;&gt;$&amp;#123;DYLIB##*/&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cp &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$MOBILEPROV&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;extracted/Payload/&lt;span class=&quot;variable&quot;&gt;$APPLICATION&lt;/span&gt;/embedded.mobileprovision&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Insert dylib into Mach-O file&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yololib &lt;span class=&quot;string&quot;&gt;&quot;extracted/Payload/&lt;span class=&quot;variable&quot;&gt;$APPLICATION&lt;/span&gt;/&lt;span class=&quot;variable&quot;&gt;$&amp;#123;APPLICATION%.*&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$&amp;#123;DYLIB##*/&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Resigning with certificate: &lt;span class=&quot;variable&quot;&gt;$DEVELOPER&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find &lt;span class=&quot;_&quot;&gt;-d&lt;/span&gt; extracted  \( -name &lt;span class=&quot;string&quot;&gt;&quot;*.app&quot;&lt;/span&gt; -o -name &lt;span class=&quot;string&quot;&gt;&quot;*.appex&quot;&lt;/span&gt; -o -name &lt;span class=&quot;string&quot;&gt;&quot;*.framework&quot;&lt;/span&gt; -o -name &lt;span class=&quot;string&quot;&gt;&quot;*.dylib&quot;&lt;/span&gt; \) &amp;gt; directories.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;security cms -D -i &lt;span class=&quot;string&quot;&gt;&quot;extracted/Payload/&lt;span class=&quot;variable&quot;&gt;$APPLICATION&lt;/span&gt;/embedded.mobileprovision&quot;&lt;/span&gt; &amp;gt; t_entitlements_full.plist&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/usr/libexec/PlistBuddy -x -c &lt;span class=&quot;string&quot;&gt;&#39;Print:Entitlements&#39;&lt;/span&gt; t_entitlements_full.plist &amp;gt; t_entitlements.plist&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; IFS=&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;read&lt;/span&gt; -r line || [[ -n &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt;&quot;&lt;/span&gt; ]]; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /usr/bin/codesign --continue &lt;span class=&quot;_&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;_&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$DEVELOPER&lt;/span&gt;&quot;&lt;/span&gt; --entitlements &lt;span class=&quot;string&quot;&gt;&quot;t_entitlements.plist&quot;&lt;/span&gt;  &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$line&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt; &amp;lt; directories.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Creating the Signed IPA&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; extracted&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;zip -qry ../extracted.ipa *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm -rf &lt;span class=&quot;string&quot;&gt;&quot;extracted&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm directories.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm cers.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm t_entitlements.plist&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm t_entitlements_full.plist&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Installing APP to your iOS Device&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mobiledevice install_app extracted.ipa&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;想要让 &lt;a href=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Shell/autoswimfi.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;autoswimfi.sh&lt;/a&gt; 一气呵成执行下去，需要依赖以下几项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mac 上需要有唯一可用的 iPhone 开发者证书，如果有多个，默认选最后一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yololib&lt;/code&gt; 工具用于注入 dylib 文件到二进制文件中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mobiledevice&lt;/code&gt; 可以将 ipa 安装到 USB 连接到 Mac 上的手机中&lt;/li&gt;
&lt;li&gt;一个可用的 mobileprovision 文件，十分关键，可以新建个工程在自己手机 Run 一下，新生成的 app 里面就有 mobileprovision 文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这里多再说几句：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一年多前我尝试安装 &lt;code&gt;iOSOpenDev&lt;/code&gt; 很多次，一直失败，就当前辈们劝我还是用 &lt;code&gt;theos&lt;/code&gt; 稳妥的时候，我觉得还是再试一次吧，果然还是失败了。不过新建 Xcode 项目选择 template 时却出现了 &lt;code&gt;iOSOpenDev&lt;/code&gt; 哈哈哈哈！&lt;/li&gt;
&lt;li&gt;一开始用 &lt;code&gt;insert_dylib&lt;/code&gt; 注入 dylib 后 crash，后来用 &lt;code&gt;yololib&lt;/code&gt; 就好了！不过 &lt;code&gt;yololib&lt;/code&gt; 有个 bug 是对 dylib 的版本号有要求。这里可以直接改源码，把 &lt;code&gt;DYLIB_CURRENT_VER&lt;/code&gt; 和 &lt;code&gt;DYLIB_COMPATIBILITY_VERSION&lt;/code&gt; 的宏定义都改成 &lt;code&gt;0x0000&lt;/code&gt;。懒人直接用我上传的 &lt;a href=&quot;https://github.com/yulingtianxia/FishChat/blob/master/yololib&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yololib&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果要查看 Mach-O 文件完整信息，建议用 MachOView。&lt;code&gt;otool -l&lt;/code&gt; 打印所有的 &lt;code&gt;Load Commands&lt;/code&gt;，建议搭配 &lt;code&gt;grep&lt;/code&gt; 进行正则过滤。&lt;code&gt;otool -L&lt;/code&gt; 可以查看使用的库文件。&lt;/li&gt;
&lt;li&gt;网上一些重签名工具没有将插件拓展或 Watch 中的 dylib 重签名，导致签名失败等问题。微信的 Apple Watch 客户端用 Swift 写的，因为还没有 ABI 稳定，所以只好把大量 dylib 打包进去。&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;Cycript&lt;/code&gt; 来完成一些调试工作，这样就不用一次次打 Log 了。同样也可以打印出视图层级，不过建议有条件的同学用 Reveal 2，已经支持 USB 调试了。&lt;code&gt;Cycript&lt;/code&gt; 只支持在同网段下连接到手机 IP 的 &lt;code&gt;8888&lt;/code&gt; 端口，cy 脚本还是跟 &lt;code&gt;lldb&lt;/code&gt; 命令有一些差别的。如果 &lt;code&gt;Cycript&lt;/code&gt; 官网的 sdk 不好用，那就用用我上传的吧：&lt;a href=&quot;https://github.com/yulingtianxia/FishChat/tree/master/Cycript.framework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Cycript.framework&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;找到视图对应的类之后，就需要在 &lt;code&gt;class-dump&lt;/code&gt; 得到的头文件寻找蛛丝马迹了。Dump 出的文件：&lt;a href=&quot;https://github.com/yulingtianxia/FishChat/tree/master/WeChat-Headers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WeChat-Headers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;查看设备 Log 最简单的方式当然是从 Xcode-&amp;gt;Devices-&amp;gt;你的设备。 &lt;/li&gt;
&lt;li&gt;安装时如果遇到 &lt;code&gt;AMDeviceSecureInstallApplication&lt;/code&gt; 安装失败，可以将工程 Clean 和 Clean Build Folder 后重新编译，再跑一次我的脚本。如果还不行，尝试用 iTools 等软件安装 ipa 到手机上。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;之后就是不停地-Hook&quot;&gt;&lt;a href=&quot;#之后就是不停地-Hook&quot; class=&quot;headerlink&quot; title=&quot;之后就是不停地 Hook&quot;&gt;&lt;/a&gt;之后就是不停地 Hook&lt;/h2&gt;&lt;p&gt;我曾经在『&lt;a href=&quot;http://yulingtianxia.com/blog/2016/05/06/Let-your-WeChat-for-Mac-never-revoke-messages/&quot;&gt;让你的微信不再被人撤回消息&lt;/a&gt;』这篇文章中说过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前看的一些逆向的教程里，感觉前期工作都是装软件配环境，噼里啪啦命令一顿敲，整的挺玄乎，其实都是用人家现成儿的工具做些事情，美其名曰『站在巨人的肩膀上』，这里不再赘述。在我看来第一个真正意义上有难度的事情就是一个字儿：『猜』！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是啊，头文件有了，UI 层级有了，该猜了！那么检验是否猜对需要做啥？Hook 呗！&lt;code&gt;CaptainHook&lt;/code&gt; 的用法很简单，新建工程的模板注释里面已经写得很详细了，就不赘述了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mac 上需要安装 &lt;code&gt;iOSOpenDev&lt;/code&gt; 或 &lt;code&gt;theos&lt;/code&gt;，本项目新建工程时使用 &lt;code&gt;iOSOpenDev&lt;/code&gt; 的 &lt;code&gt;CaptainHook&lt;/code&gt; 模板。编译的时候要选自己的手机，不要选模拟器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;关闭『发现』页面的各种入口-清君侧&quot;&gt;&lt;a href=&quot;#关闭『发现』页面的各种入口-清君侧&quot; class=&quot;headerlink&quot; title=&quot;关闭『发现』页面的各种入口 - 清君侧&quot;&gt;&lt;/a&gt;关闭『发现』页面的各种入口 - 清君侧&lt;/h3&gt;&lt;p&gt;在关掉各种乱码七糟的功能之后，发现页面仍留下几个无法关闭的入口。本次逆向微信的动机也由此引发：我只想关闭朋友圈入口，并没想关闭自己朋友圈内容，不过微信的这项策略也是很符合一些人的需求的。很多人真的想关闭自己朋友圈不让别人看，不过将这个需求跟旧的『关闭朋友圈入口』功能强绑定在一起，就有些绑架用户的味道了，鱼和熊掌不可兼得啊！不过关闭朋友圈后，别人依然能看到自己在 TimeLine 上新发的内容，但是一旦点击头像进入主页后就提示『该朋友暂未开启朋友圈』，奇怪的是回到自己的 TimeLine 上后，以前那条新发的内容就消失了。我觉得这不是 bug，而是产品策略。微信在努力保持用户粘性，不得不在用户需求和产品数据之间权衡。好吧，扯远了。。。&lt;/p&gt;
&lt;p&gt;我只保留了这俩『活儿好不粘人』的工具类入口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Images/wechat_discover.PNG?raw=true&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实扫一扫页面可以通过右上角加号更快进入，也可以去掉。小程序其实平时也基本不用，偶尔用的时候现搜，鸡肋入口。不能再干掉了，否则还不如索性干掉整个发现页面。&lt;/p&gt;
&lt;p&gt;删入口有两种思路，一种是删数据源，另一种是 hook &lt;code&gt;UITableViewDelegate&lt;/code&gt; 和 &lt;code&gt;UITableViewDataSource&lt;/code&gt;。发现页面的 VC 是 &lt;code&gt;FindFriendEntryViewController&lt;/code&gt;，发现数据源数组包含的结构体需要花功夫猜下含义，索性简单粗暴 Plan B。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 关闭朋友圈入口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CHOptimizedMethod2(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;, FindFriendEntryViewController, tableView, &lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *, tableView, heightForRowAtIndexPath, &lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *, indexPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *timelineIndexPath = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; valueForKeyPath:&lt;span class=&quot;string&quot;&gt;@&quot;m_WCTimeLineIndexPath&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([indexPath isEqual: timelineIndexPath] || indexPath.section == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;## Hide Time Line Entry ##&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; CHSuper2(FindFriendEntryViewController, tableView, tableView, heightForRowAtIndexPath, indexPath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CHOptimizedMethod2(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *, FindFriendEntryViewController, tableView, &lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *, tableView, cellForRowAtIndexPath, &lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *, indexPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *timelineIndexPath = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; valueForKeyPath:&lt;span class=&quot;string&quot;&gt;@&quot;m_WCTimeLineIndexPath&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *cell = CHSuper2(FindFriendEntryViewController, tableView, tableView, cellForRowAtIndexPath, indexPath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([indexPath isEqual: timelineIndexPath] || indexPath.section == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;## Hide Time Line Entry ##&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cell.hidden = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *subview &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; cell.subviews) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [subview removeFromSuperview];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;简单粗暴地将想要隐藏的入口 Cell 高度设为 &lt;code&gt;0&lt;/code&gt; 后发现 &lt;code&gt;subview&lt;/code&gt; 被挤出来了，我日，只好再干掉这些 &lt;code&gt;subview&lt;/code&gt;。最后记得在页面出现时刷新下 table 数据：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CHOptimizedMethod1(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;, FindFriendEntryViewController, viewDidAppear, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;, animated)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CHSuper1(FindFriendEntryViewController, viewDidAppear, animated);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; performSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(reloadData)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;修改微信运动步数-装逼党的自我修养&quot;&gt;&lt;a href=&quot;#修改微信运动步数-装逼党的自我修养&quot; class=&quot;headerlink&quot; title=&quot;修改微信运动步数 - 装逼党的自我修养&quot;&gt;&lt;/a&gt;修改微信运动步数 - 装逼党的自我修养&lt;/h3&gt;&lt;p&gt;修改微信运动步数的方法网上一搜就有好多文章，就是 hook &lt;code&gt;WCDeviceStepObject&lt;/code&gt; 的 &lt;code&gt;m7StepCount&lt;/code&gt; 方法罢了。我在这里为了更方便地装逼，当然不能 hook 时把步数写死了，随机数也不够屌，要装逼就装到位：&lt;/p&gt;
&lt;p&gt;先到设置页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Images/wechat_setting_keyboard.PNG?raw=true&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;在文本框输入个正数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Images/wechat_setting_stepcount.PNG?raw=true&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;完美：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Images/wechat_mystepcount.PNG?raw=true&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;==我就问你怕不怕==&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微信的一些列表页面是由数据来驱动 UI 的。table 对应 &lt;code&gt;MMTableViewInfo&lt;/code&gt;，section 对应 &lt;code&gt;MMTableViewSectionInfo&lt;/code&gt;，cell 对应 &lt;code&gt;MMTableViewCellInfo&lt;/code&gt;。以前做项目时也见到过类似的框架，理解起来不难。但是这种过度的封装完全改变了原有系统 API，使用者碰到问题需要深入到框架去调试，又因为是内部框架，网上也搜不到方案。所以要求框架作者规范的编码习惯和较强的能力。又扯远了，我是用 &lt;code&gt;FishConfigurationCenter&lt;/code&gt; 这个单例类来保存状态值的，目前还没在持久层写入磁盘。可以在 &lt;code&gt;MMTableViewCellInfo&lt;/code&gt; 头文件看到微信中常用的 cell 是封装好的，这里直接获取个带文本框的就行了。我顺便还加了个夜间模式的开关 cell：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CHDeclareMethod0(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;, NewSettingViewController, reloadTableData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CHSuper0(NewSettingViewController, reloadTableData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MMTableViewInfo *tableInfo = [self &lt;span class=&quot;string&quot;&gt;valueForKeyPath:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;m_tableViewInfo&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MMTableViewSectionInfo *sectionInfo = [objc_getClass(&lt;span class=&quot;string&quot;&gt;&quot;MMTableViewSectionInfo&quot;&lt;/span&gt;) sectionInfoDefaut];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MMTableViewCellInfo *nightCellInfo = [objc_getClass(&lt;span class=&quot;string&quot;&gt;&quot;MMTableViewCellInfo&quot;&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;switchCellForSel:&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;handleNightMode:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;target:&lt;/span&gt;[FishConfigurationCenter sharedInstance] &lt;span class=&quot;string&quot;&gt;title:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;夜间模式&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;on:&lt;/span&gt;[FishConfigurationCenter sharedInstance].isNightMode];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [sectionInfo &lt;span class=&quot;string&quot;&gt;addCell:&lt;/span&gt;nightCellInfo];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MMTableViewCellInfo *stepcountCellInfo = [objc_getClass(&lt;span class=&quot;string&quot;&gt;&quot;MMTableViewCellInfo&quot;&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;editorCellForSel:&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;handleStepCount:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;target:&lt;/span&gt;[FishConfigurationCenter sharedInstance] &lt;span class=&quot;string&quot;&gt;tip:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;请输入步数&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;focus:&lt;/span&gt;NO &lt;span class=&quot;string&quot;&gt;text:&lt;/span&gt;[NSString &lt;span class=&quot;string&quot;&gt;stringWithFormat:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;%ld&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)[FishConfigurationCenter sharedInstance].stepCount]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [sectionInfo &lt;span class=&quot;string&quot;&gt;addCell:&lt;/span&gt;stepcountCellInfo];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [tableInfo &lt;span class=&quot;string&quot;&gt;insertSection:&lt;/span&gt;sectionInfo &lt;span class=&quot;string&quot;&gt;At:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MMTableView *tableView = [tableInfo getTableView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [tableView reloadData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后获取步数的时候从单例里取值就可以啦：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 微信运动步数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CHOptimizedMethod0(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, WCDeviceStepObject, m7StepCount)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([FishConfigurationCenter sharedInstance].stepCount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [FishConfigurationCenter sharedInstance].stepCount = CHSuper0(WCDeviceStepObject, m7StepCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [FishConfigurationCenter sharedInstance].stepCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;小红点消除计划-我想静静&quot;&gt;&lt;a href=&quot;#小红点消除计划-我想静静&quot; class=&quot;headerlink&quot; title=&quot;小红点消除计划 - 我想静静&quot;&gt;&lt;/a&gt;小红点消除计划 - 我想静静&lt;/h3&gt;&lt;p&gt;微信真的是越来越臃肿，大有追赶 QQ 的架势，连小红点也是越来越多。『发现』页面撸的挺干净了，我就不信扫一扫入口还能有小红点（flag 已立）。『我』Tab 页里什么钱包啊卡包啊老有小红点，真烦人，老得点进去。&lt;/p&gt;
&lt;p&gt;通过查看视图层级发现小红点来源有两种，一种是 TabBar 上的小红点，另一种是 cell 上的小红点。前者是系统 API 带的，后者是微信的 &lt;code&gt;MMBadgeView&lt;/code&gt; 类实现的。&lt;/p&gt;
&lt;p&gt;微信的 &lt;code&gt;MMTabBarController&lt;/code&gt; 继承于 &lt;code&gt;UITabBarController&lt;/code&gt;，它提供了几个设置小红点的快捷方法，统统 hook 掉，屏蔽后两个『发现』和『我』上的小红点：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CHOptimizedMethod2(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;, MMTabBarController, setTabBarBadgeImage, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, arg1, forIndex, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, arg2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arg2 != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;amp;&amp;amp; arg2 != &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHSuper2(MMTabBarController, setTabBarBadgeImage, arg1, forIndex, arg2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CHOptimizedMethod2(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;, MMTabBarController, setTabBarBadgeString, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, arg1, forIndex, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, arg2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arg2 != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;amp;&amp;amp; arg2 != &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHSuper2(MMTabBarController, setTabBarBadgeString, arg1, forIndex, arg2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CHOptimizedMethod2(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;, MMTabBarController, setTabBarBadgeValue, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, arg1, forIndex, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, arg2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arg2 != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;amp;&amp;amp; arg2 != &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHSuper2(MMTabBarController, setTabBarBadgeValue, arg1, forIndex, arg2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;去除 &lt;code&gt;MMBadgeView&lt;/code&gt; 就更简单了，直接隐藏掉就好了。不直接 remove 的好处是可以保留聊天页面的小红点提醒，而其他页面的小红点被隐藏了。我猜原因是聊天页面的小红点在添加上去后会设置下 &lt;code&gt;hidden = NO&lt;/code&gt;，因为 cell 是重用的。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CHOptimizedMethod1(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt;, didAddSubview, &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *, subview)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([subview isKindOfClass:&lt;span class=&quot;built_in&quot;&gt;NSClassFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;MMBadgeView&quot;&lt;/span&gt;)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subview.hidden = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;夜间模式-辣眼睛&quot;&gt;&lt;a href=&quot;#夜间模式-辣眼睛&quot; class=&quot;headerlink&quot; title=&quot;夜间模式 - 辣眼睛&quot;&gt;&lt;/a&gt;夜间模式 - 辣眼睛&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;她说睡了，其实是躺在被窝里继续玩手机罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;夜间模式其实也就是主题适配，这个手机 QQ 玩的是最 6 的了，无人能敌。要想做一个完美的皮肤引擎是很庞大的工作，不仅是多套色值方案的存储和切换问题，还有多套图片资源的适配问题。这里由于时间仓促，只做了个很辣眼睛的夜间模式，而且切换回来需要杀进程重新进：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yulingtianxia/FishChat/blob/master/Images/wechat_about.PNG?raw=true&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;这么辣眼睛的审美会被狂吐槽，就不贴代码了，有兴趣的去项目里查看哈哈。&lt;/p&gt;
&lt;h3 id=&quot;阻止撤回消息-知道真相的我眼泪掉下来&quot;&gt;&lt;a href=&quot;#阻止撤回消息-知道真相的我眼泪掉下来&quot; class=&quot;headerlink&quot; title=&quot;阻止撤回消息 - 知道真相的我眼泪掉下来&quot;&gt;&lt;/a&gt;阻止撤回消息 - 知道真相的我眼泪掉下来&lt;/h3&gt;&lt;p&gt;有时候被撤回的消息看到了会后悔的，但这依然阻止不了我的好奇心+强迫症。&lt;/p&gt;
&lt;p&gt;在 『&lt;a href=&quot;http://yulingtianxia.com/blog/2016/05/06/Let-your-WeChat-for-Mac-never-revoke-messages/&quot;&gt;让你的微信不再被人撤回消息&lt;/a&gt;』 里我介绍过用 Hopper 逆向的方法。直接看汇编代码来的不那么直接，还是 hook OC 代码稳一些。&lt;/p&gt;
&lt;p&gt;撤回消息时会先调用 &lt;code&gt;-[CMessageMgr onRevokeMsg:]&lt;/code&gt; 方法，然后调用 &lt;code&gt;-[CMessageMgr DelMsg:MsgList: DelAll:]&lt;/code&gt; 方法删除消息。随意在撤回的时候记录下标志位就好，不影响删除消息功能。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 阻止撤回消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CHOptimizedMethod1(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;, CMessageMgr, onRevokeMsg, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, msg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [FishConfigurationCenter sharedInstance].revokeMsg = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CHSuper1(CMessageMgr, onRevokeMsg, msg);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CHDeclareMethod3(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;, CMessageMgr, DelMsg, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, arg1, MsgList, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, arg2, DelAll, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;, arg3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([FishConfigurationCenter sharedInstance].revokeMsg) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [FishConfigurationCenter sharedInstance].revokeMsg = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHSuper3(CMessageMgr, DelMsg, arg1, MsgList, arg2, DelAll, arg3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;要屏蔽-不要免打扰&quot;&gt;&lt;a href=&quot;#要屏蔽-不要免打扰&quot; class=&quot;headerlink&quot; title=&quot;要屏蔽 - 不要免打扰&quot;&gt;&lt;/a&gt;要屏蔽 - 不要免打扰&lt;/h3&gt;&lt;p&gt;详细内容请见：&lt;a href=&quot;http://yulingtianxia.com/blog/2017/03/06/How-to-hook-the-correct-method-in-reverse-engineering&quot;&gt;如何在逆向工程中 Hook 得更准 - 微信屏蔽好友&amp;amp;群消息实战&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h2&gt;&lt;p&gt;若不是时间匆忙，或许还可以让微信变得更伟大。比如加个『彻底清理缓存』按钮。平时使用微信确实有很多不爽的地方，尤其是群功能太弱太弱了。我还想加个功能就是如果对方发了超过 30s 的语音，并且对方不是妹子也不是老板不是亲戚，此时自动回复 #&amp;amp;*DF@$@(M!…..我没太听清，请你重新再发一遍？&lt;/p&gt;
&lt;p&gt;此项目仅用于逆向工程交流学习，黑产死开！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;关闭朋友圈有一年多了，突然有一天微信的策略变了，在关闭朋友圈的同时也不让别人查看自己的朋友圈了。有妹子表示看不到我朋友圈很不爽，于是我决定对微信进行一番改造！初步实现效果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关闭『发现』页面的『朋友圈』、『购物』和『游戏』入口&lt;/li&gt;
&lt;li&gt;修改微信运动步数&lt;/li&gt;
&lt;li&gt;去除各种小红点提示&lt;/li&gt;
&lt;li&gt;设置夜间模式&lt;/li&gt;
&lt;li&gt;阻止撤回消息&lt;/li&gt;
&lt;li&gt;屏蔽群&amp;amp;好友消息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;手机无需越狱&lt;/strong&gt;，项目 GitHub 地址: &lt;a href=&quot;https://github.com/yulingtianxia/FishChat&quot;&gt;FishChat&lt;/a&gt;，Make WeChat Great Again！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Reverse Engineering" scheme="http://yulingtianxia.com/tags/Reverse-Engineering/"/>
    
  </entry>
  
  <entry>
    <title>DIY 双向滑动列表</title>
    <link href="http://yulingtianxia.com/blog/2017/01/16/DIY-a-simple-two-way-list/"/>
    <id>http://yulingtianxia.com/blog/2017/01/16/DIY-a-simple-two-way-list/</id>
    <published>2017-01-16T05:23:17.000Z</published>
    <updated>2017-02-27T12:59:40.000Z</updated>
    
    <content type="html">&lt;p&gt;公司项目中有个页面是双向滑动的列表，遂用 &lt;code&gt;UIScrollView&lt;/code&gt; 手撸了之，把一些 UI 和数据上的心得记录下来。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;需求简介&quot;&gt;&lt;a href=&quot;#需求简介&quot; class=&quot;headerlink&quot; title=&quot;需求简介&quot;&gt;&lt;/a&gt;需求简介&lt;/h2&gt;&lt;p&gt;UI 上的主要内容就是一个 &lt;code&gt;UITableView&lt;/code&gt;，其中一些 cell 内会嵌套一个横向滑动的 &lt;code&gt;ListView&lt;/code&gt;，&lt;code&gt;ListView&lt;/code&gt; 中包含一些尺寸相同可点击的 ItemView，ItemView 中的图片内容需要从网络加载。&lt;/p&gt;
&lt;p&gt;去掉一些跟本文内容无关的细枝末节，可以将原型抽象如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/QQStoryMemory/原型.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;蓝色的为 ItemView，白色为 &lt;code&gt;ListView&lt;/code&gt;，灰色为 TableView。&lt;/p&gt;
&lt;p&gt;竖向滑动会有分页加载和转菊花停顿，横向滑动无分页加载停顿，要求细腻丝滑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果只是单纯一个双向滑动列表，&lt;code&gt;UICollectionView&lt;/code&gt; 完全可以胜任。&lt;/strong&gt;但是真正的需求里还掺杂着很多其他 UI 元素，所以只能 DIY 了。&lt;/p&gt;
&lt;h2 id=&quot;数据请求&quot;&gt;&lt;a href=&quot;#数据请求&quot; class=&quot;headerlink&quot; title=&quot;数据请求&quot;&gt;&lt;/a&gt;数据请求&lt;/h2&gt;&lt;h3 id=&quot;格式设计&quot;&gt;&lt;a href=&quot;#格式设计&quot; class=&quot;headerlink&quot; title=&quot;格式设计&quot;&gt;&lt;/a&gt;格式设计&lt;/h3&gt;&lt;p&gt;因为主体 UI 为竖向列表嵌套横向列表，所以两个方向都需要有数据请求。&lt;/p&gt;
&lt;p&gt;为了方便叙述，这里简化下数据格式。&lt;/p&gt;
&lt;p&gt;ItemView 对应的数据 &lt;code&gt;ItemModel&lt;/code&gt; 包含唯一标识符 &lt;code&gt;itemID&lt;/code&gt; 和图片地址 &lt;code&gt;imageURL&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;ItemModel&lt;/span&gt;: NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic, strong) NSString *itemID; &lt;span class=&quot;comment&quot;&gt;// Item 唯一标识符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic, strong) NSString *imageURL; &lt;span class=&quot;comment&quot;&gt;// 封面图片 URL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;ListView&lt;/code&gt; 对应的数据 &lt;code&gt;ListModel&lt;/code&gt; 包含分组唯一标识符 &lt;code&gt;listID&lt;/code&gt;，首屏需要展现的 Item 数据 &lt;code&gt;items&lt;/code&gt; 和列表所有 Item 的 ID &lt;code&gt;itemIDs&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;ListModel&lt;/span&gt;: NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic, strong) NSString *listID; &lt;span class=&quot;comment&quot;&gt;// List 唯一标识符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic, strong) NSArray&amp;lt;ItemModel *&amp;gt; *items; &lt;span class=&quot;comment&quot;&gt;// 包含首屏前几个 Item 数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt; (nonatomic, strong) NSArray&amp;lt;NSString *&amp;gt; *itemIDs; &lt;span class=&quot;comment&quot;&gt;// 包含整行 List 所有 Item 的 ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;竖向滑动时，TableView 会从后台分页获取 &lt;code&gt;ListModel&lt;/code&gt; 数组。&lt;code&gt;ListModel&lt;/code&gt; 中的 &lt;code&gt;items&lt;/code&gt; 填充了初始数据（此时不需要横向滑动拉取数据）。&lt;/p&gt;
&lt;p&gt;之所以不干脆在 &lt;code&gt;ListModel&lt;/code&gt; 装填所有 &lt;code&gt;ItemModel&lt;/code&gt;，是为了节省一次请求的数据流量，降低失败率。因为第一次展示页面时只需要填充前几个 ItemView 的数据，等用户横向滑动后再继续根据 &lt;code&gt;itemIDs&lt;/code&gt; 请求滑动到的 ItemView 对应数据。&lt;/p&gt;
&lt;h3 id=&quot;请求时机&quot;&gt;&lt;a href=&quot;#请求时机&quot; class=&quot;headerlink&quot; title=&quot;请求时机&quot;&gt;&lt;/a&gt;请求时机&lt;/h3&gt;&lt;p&gt;因为有了 &lt;code&gt;ListView&lt;/code&gt; 中所有 ItemView 对应的 ID，所以横向滑动没有分页逻辑，就没有转菊花的停顿时间用来请求网络数据和等待接受处理数据。虽然可以用 ID 请求到对应的 &lt;code&gt;ItemModel&lt;/code&gt;，但肯定不能在 &lt;code&gt;UITableView&lt;/code&gt; 的 datasource 回调中为每个 cell 去单独请求数据。所以 &lt;code&gt;ListView&lt;/code&gt; 即便直接使用 &lt;code&gt;UITableView&lt;/code&gt; 或 &lt;code&gt;UICollectionView&lt;/code&gt;，也无法享受到它带来的便捷，数据请求逻辑依然需要自己在 &lt;code&gt;UIScrollViewDelegate&lt;/code&gt; 中实现。&lt;strong&gt;所以 &lt;code&gt;ListView&lt;/code&gt; 是继承 &lt;code&gt;UIScrollView&lt;/code&gt; 自己 DIY 了一个横向滑动列表。如何合理控制数据请求次数成为了性能优化的重点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;文中示例代码均经过简化，去除了无关信息，并使用 MRC。&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; `&lt;span class=&quot;title&quot;&gt;ListView&lt;/span&gt;` : &lt;span class=&quot;title&quot;&gt;UIScrollView&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, retain) ListModel *model;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, retain) &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;&amp;lt;ItemModel *&amp;gt; *itemModels;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; itemWidth = &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// ItemView 宽度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; itemHeight = &lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// ItemView 高度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; itemGap = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// ItemView 间距&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; itemFirstToLeft = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 最左边的 ItemView 的 leftMargin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#pragma mark - UIScrollViewDelegate&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)scrollViewDidScroll:(&lt;span class=&quot;built_in&quot;&gt;UIScrollView&lt;/span&gt; *)scrollView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (scrollView.contentSize.width == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算滚动的区间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; indexLeft = floorf((scrollView.contentOffset.x - itemFirstToLeft) / (itemWidth + itemGap)) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    indexLeft = MAX(indexLeft, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    indexLeft = MIN(indexLeft, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.model.itemIDs.count - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; indexRight = ceilf((scrollView.contentOffset.x - itemFirstToLeft + scrollView.width) / (itemWidth + itemGap));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    indexRight = MAX(indexRight, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    indexRight = MIN(indexRight, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.model.itemIDs.count - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; length = indexRight - indexLeft + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    length = MAX(length, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    length = MIN(length, &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.model.itemIDs.count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 加载区间内的 Item&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; loadItems:&lt;span class=&quot;built_in&quot;&gt;NSMakeRange&lt;/span&gt;(indexLeft, length)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)scrollViewWillBeginDragging:(&lt;span class=&quot;built_in&quot;&gt;UIScrollView&lt;/span&gt; *)scrollView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; reloadItemModels];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)scrollViewDidEndDecelerating:(&lt;span class=&quot;built_in&quot;&gt;UIScrollView&lt;/span&gt; *)scrollView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; reloadItemModels];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 在指定范围内加载可重用 Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 针对本地没有数据的 itemID 请求数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @param range 加载的范围&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)loadItems:(&lt;span class=&quot;built_in&quot;&gt;NSRange&lt;/span&gt;)range&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 省略...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 刷新页面数据，如果页面上有数据缺失，则再次请求数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)reloadItemModels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 省略...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 省略一堆逻辑...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;ListView&lt;/code&gt; 中直接请求数据的位置有三处，但 &lt;code&gt;loadItems:&lt;/code&gt; 和 &lt;code&gt;reloadItemModels&lt;/code&gt; 这两个方法会被其他地方调用，所以可能间接请求数据的时机还是很多的。&lt;code&gt;reloadItemModels&lt;/code&gt; 方法也会在接收到网络数据时被调用。&lt;code&gt;loadItems:&lt;/code&gt; 计算滚动时屏幕上包含 &lt;code&gt;ItemView&lt;/code&gt; 的区间的方法完全是根据 frame 坐标来计算的，并且会预留出屏幕外左右各一个 &lt;code&gt;ItemView&lt;/code&gt;。&lt;code&gt;reloadItemModels&lt;/code&gt; 方法只是重新装载下数据，因为 &lt;code&gt;itemID&lt;/code&gt; 列表是完整的，但每个 &lt;code&gt;itemID&lt;/code&gt; 不一定都缓存到了对应的 &lt;code&gt;ItemModel&lt;/code&gt;，所以这个方法还对缺失数据进行请求，可以理解为『强刷』。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UIScrollViewDelegate&lt;/code&gt; 中实现策略如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在列表滚动过程中计算当前显示在屏幕上的 ItemView 的区间，并调用 &lt;code&gt;loadItems:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在列表即将开始滚动和停止滚动的时刻，调用 &lt;code&gt;reloadItemModels&lt;/code&gt; 重新加载数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在计算需要加载的 &lt;code&gt;range&lt;/code&gt; 的时候需要注意一些边界数值的处理，擅用 &lt;code&gt;floorf&lt;/code&gt; 和 &lt;code&gt;ceilf&lt;/code&gt; 函数进行取舍，并用 &lt;code&gt;MAX()&lt;/code&gt; 和 &lt;code&gt;MIN()&lt;/code&gt; 来检查边界值合法性。&lt;/p&gt;
&lt;h2 id=&quot;可重用的-ItemView&quot;&gt;&lt;a href=&quot;#可重用的-ItemView&quot; class=&quot;headerlink&quot; title=&quot;可重用的 ItemView&quot;&gt;&lt;/a&gt;可重用的 &lt;code&gt;ItemView&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;需要自己实现一个类似 &lt;code&gt;UICollectionView&lt;/code&gt; 的 item 重用机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/QQStoryMemory/reusableitem.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在用户横向滑动列表时，需要更新此时某个区间的 UI 和数据。这个任务是在 &lt;code&gt;loadItems:&lt;/code&gt; 中实现的，原理是计算出需要被加载的 itemID 数组，并与已有的数据进行比较。将不再需要显示在屏幕上的 &lt;code&gt;ItemView&lt;/code&gt; 进行回收（enqueue），并从根据 itemID 添加 &lt;code&gt;ItemView&lt;/code&gt; 对象（dequeue）。因为一开始只加载了首屏的 &lt;code&gt;ItemModel&lt;/code&gt; 数组，所以还需要对本地缓存中缺失的数据进行请求。&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 在指定范围内加载可重用 Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 针对本地没有数据的 itemID 请求数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @param range 加载的范围&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)loadItems:(NSRange)range&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray&amp;lt;NSString *&amp;gt; *&lt;span class=&quot;keyword&quot;&gt;itemIDsToLoad &lt;/span&gt;= [[&lt;span class=&quot;keyword&quot;&gt;self.model.itemIDs &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;subarrayWithRange:range] &lt;/span&gt;mutableCopy]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray&amp;lt;&lt;span class=&quot;keyword&quot;&gt;ItemView &lt;/span&gt;*&amp;gt; *&lt;span class=&quot;keyword&quot;&gt;itemsToEnqueue &lt;/span&gt;= [NSMutableArray array]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 比较需要加载的 &lt;span class=&quot;keyword&quot;&gt;itemID &lt;/span&gt;数组和已经显示过的 &lt;span class=&quot;keyword&quot;&gt;itemID &lt;/span&gt;数组，计算出需要新添加的 &lt;span class=&quot;keyword&quot;&gt;itemID &lt;/span&gt;和不再需要显示而被回收的 &lt;span class=&quot;keyword&quot;&gt;Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    for (&lt;span class=&quot;keyword&quot;&gt;ItemView &lt;/span&gt;*&lt;span class=&quot;keyword&quot;&gt;item &lt;/span&gt;in &lt;span class=&quot;keyword&quot;&gt;self.visibleItems) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSString *&lt;span class=&quot;keyword&quot;&gt;itemIDAlreadyLoad &lt;/span&gt;= nil&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (NSString *&lt;span class=&quot;keyword&quot;&gt;itemIDToLoad &lt;/span&gt;in &lt;span class=&quot;keyword&quot;&gt;itemIDsToLoad) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;meta&quot;&gt;if&lt;/span&gt; ([&lt;span class=&quot;keyword&quot;&gt;itemIDToLoad &lt;/span&gt;isEqualToString:&lt;span class=&quot;keyword&quot;&gt;item.itemID]) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;itemIDAlreadyLoad &lt;/span&gt;= &lt;span class=&quot;keyword&quot;&gt;itemIDToLoad;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;keyword&quot;&gt;itemIDAlreadyLoad) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;keyword&quot;&gt;itemsToEnqueue &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;addObject:item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;keyword&quot;&gt;itemIDsToLoad &lt;/span&gt;removeObject:&lt;span class=&quot;keyword&quot;&gt;itemIDAlreadyLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 回收不需要显示的 &lt;span class=&quot;keyword&quot;&gt;Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    for (&lt;span class=&quot;keyword&quot;&gt;ItemView &lt;/span&gt;*&lt;span class=&quot;keyword&quot;&gt;item &lt;/span&gt;in &lt;span class=&quot;keyword&quot;&gt;itemsToEnqueue) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;item &lt;/span&gt;removeFromSuperview]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self.visibleItems &lt;/span&gt;removeObject:&lt;span class=&quot;keyword&quot;&gt;item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        [&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;enqueueReusableItem:&lt;span class=&quot;keyword&quot;&gt;item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 添加需要显示的 &lt;span class=&quot;keyword&quot;&gt;Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    NSMutableArray&amp;lt;NSString *&amp;gt; *&lt;span class=&quot;keyword&quot;&gt;itemIDsToRequest &lt;/span&gt;= [NSMutableArray array]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (NSString *&lt;span class=&quot;keyword&quot;&gt;itemID &lt;/span&gt;in &lt;span class=&quot;keyword&quot;&gt;itemIDsToLoad) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;if&lt;/span&gt; (![&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;addItemViewWithID:itemID]) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;keyword&quot;&gt;itemIDsToRequest &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;addObject:itemID];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 针对本地没有数据的 &lt;span class=&quot;keyword&quot;&gt;itemID &lt;/span&gt;请求数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;itemIDsToRequest.count &lt;/span&gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 向后台请求 &lt;span class=&quot;keyword&quot;&gt;itemIDsToRequest &lt;/span&gt;对应数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;itemIDsToLoad &lt;/span&gt;release]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;addItemViewWithID:&lt;/code&gt; 负责从 reusable items 获取 &lt;code&gt;ItemView&lt;/code&gt; 并设置 &lt;code&gt;frame&lt;/code&gt; 添加到 &lt;code&gt;ListView&lt;/code&gt; 中。因为 &lt;code&gt;ItemView&lt;/code&gt; 是重用的，所以如果 dequeue 出的对象正好是上一次刚刚 enqueue 的对象，那么就不用重新填充数据了；否则需要重置 &lt;code&gt;ItemView&lt;/code&gt; 的占位图，并填充新数据。&lt;code&gt;ItemView&lt;/code&gt; 被填充了数据后会对数据进行处理，比如异步拉取图片资源。&lt;/p&gt;
&lt;p&gt;当无法向 &lt;code&gt;ItemView&lt;/code&gt; 填充数据时，&lt;code&gt;addItemViewWithID:&lt;/code&gt; 会返回 &lt;code&gt;NO&lt;/code&gt;，暗示调用方需要用该 itemID 请求数据。&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 添加 itemID 对应的 Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @param itemID @param itemID 视频 ID&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @return 是否成功向 Item 填充数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;BOOL)addItemViewWithID:(NSString &lt;/span&gt;*)&lt;span class=&quot;keyword&quot;&gt;itemID&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ItemView &lt;/span&gt;*&lt;span class=&quot;keyword&quot;&gt;item &lt;/span&gt;= [&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;dequeueReusableItem]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSUInteger index = [&lt;span class=&quot;keyword&quot;&gt;self.model.itemIDs &lt;/span&gt;indexOfObject:&lt;span class=&quot;keyword&quot;&gt;itemID];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGFloat originX = &lt;span class=&quot;keyword&quot;&gt;itemFirstToLeft &lt;/span&gt;+ index * (&lt;span class=&quot;keyword&quot;&gt;itemWidth &lt;/span&gt;+ &lt;span class=&quot;keyword&quot;&gt;itemGap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;item.frame &lt;/span&gt;= CGRectMake(originX, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;itemWidth, &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;itemHeight);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    [&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;addSubview:item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    [&lt;span class=&quot;keyword&quot;&gt;self.visibleItems &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;addObject:item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;meta&quot;&gt;if&lt;/span&gt; ([&lt;span class=&quot;keyword&quot;&gt;item.itemID &lt;/span&gt;isEqualToString:&lt;span class=&quot;keyword&quot;&gt;itemID]) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return YES&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;item &lt;/span&gt;useDefaultCover]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;item.itemID &lt;/span&gt;= &lt;span class=&quot;keyword&quot;&gt;itemID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (&lt;span class=&quot;keyword&quot;&gt;ItemModel &lt;/span&gt;*model in &lt;span class=&quot;keyword&quot;&gt;self.itemModels)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;if&lt;/span&gt; ([model.&lt;span class=&quot;keyword&quot;&gt;itemID &lt;/span&gt;isEqualToString:&lt;span class=&quot;keyword&quot;&gt;itemID])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;item.model &lt;/span&gt;= model&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return YES&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return NO&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可重用 Item 列表的 dequeue 和 enqueue 操作实现如下，dequeue 也负责在可重用列表不够用时创建新的 &lt;code&gt;ItemView&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 从可重用队列中回收 Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @param item  回收的 Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)enqueueReusableItem:(&lt;span class=&quot;keyword&quot;&gt;ItemView &lt;/span&gt;*)&lt;span class=&quot;keyword&quot;&gt;item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self.reusableItems &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;addObject:item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 从可重用队列中取出 Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; @return  取出的 Item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;ItemView &lt;/span&gt;*)dequeueReusableItem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ItemView &lt;/span&gt;*&lt;span class=&quot;keyword&quot;&gt;item &lt;/span&gt;= [&lt;span class=&quot;keyword&quot;&gt;self.reusableItems.firstObject &lt;/span&gt;retain]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;item) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self.reusableItems &lt;/span&gt;removeObject:&lt;span class=&quot;keyword&quot;&gt;item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;item &lt;/span&gt;= [&lt;span class=&quot;keyword&quot;&gt;ItemView &lt;/span&gt;new]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [&lt;span class=&quot;keyword&quot;&gt;item &lt;/span&gt;autorelease]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;感受&quot;&gt;&lt;a href=&quot;#感受&quot; class=&quot;headerlink&quot; title=&quot;感受&quot;&gt;&lt;/a&gt;感受&lt;/h2&gt;&lt;p&gt;不得不承认一开始想 DIY 个列表还是有装逼嫌疑的，但后来发现还是 DIY 来的爽，好多事情都掌握在自己手里，批量请求数据也更方便（虽说直接用 &lt;code&gt;UICollectionView&lt;/code&gt; 也可以办到，只是有些绕，且依然得自己实现 &lt;code&gt;UIScrollViewDelegate&lt;/code&gt;）。最大的收获就是对 &lt;code&gt;UIScrollView&lt;/code&gt; 的理解更深刻，对 &lt;code&gt;UITableView&lt;/code&gt; 的实现机制有了掌握。&lt;/p&gt;
&lt;p&gt;还有就是在做之前把一些事情想的太简单了，然后开始动工后就会发现：卧槽还真就是这么简单！23333333&lt;/p&gt;
&lt;p&gt;其实还是遇到了一些项目中的 API 上的坑的，比如工程里的异步加载图片 ImageView 会忽略第二次相同的 url 请求，导致调试时花了些时间。&lt;/p&gt;
&lt;p&gt;曾经还设想把可重用的范围扩大到整个屏幕，也就是屏幕上所有横向滑动的 &lt;code&gt;ListView&lt;/code&gt; 全都共用一个可重用列表。但后来计算一下这样做收益不高，毕竟横向滑动的 &lt;code&gt;ListView&lt;/code&gt; 在正常滑动时可重用列表中会有一到两个 &lt;code&gt;ItemView&lt;/code&gt; 对象，而全屏最多同时存在 5 个 &lt;code&gt;ListView&lt;/code&gt;，节省的内存很有限。&lt;/p&gt;
&lt;p&gt;其实还有许多细节实现没有叙述，比如记录 &lt;code&gt;ListView&lt;/code&gt; 上次横向滑动位置，因为 &lt;code&gt;ListView&lt;/code&gt; 是加在全屏 TableView 的每个 cell 中，而 cell 也是重用的，所以上次滑动偏移是需要每次 cell 消失时记录和 cell 出现时刷新的。&lt;/p&gt;
&lt;p&gt;在公司项目用了快半年的 MRC，有时还要切换到 ARC 做做其他事情，或者来一发 Swift 玩票儿，真是一种奇(dan)妙(teng)的体验。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;公司项目中有个页面是双向滑动的列表，遂用 &lt;code&gt;UIScrollView&lt;/code&gt; 手撸了之，把一些 UI 和数据上的心得记录下来。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多媒体编辑模块架构设计</title>
    <link href="http://yulingtianxia.com/blog/2016/12/29/Multimedia-Edit-Module-Architecture-Design/"/>
    <id>http://yulingtianxia.com/blog/2016/12/29/Multimedia-Edit-Module-Architecture-Design/</id>
    <published>2016-12-29T01:37:04.000Z</published>
    <updated>2016-12-28T15:48:23.000Z</updated>
    
    <content type="html">&lt;p&gt;本文主要讲了下我在工作时对项目中多媒体编辑模块的架构设计心得，并剖析了一部分原理。目前框架主流程已经验证跑通，所以把一些关键的思想和概念记录下来。涉及到公司机密的已经略去，只说说思想，代码也就不公开了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;多媒体编辑模块重构概要&quot;&gt;&lt;a href=&quot;#多媒体编辑模块重构概要&quot; class=&quot;headerlink&quot; title=&quot;多媒体编辑模块重构概要&quot;&gt;&lt;/a&gt;多媒体编辑模块重构概要&lt;/h2&gt;&lt;p&gt;多媒体编辑包含了对图片和视频的编辑，比如在某个位置添加一些图片或者涂鸦等操作。这里讲的其实是一个跟移动端平台无关的架构，包含了操作面板组件化、手势引擎、业务解耦等内容。具体对图片和视频等内容的渲染等操作不做讨论。&lt;/p&gt;
&lt;p&gt;这里设想的场景是：用户录制好一段视频或拍照后进入编辑模块，编辑面板下方有几个按钮，点击后可以进入某种编辑模式，比如添加文字、表情、涂鸦、音乐等编辑功能。右下角会有个发表按钮，左上角有个重拍按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MultimediaEdit/原型.png&quot; alt=&quot;原型&quot;&gt;&lt;/p&gt;
&lt;p&gt;设计一个模块首先要明确它的职责，输入和输出都是什么。多媒体编辑简介如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MultimediaEdit/简介.png&quot; alt=&quot;简介&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;组件化总体设计&quot;&gt;&lt;a href=&quot;#组件化总体设计&quot; class=&quot;headerlink&quot; title=&quot;组件化总体设计&quot;&gt;&lt;/a&gt;组件化总体设计&lt;/h2&gt;&lt;p&gt;在明确了多媒体编辑模块的本质是 UI 操作面板后，首先要从视图层级入手，设计好整个模块各职责对应的层级，并兼顾触摸事件的传递。在视图层级交互策略设计好后，就可以进行 UML 的设计了。这次，要拒绝不规范的编程习惯，并对耦合几乎零容忍！将编辑组件与 EditView 解耦，把一些基础逻辑抽象出来，与具体业务剥离开。减少了多人改同一份代码带来的风险，并能更快定位bug来源。&lt;/p&gt;
&lt;h3 id=&quot;视图层级图&quot;&gt;&lt;a href=&quot;#视图层级图&quot; class=&quot;headerlink&quot; title=&quot;视图层级图&quot;&gt;&lt;/a&gt;视图层级图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MultimediaEdit/框架总体视图层级设计.png&quot; alt=&quot;框架总体视图层级设计&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;UML-架构图&quot;&gt;&lt;a href=&quot;#UML-架构图&quot; class=&quot;headerlink&quot; title=&quot;UML 架构图&quot;&gt;&lt;/a&gt;UML 架构图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MultimediaEdit/多媒体编辑重构UML.png&quot; alt=&quot;多媒体编辑重构UML&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;手势识别引擎&quot;&gt;&lt;a href=&quot;#手势识别引擎&quot; class=&quot;headerlink&quot; title=&quot;手势识别引擎&quot;&gt;&lt;/a&gt;手势识别引擎&lt;/h2&gt;&lt;p&gt;手势引擎既要『大一统』式地管理，又要与具体响应手势的元素视图进行解耦，做法就是统一接口，制定标准。所有想响应手势的视图都需要继承 &lt;code&gt;InteractionElementView&lt;/code&gt; 或者将其作为 &lt;code&gt;parentView&lt;/code&gt;。可以配置元素对象来实现对手势响应的规则，更加灵活自如，而且零耦合。有关手势命中区域的计算方法请阅读我之前发表的一篇文章：&lt;a href=&quot;http://yulingtianxia.com/blog/2016/08/29/Some-Experience-of-Gesture/&quot;&gt;处理手势冲突和错乱的一点经验&lt;/a&gt;，我在这里详细阐述了各种情形下的手势命中计算方法。下图为手势识别引擎策略的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MultimediaEdit/手势识别引擎.png&quot; alt=&quot;手势识别引擎&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;组件设计&quot;&gt;&lt;a href=&quot;#组件设计&quot; class=&quot;headerlink&quot; title=&quot;组件设计&quot;&gt;&lt;/a&gt;组件设计&lt;/h2&gt;&lt;h3 id=&quot;组件与元素&quot;&gt;&lt;a href=&quot;#组件与元素&quot; class=&quot;headerlink&quot; title=&quot;组件与元素&quot;&gt;&lt;/a&gt;组件与元素&lt;/h3&gt;&lt;p&gt;组件的 &lt;code&gt;baseZIndex&lt;/code&gt; 定义了组件所创建元素的 &lt;code&gt;zIndex&lt;/code&gt; 的基础值。元素容器会有一个计数器 &lt;code&gt;nextZIndexOfElement&lt;/code&gt;，每次获取时会自动加一。所以元素的 &lt;code&gt;zIndex&lt;/code&gt; 等于 &lt;code&gt;baseZIndex&lt;/code&gt; 与 &lt;code&gt;nextZIndexOfElement&lt;/code&gt; 之和。&lt;/p&gt;
&lt;p&gt;之所以要给元素定义 &lt;code&gt;zIndex&lt;/code&gt; 这个属性是考虑到某些元素可能会在元素容器与组件容器之间切换层级。比如文字元素就是这种例子。所以当某个元素重新添加到元素容器后，元素容器需要根据每个元素的 &lt;code&gt;zIndex&lt;/code&gt; 属性来重新排序层级顺序。&lt;/p&gt;
&lt;h3 id=&quot;组件与-EditView&quot;&gt;&lt;a href=&quot;#组件与-EditView&quot; class=&quot;headerlink&quot; title=&quot;组件与 EditView&quot;&gt;&lt;/a&gt;组件与 EditView&lt;/h3&gt;&lt;p&gt;组件不是必须要向 &lt;code&gt;MultimediaEditView&lt;/code&gt; 中的元素容器中添加元素的，它也可以不创建任何元素，而是直接操作多媒体资源（比如选择一些滤镜），也可以是做些其他事情，比如保存多媒体资源到本地。&lt;strong&gt;&lt;code&gt;MultimediaEditView&lt;/code&gt; 只是给组件提供了一个操作入口，而组件为 &lt;code&gt;MultimediaEditView&lt;/code&gt; 提供了很强的拓展性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;组件与数据&quot;&gt;&lt;a href=&quot;#组件与数据&quot; class=&quot;headerlink&quot; title=&quot;组件与数据&quot;&gt;&lt;/a&gt;组件与数据&lt;/h3&gt;&lt;p&gt;每个组件都有自己唯一的 ID，默认是类名。组件的按钮被点击后，会将自己设为 &lt;code&gt;currentEditComponent&lt;/code&gt;，&lt;code&gt;MultimediaEditView&lt;/code&gt; 会调用上一个组件的 &lt;code&gt;stop&lt;/code&gt; 方法，然后调用新组件的 &lt;code&gt;start&lt;/code&gt; 方法。组件在 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 方法中完成组件内容的装载和卸载。组件产生的用户数据可以存放在 &lt;code&gt;componentInfos&lt;/code&gt; 中，可用于之后的发表等流程。&lt;code&gt;reset&lt;/code&gt; 方法用于清除组件数据以及持有的状态和元素。继承于 &lt;code&gt;MultimediaEditComponent&lt;/code&gt; 的子类需要覆写这些主要的方法。组件也可以直接操作多媒体资源，所以也可能会跟其他模块有数据流动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MultimediaEdit/组件的数据流动.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;业务方&quot;&gt;&lt;a href=&quot;#业务方&quot; class=&quot;headerlink&quot; title=&quot;业务方&quot;&gt;&lt;/a&gt;业务方&lt;/h2&gt;&lt;p&gt;具体的业务一般是需要继承 &lt;code&gt;MultimediaEditView&lt;/code&gt; 加入一些自己特有的逻辑，并在自己的 ViewController 创建和注册组件。如果某个业务需要对具体的组件进行个性化修改，我建议具体的组件也需要再继承一下。如果以后所有业务统一组件的行为，那也可以再把之前子类的逻辑迁移回基类。这样做的好处是避免某个业务直接修改基类影响到所有业务的风险，之前就有过先例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7ni3rk.com1.z0.glb.clouddn.com/MultimediaEdit/业务方的使用.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲了下我在工作时对项目中多媒体编辑模块的架构设计心得，并剖析了一部分原理。目前框架主流程已经验证跑通，所以把一些关键的思想和概念记录下来。涉及到公司机密的已经略去，只说说思想，代码也就不公开了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yulingtianxia.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>pbxprojHelper--Xcode工程文件助手</title>
    <link href="http://yulingtianxia.com/blog/2016/11/28/pbxprojHelper/"/>
    <id>http://yulingtianxia.com/blog/2016/11/28/pbxprojHelper/</id>
    <published>2016-11-27T16:03:08.000Z</published>
    <updated>2016-11-27T17:32:16.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pbxprojHelper&lt;/a&gt; 可以帮你快速配置 Xcode 工程文件，省去麻烦的人工手动操作。项目开源，使用 Swift 开发，详细介绍请见&lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper/blob/master/Documentation/README_ZH.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用说明&lt;/a&gt;。除了 Mac App 外还提供了命令行工具 &lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper/releases/download/1.1.3/pbxproj&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;pbxproj&lt;/code&gt;&lt;/a&gt;，它集成了 &lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pbxprojHelper&lt;/a&gt; 的核心功能，同样简易实用。&lt;/p&gt;
&lt;p&gt;因为 &lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper/blob/master/Documentation/README_ZH.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;README_ZH&lt;/a&gt; 中对使用方法已经讲得很详细了，这里重点说的是产品方案和技术实现。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;产品方案&quot;&gt;&lt;a href=&quot;#产品方案&quot; class=&quot;headerlink&quot; title=&quot;产品方案&quot;&gt;&lt;/a&gt;产品方案&lt;/h2&gt;&lt;h3 id=&quot;为什么造这个工具？&quot;&gt;&lt;a href=&quot;#为什么造这个工具？&quot; class=&quot;headerlink&quot; title=&quot;为什么造这个工具？&quot;&gt;&lt;/a&gt;为什么造这个工具？&lt;/h3&gt;&lt;p&gt;在开发公司的项目时，check out 代码到本地后需要修改工程文件。比如更改证书和 Bundle Identifier、删除一些编译不过的 Target，修改 Build Settings 等配置。重复手动修改这些配置的场景很多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次 check out 新的分支，需要使用自己的配置。&lt;/li&gt;
&lt;li&gt;增删代码文件前会先 revert project.pbxproj 文件，修改完成后再 commit。此时本地工程文件需要重新配置。&lt;/li&gt;
&lt;li&gt;没有增删代码文件但 project.pbxproj 文件有冲突（conflict），需要先 revert 后重新配置工程文件。&lt;/li&gt;
&lt;li&gt;一些自动化流程（比如 CI）每次执行都需要特定的编译选项和证书来编包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而我本人最常遇到的场景是 1 和 2，因为不能用公司的证书配置来编译，一些跟苹果开发者账号相关的功能导致一些 target 编译不过，还有些 debug 模式下需要设置的编译选项。所以每次都需要手动修改 Xcode 工程配置，很是麻烦。&lt;/p&gt;
&lt;h3 id=&quot;需求！&quot;&gt;&lt;a href=&quot;#需求！&quot; class=&quot;headerlink&quot; title=&quot;需求！&quot;&gt;&lt;/a&gt;需求！&lt;/h3&gt;&lt;p&gt;可以说开发这个工具一开始完全就是为了解决我个人的痛点的，基本没考虑做成功能强大的通用工具。虽然做的事情比较小众，但也能满足一批苹果开发者的需求了。我把需求分为以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将程序员对工程文件做出的配置修改记录下来，并保存成 JSON 文件&lt;/li&gt;
&lt;li&gt;下次使用时直接导入 JSON 文件，将配置修改应用到当前的工程文件上&lt;/li&gt;
&lt;li&gt;支持回滚操作&lt;/li&gt;
&lt;li&gt;支持工程文件内容的预览、过滤&lt;/li&gt;
&lt;li&gt;快速切换最近使用的工程&lt;/li&gt;
&lt;li&gt;提供命令行工具&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以说 1 和 2 是刚需，也是常用功能。3、4 和 5 是辅助功能，6 是附加需求。我平时最常碰到的需求点就是 2 和 5 了。&lt;/p&gt;
&lt;h2 id=&quot;技术实现&quot;&gt;&lt;a href=&quot;#技术实现&quot; class=&quot;headerlink&quot; title=&quot;技术实现&quot;&gt;&lt;/a&gt;技术实现&lt;/h2&gt;&lt;p&gt;关于 Xcode 工程文件的介绍，请参考我之前写的 &lt;a href=&quot;http://yulingtianxia.com/blog/2016/09/28/Let-s-Talk-About-project-pbxproj/&quot;&gt;Let’s Talk About project.pbxproj&lt;/a&gt;。本篇文章可以算作是它的续集。&lt;/p&gt;
&lt;p&gt;我把工程文件相关的底层方法都封装在 &lt;code&gt;PropertyListHandler&lt;/code&gt; 类中，它们跟界面无关。还有一些工具类和方法写到 &lt;code&gt;Utils&lt;/code&gt; 文件中。&lt;/p&gt;
&lt;h3 id=&quot;对比工程文件&quot;&gt;&lt;a href=&quot;#对比工程文件&quot; class=&quot;headerlink&quot; title=&quot;对比工程文件&quot;&gt;&lt;/a&gt;对比工程文件&lt;/h3&gt;&lt;p&gt;想要记录工程文件的修改是很难的，所以只能是比较下两个工程文件的差异。这里不是对比文件那种简单的 &lt;code&gt;diff&lt;/code&gt; 操作，而是要记录具体针对哪个配置项做了『增删改』。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工程文件的内容可以比作一颗多叉树，的根节点是字典，其余中间节点都是字典的键。数组的元素肯定是字符串（叶子节点），字典的键值对则可能继续拓展出子树，也可能是叶子节点。&lt;/strong&gt;在拿到两个工程文件的数据后，就需要对两棵树的每个层级进行对比。对比两颗树的差异算法不难实现，核心思想是：&lt;strong&gt;在对比中间节点时，如果内容相同那就递归比较下一层，否则就记为『增』或『删』&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而比较同一层级中间节点的差异，直接用 &lt;code&gt;Set&lt;/code&gt; 是最方便的了。我将两棵树的差异保存在字典 &lt;code&gt;difference&lt;/code&gt; 中，在内嵌方法中又实现了个尾递归。递归过程中需要记录中间节点作为路径，因为生成的路径需要保存到对比结果中。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// 将 project 与 other project 做比较&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - parameter project1: 作为比较的 project&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - parameter project2: 被参照的 project&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - returns: project1 相对于 project2 的变化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compare&lt;/span&gt;(&lt;span class=&quot;title&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;project1&lt;/span&gt;: [&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Any&lt;/span&gt;], &lt;span class=&quot;title&quot;&gt;withOtherProject&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;project2&lt;/span&gt;: [&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Any&lt;/span&gt;]) -&amp;gt; &lt;span class=&quot;title&quot;&gt;Any&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; difference = [&lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;: [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;](), &lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;: [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;](), &lt;span class=&quot;string&quot;&gt;&quot;modify&quot;&lt;/span&gt;: [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;]()]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/// 将两个数据对象作递归比较，将最深层次节点的差异保存到 difference 中。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;///&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/// - Parameters:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;///   - data1: 第一个数据对象，数组或字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;///   - data2: 第二个数据对象，数组或字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;///   - parentKeyPath: 父路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data data1: Any?, withOtherData data2: Any?, parentKeyPath: String)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dictionary1 = data1 &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;], &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dictionary2 = data2 &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; set1 = &lt;span class=&quot;type&quot;&gt;Set&lt;/span&gt;(dictionary1.keys)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; set2 = &lt;span class=&quot;type&quot;&gt;Set&lt;/span&gt;(dictionary2.keys)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; set1.subtracting(set2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; value = dictionary1[key], difference[&lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;]?[parentKeyPath] == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    difference[&lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;]?[parentKeyPath] = [key: value]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; value = dictionary1[key], &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; insertDictionary = difference[&lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;]?[parentKeyPath] &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    insertDictionary[key] = value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    difference[&lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;]?[parentKeyPath] = insertDictionary&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; set2.subtracting(set1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; difference[&lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;]?[parentKeyPath] == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    difference[&lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;]?[parentKeyPath] = [key]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; removeArray = difference[&lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;]?[parentKeyPath] &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    removeArray.append(key)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    difference[&lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;]?[parentKeyPath] = removeArray&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; set1.intersection(set2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; keyPath = parentKeyPath == &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; ? key : &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(parentKeyPath)&lt;/span&gt;.&lt;span class=&quot;subst&quot;&gt;\(key)&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// values are both String, leaf node&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; str1 = dictionary1[key] &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; str2 = dictionary2[key] &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; str1 != str2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        difference[&lt;span class=&quot;string&quot;&gt;&quot;modify&quot;&lt;/span&gt;]?[keyPath] = str1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// continue compare subtrees&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    compare(data: dictionary1[key], withOtherData: dictionary2[key], parentKeyPath: keyPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; array1 = data1 &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;], &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; array2 = data2 &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; set1 = &lt;span class=&quot;type&quot;&gt;Set&lt;/span&gt;(array1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; set2 = &lt;span class=&quot;type&quot;&gt;Set&lt;/span&gt;(array2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; element &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; set1.subtracting(set2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; difference[&lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;]?[parentKeyPath] == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    difference[&lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;]?[parentKeyPath] = [element]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; insertArray = difference[&lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;]?[parentKeyPath] &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    insertArray.append(element)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    difference[&lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;]?[parentKeyPath] = insertArray&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; element &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; set2.subtracting(set1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; difference[&lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;]?[parentKeyPath] == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    difference[&lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;]?[parentKeyPath] = [element]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; removeArray = difference[&lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;]?[parentKeyPath] &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    removeArray.append(element)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    difference[&lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;]?[parentKeyPath] = removeArray&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compare(data: project1, withOtherData: project2, parentKeyPath: &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; difference&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段看似很长的代码其实逻辑超级简单，就是分别针对字典和数组两种情况进行比较而已，弱智的一逼。需要注意的是数组内容作为叶子节点，只存在『增』和『删』两种情况。&lt;/p&gt;
&lt;p&gt;每次递归都将 &lt;code&gt;parentKeyPath&lt;/code&gt; 与当前节点的值 &lt;code&gt;key&lt;/code&gt; 用 &lt;code&gt;.&lt;/code&gt; 拼接在一起。也就是说最后得到的路径是 &lt;code&gt;A.B.C&lt;/code&gt; 这种格式。&lt;/p&gt;
&lt;p&gt;可以看出生成的对比结果是个字典，包含三个键值对，键分别是 &lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt; 和 &lt;code&gt;modify&lt;/code&gt;，值为字典。&lt;/p&gt;
&lt;h3 id=&quot;应用-JSON-配置&quot;&gt;&lt;a href=&quot;#应用-JSON-配置&quot; class=&quot;headerlink&quot; title=&quot;应用 JSON 配置&quot;&gt;&lt;/a&gt;应用 JSON 配置&lt;/h3&gt;&lt;p&gt;因为生成的 JSON 配置文件具有一定格式，所以必须按照格式规则来应用这些配置到工程文件中。最关键的是在上一步中生成的路径格式为 &lt;code&gt;A.B.C&lt;/code&gt;，且路径内容是未知的，需要实时处理。所以我写了个方法来解析路径，步入到路径最底层后提供闭包来对路径的值进行修改。假设 &lt;code&gt;keyPath&lt;/code&gt; 为路径字符串内容，方法实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;keys&lt;/span&gt; = keyPath.components(separatedBy: &lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/// 假如 &lt;span class=&quot;keyword&quot;&gt;command&lt;/span&gt; 为 &lt;span class=&quot;string&quot;&gt;&quot;modify&quot;&lt;/span&gt; keyPath 为 &lt;span class=&quot;string&quot;&gt;&quot;A.B.C&quot;&lt;/span&gt;，目的是让 value[A][B][C] = data。需要沿着路径深入，使用闭包修改叶子节点的数据，递归过程中逐级向上返回修改后的结果，完成整个路径上数据的更新。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;///&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/// - parameter &lt;span class=&quot;built_in&quot;&gt;index&lt;/span&gt;:    路径深度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/// - parameter value:    当前路径对应的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/// - parameter &lt;span class=&quot;built_in&quot;&gt;complete&lt;/span&gt;: 路径终点所要做的操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;///&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/// - &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;s:&lt;/span&gt; 当前路径层级修改后的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func walkIn(atIndex &lt;span class=&quot;built_in&quot;&gt;index&lt;/span&gt;: Int, withCurrentValue value: Any, &lt;span class=&quot;built_in&quot;&gt;complete&lt;/span&gt;: (Any) -&amp;gt; Any?) -&amp;gt; Any? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;index&lt;/span&gt; &amp;lt; &lt;span class=&quot;built_in&quot;&gt;keys&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; key = &lt;span class=&quot;built_in&quot;&gt;keys&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;index&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dicValue = value &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [Strin&lt;span class=&quot;variable&quot;&gt;g:&lt;/span&gt; Any],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; nextValue = dicValue[key] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var resultValue = dicValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            resultValue[key] = walkIn(atIndex: &lt;span class=&quot;built_in&quot;&gt;index&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, withCurrentValue: nextValue, &lt;span class=&quot;built_in&quot;&gt;complete&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;complete&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; resultValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Wrong KeyPath&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;complete&lt;/span&gt;(value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个方法会将当前层级（&lt;code&gt;index&lt;/code&gt;）路径的节点作为键（&lt;code&gt;key&lt;/code&gt;），并查找字典中该键对应的值（&lt;code&gt;nextValue&lt;/code&gt;）。然后递归遍历下一层，直至步入到路径（&lt;code&gt;keypath&lt;/code&gt;）最末端。此时会执行传入的 &lt;code&gt;complete&lt;/code&gt; 闭包，并将结果作为该方法的返回值。这样在对路径最末端的节点值做出修改后就可以逐层同步上去，最后完成对整条路径的修改。&lt;/p&gt;
&lt;p&gt;如果能直接给 &lt;code&gt;value[A][B][C]&lt;/code&gt; 赋值就好了，但是这是不可能的。因为路径内容是未知的，这样的代码不可能写死的，只能动态地递归进去，并在调用后将修改内容返回上层。&lt;/p&gt;
&lt;p&gt;之前提到过 JSON 文件格式中包含三种命令：&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt; 和 &lt;code&gt;modify&lt;/code&gt;。所以在实现 &lt;code&gt;complete&lt;/code&gt; 方法的时候需要针对这三种命令分别处理，每种命令还要区分字典和数组两种数据类型。这里处理的逻辑基本是上一步的逆逻辑，很容易理解。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// 这个方法可厉（dan）害（teng）咯，把 json 配置数据应用到工程文件数据上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - parameter json:        配置文件数据，用于对工程文件的增删改操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - parameter projectData: 工程文件数据，project.pbxproj 的内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;title&quot;&gt;json&lt;/span&gt;: [&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;: [&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Any&lt;/span&gt;]], &lt;span class=&quot;title&quot;&gt;onProjectData&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;projectData&lt;/span&gt;: [&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Any&lt;/span&gt;]) -&amp;gt; [&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Any&lt;/span&gt;] &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; appliedData = projectData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历 JSON 中的三个命令&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (command, arguments) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; json &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	     &lt;span class=&quot;comment&quot;&gt;// 遍历每个命令中的路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (keyPath, data) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; arguments &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; keys = keyPath.components(separatedBy: &lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;walkIn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(atIndex index: Int, withCurrentValue value: Any, complete: &lt;span class=&quot;params&quot;&gt;(Any)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;?) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ... 此处省略&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 调用 `walkIn` 方法，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = walkIn(atIndex: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, withCurrentValue: appliedData, complete: &amp;#123; (value) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;? &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// value 为路径叶子节点的数据。根据 command 的不同，处理的规则也不一样：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; command &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 添加数据时 data 和 value 类型要统一，要么都是数组，要么都是字典，否则不做变更&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;insert&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dictionary = value &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dicData = data &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (dataKey, dataValue) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dicData &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            dictionary[dataKey] = dataValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dictionary&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; array = value &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arrayData = data &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        array.append(contentsOf: arrayData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 移除数据时被移除的 data 为包含数据或键的数组，否则不做变更&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;remove&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dictionary = value &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arrayData = data &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; removeData &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; arrayData &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; removeKey = removeData &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                dictionary[removeKey] = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dictionary&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; array = value &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arrayData = data &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; removeData &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; arrayData &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; removeIndex = removeData &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ..&amp;lt; array.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;).&lt;span class=&quot;built_in&quot;&gt;contains&lt;/span&gt;(removeIndex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    array.remove(at: removeIndex)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; removeElement = removeData &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; removeIndex = array.index(of: removeElement) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                array.remove(at: removeIndex)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 直接用 data 替换 value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;modify&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                appliedData = result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; appliedData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为 JSON 文件内容层级较深，所以需要先遍历最外面的字典。一共有三个键值对，分别对应 &lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt; 和 &lt;code&gt;modify&lt;/code&gt; 三个命令（&lt;code&gt;command&lt;/code&gt;）及其参数（&lt;code&gt;arguments&lt;/code&gt;）。每种命令的参数都是由『(路径:字典或数组)』这样格式的键值对组成。路径对应的值的类型需要与 JSON 文件中一样。&lt;/p&gt;
&lt;p&gt;在遍历的同时修改工程文件数据的内容，这里使用了 Swift 的嵌套方法和尾随闭包语法。这总语法虽然用着爽，但是对代码的可读性也有所降低。&lt;/p&gt;
&lt;h3 id=&quot;操作工程文件&quot;&gt;&lt;a href=&quot;#操作工程文件&quot; class=&quot;headerlink&quot; title=&quot;操作工程文件&quot;&gt;&lt;/a&gt;操作工程文件&lt;/h3&gt;&lt;p&gt;可以用 &lt;code&gt;PropertyListSerialization&lt;/code&gt; 来（反）序列化 project.pbxproj 文件的内容：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; fileData = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; Data(contentsOf: url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; plist = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; PropertyListSerialization.propertyList(from: fileData, option&lt;span class=&quot;variable&quot;&gt;s:&lt;/span&gt; .mutableContainersAndLeaves, forma&lt;span class=&quot;variable&quot;&gt;t:&lt;/span&gt; nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; data = &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; PropertyListSerialization.data(fromPropertyLis&lt;span class=&quot;variable&quot;&gt;t:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;, forma&lt;span class=&quot;variable&quot;&gt;t:&lt;/span&gt; .xml, option&lt;span class=&quot;variable&quot;&gt;s:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; data.&lt;span class=&quot;keyword&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt;: url, option&lt;span class=&quot;variable&quot;&gt;s:&lt;/span&gt; .atomic)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将工程文件数据写入磁盘表面上看起来是一件再简单不过的事情，但其实这里面包含编码问题和备份机制。&lt;/p&gt;
&lt;h4 id=&quot;编码问题&quot;&gt;&lt;a href=&quot;#编码问题&quot; class=&quot;headerlink&quot; title=&quot;编码问题&quot;&gt;&lt;/a&gt;编码问题&lt;/h4&gt;&lt;p&gt;直接把工程文件数据写入文件后，中文会有乱码。需要做的是把中文内容的 Unicode 的标量值提取出并转成 numeric character reference（NCR）。”&amp;amp;#dddd” 的一串字符是 HTML、XML 等 SGML 类语言的转义序列（escape sequence），它们不是『编码』。&lt;/p&gt;
&lt;p&gt;下面的方法可以将生成的工程文件中文内容替换成 NCR：&lt;/p&gt;
&lt;figure class=&quot;highlight gams&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func handleEncode(fileURL: URL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func encodeString(_ str: String) -&amp;gt; String &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var result = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;scalar&lt;/span&gt; in &lt;span class=&quot;comment&quot;&gt;str.unicodeScalars &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if &lt;span class=&quot;comment&quot;&gt;scalar.value &amp;gt; 0x4e00 &amp;amp;&amp;amp; scalar.value &amp;lt; 0x9fff &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result &lt;span class=&quot;comment&quot;&gt;+= String(format:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;&quot;&amp;amp;#%04d;&quot;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;, scalar.value)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result &lt;span class=&quot;comment&quot;&gt;+= scalar.description&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return &lt;span class=&quot;comment&quot;&gt;result&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;comment&quot;&gt;txt = try String(contentsOf: fileURL, encoding: .utf8)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        txt &lt;span class=&quot;comment&quot;&gt;= encodeString(txt)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        try &lt;span class=&quot;comment&quot;&gt;txt.write(to: fileURL, atomically: true, encoding: .utf8)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch &lt;span class=&quot;comment&quot;&gt;let error &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;translate chinese characters to mathematical symbols error: \(error.localizedDescription)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;备份机制&quot;&gt;&lt;a href=&quot;#备份机制&quot; class=&quot;headerlink&quot; title=&quot;备份机制&quot;&gt;&lt;/a&gt;备份机制&lt;/h4&gt;&lt;p&gt;既然是要生成新的工程文件来替换原来的工程文件，备份机制肯定不能少。当前的备份机制仅仅备份上次修改的文件，这是考虑到备份历史文件会占用大量磁盘的问题。比如大一些的工程文件可能占用10M 甚至更多的空间，频繁操作产生的备份会很多。&lt;/p&gt;
&lt;p&gt;在生成备份文件和使用备份文件还原时，都需要获取到当前工程文件对应的备份文件 URL。真正的主角 project.pbxproj 被包含在工程文件（夹）内部，所以要根据文件后缀名来决定如何处理。下面的私有方法会将传入的 URL 引用参数修改为真正的 project.pbxproj 文件 URL，并返回备份文件的 URL：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// 返回指定文件对应的备份文件路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - parameter url: 文件 URL，如果是工程文件，会被修改为 project.pbxproj 文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// - returns: 备份文件路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fileprivate class func backupURLOf(projectURL url: inout URL) -&amp;gt; URL &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-tag&quot;&gt;var&lt;/span&gt; backupURL = URL(fileURLWithPath: NSHomeDirectory()).appendingPathComponent(&lt;span class=&quot;string&quot;&gt;&quot;Documents&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; url&lt;span class=&quot;selector-class&quot;&gt;.pathExtension&lt;/span&gt; == &lt;span class=&quot;string&quot;&gt;&quot;xcodeproj&quot;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        backupURL.appendPathComponent(url.lastPathComponent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        backupURL.appendPathExtension(&lt;span class=&quot;string&quot;&gt;&quot;project.pbxproj&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        url.appendPathComponent(&lt;span class=&quot;string&quot;&gt;&quot;project.pbxproj&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let count = url&lt;span class=&quot;selector-class&quot;&gt;.pathComponents&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.count&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; count &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            backupURL.appendPathComponent(url&lt;span class=&quot;selector-class&quot;&gt;.pathComponents&lt;/span&gt;[count-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            backupURL.appendPathExtension(url&lt;span class=&quot;selector-class&quot;&gt;.pathComponents&lt;/span&gt;[count-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    backupURL.appendPathExtension(&lt;span class=&quot;string&quot;&gt;&quot;backup&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return backupURL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个方法只干一件事，这个方法设计的很不好，干了两件事，别学我这么做。我这么做是为了省代码量。（狡辩，逃）&lt;/p&gt;
&lt;h3 id=&quot;预览和过滤工程文件内容&quot;&gt;&lt;a href=&quot;#预览和过滤工程文件内容&quot; class=&quot;headerlink&quot; title=&quot;预览和过滤工程文件内容&quot;&gt;&lt;/a&gt;预览和过滤工程文件内容&lt;/h3&gt;&lt;p&gt;主界面如下，在展示所有数据的同时，可以在 Filter 文本框中输入关键词来过滤数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yulingtianxia/pbxprojHelper/master/images/MainWindow%402x.png&quot; alt=&quot;MainWindow&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;预览&quot;&gt;&lt;a href=&quot;#预览&quot; class=&quot;headerlink&quot; title=&quot;预览&quot;&gt;&lt;/a&gt;预览&lt;/h4&gt;&lt;p&gt;关于如何使用 &lt;code&gt;NSOutlineView&lt;/code&gt; 展示数据，不想多说，查文档写 UI 谁都会。&lt;/p&gt;
&lt;p&gt;我定义了一个数据结构 &lt;code&gt;Item&lt;/code&gt; 来表示 &lt;code&gt;NSOutlineView&lt;/code&gt; 中每行节点的数据：&lt;/p&gt;
&lt;figure class=&quot;highlight elm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typealias &lt;span class=&quot;type&quot;&gt;Item&lt;/span&gt; = (key: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, value: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;, parent: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;?)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为有了 &lt;code&gt;parent&lt;/code&gt; 指向父节点，可以递归搜寻到某个 &lt;code&gt;Item&lt;/code&gt; 对象所处的路径（&lt;code&gt;keypath&lt;/code&gt;）：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;keyPath&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(forItem item: Any?)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; key: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; parent: &lt;span class=&quot;type&quot;&gt;Any&lt;/span&gt;?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; tupleItem = item &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;Item&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        key = tupleItem.key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        parent = tupleItem.parent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        key = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        parent = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; parentItem = parent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(keyPath(forItem: parentItem)&lt;/span&gt;).&lt;span class=&quot;subst&quot;&gt;\(key)&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;\(key)&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样就可以实现双击某行数据时，自动将当前数据的路径写入 Pasteboard 中。&lt;/p&gt;
&lt;h4 id=&quot;过滤&quot;&gt;&lt;a href=&quot;#过滤&quot; class=&quot;headerlink&quot; title=&quot;过滤&quot;&gt;&lt;/a&gt;过滤&lt;/h4&gt;&lt;p&gt;过滤关键字的重点就是判断一个 &lt;code&gt;Item&lt;/code&gt; 及其子节点中是否包含此关键字，此时需要依然是需要 DFS 递归查找关键字。&lt;/p&gt;
&lt;p&gt;查找关键字需要忽略大小写：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;func &lt;span class=&quot;title&quot;&gt;checkAny&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: Any, containsString &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;: String&lt;/span&gt;) -&amp;gt; Bool &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; String) &amp;amp;&amp;amp; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;! String).lowercased().contains(&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;.lowercased()))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;递归查找很容易实现，只不过区分下数组和字典罢了：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;func &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;propertyList list: Any&lt;/span&gt;) -&amp;gt; Bool &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dictionary = list &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [String: Any] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (key, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dictionary &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;checkAny&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: key, containsString: word&lt;/span&gt;) || &lt;span class=&quot;title&quot;&gt;checkAny&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;, containsString: word&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;propertyList: &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; array = list &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? [Any] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;checkAny&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;, containsString: word&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;propertyList: &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后经过方法嵌套拼装成如下：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isItem&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; item: Any, containsKeyWord word: String)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; tupleItem = item &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;Item&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; checkAny(value: tupleItem.key, containsString: word) || checkAny(value: tupleItem.value, containsString: word) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(propertyList list: Any)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	&lt;span class=&quot;comment&quot;&gt;/// 此处省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dfs(propertyList: tupleItem.value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;快速切换工程文件&quot;&gt;&lt;a href=&quot;#快速切换工程文件&quot; class=&quot;headerlink&quot; title=&quot;快速切换工程文件&quot;&gt;&lt;/a&gt;快速切换工程文件&lt;/h3&gt;&lt;p&gt;下拉列表的 UI 实现很简单，就是一个 &lt;code&gt;NSView&lt;/code&gt; 里面放几个 &lt;code&gt;NSTextField&lt;/code&gt;。维护常用工程文件列表需要在每次用户选择工程文件后将其加入列表，实现 LRU 算法。&lt;/p&gt;
&lt;p&gt;这里对 LRU 缓存的需求跟 &lt;a href=&quot;http://yulingtianxia.com/blog/2016/02/27/TFSHelper/#缓存常用链接&quot;&gt;自制一款 Mac 平台 URL 辅助工具&lt;/a&gt; 这篇文章中的 TFSHelper 的是一样的。我直接把代码搬过来了。我将其放到 Github Gist 上了，可能需要科学上网：&lt;a href=&quot;https://gist.github.com/yulingtianxia/5d61afdb241dcd5562b211cb485883fa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LRUCache&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下拉列表的点击操作交由 &lt;code&gt;NSClickGestureRecognizer&lt;/code&gt; 捕获处理。&lt;/p&gt;
&lt;h3 id=&quot;构造命令行工具&quot;&gt;&lt;a href=&quot;#构造命令行工具&quot; class=&quot;headerlink&quot; title=&quot;构造命令行工具&quot;&gt;&lt;/a&gt;构造命令行工具&lt;/h3&gt;&lt;p&gt;为了尽可能精简命令行的使用复杂度，我只把最核心的功能封装进去，一共只有这几个命令：&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Usage: pbxproj [command_option] &lt;span class=&quot;built_in&quot;&gt;file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Command options are (-convert &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; default):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-compare modified_file -o path          compare modified &lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; generate a json &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;given&lt;/span&gt; path&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-apply json_file                        apply a json &lt;span class=&quot;built_in&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-revert                                 revert &lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; latest backup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-convert                                rewrite &lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt; files &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xml format&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输入的这些参数都需要自己去处理，由此会产生大量条件判断，好在我的不算复杂。需要注意的是参数列表第一个是程序名称（路径）。&lt;/p&gt;
&lt;p&gt;在 terminal 中执行 Swift 文件时获取参数内容的方式变了好多次，一开始是 &lt;code&gt;C_ARGC&lt;/code&gt; 和 &lt;code&gt;C_ARGV&lt;/code&gt;，到了 Swift 1.2 只能使用 &lt;code&gt;Process.arguments&lt;/code&gt;，到了 Swift 3 又变了，必须用 &lt;code&gt;CommandLine.arguments&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;拿到了参数后，我所做的事情只是调用 &lt;code&gt;PropertyListHandler&lt;/code&gt; 中已经封装好的工具方法罢了。&lt;/p&gt;
&lt;p&gt;不是所有的人都会把 Swift 文件当做脚本去执行，所以还需要创建个 target，打包成可执行程序，这样就不依赖 Swift 命令了。&lt;/p&gt;
&lt;h2 id=&quot;结果&quot;&gt;&lt;a href=&quot;#结果&quot; class=&quot;headerlink&quot; title=&quot;结果&quot;&gt;&lt;/a&gt;结果&lt;/h2&gt;&lt;p&gt;我使用 pbxprojHelper 的频率十分高，因为开发同一项目的人很多，svn 的分支也多。第一次生成好我的 JSON 配置文件后以后就几乎不用再生成了，不同分支的工程都可以共用这一个 JSON 配置。每次因为种种原因 revert 了 project.pbxproj 文件后，我都可以用它一键配置好我的工程文件，&lt;strong&gt;节省了至少 90% 的时间！&lt;/strong&gt;即便换了个其他分支的工程，也可以在常用列表中迅速切换，不用再次 select 文件。&lt;/p&gt;
&lt;p&gt;也正是在一次次的使用中发现了若干 bug 和体验问题，然后不断改进和完善。&lt;/p&gt;
&lt;h2 id=&quot;感悟&quot;&gt;&lt;a href=&quot;#感悟&quot; class=&quot;headerlink&quot; title=&quot;感悟&quot;&gt;&lt;/a&gt;感悟&lt;/h2&gt;&lt;p&gt;这个项目从开始构思需求到完成基本功能花费了我大概一周的业余时间。&lt;/p&gt;
&lt;p&gt;前期调研做了些准备工作后觉得还是有可行性的，并对部分功能需求做了妥协。比如记录工程文件修改内容需要对比新旧两个文件，这就要求使用者先把工程文件保存一份，然后再修改，最后使用 pbxprojHelper 对比两个工程文件的差异。最后生成工程文件的环节也做了妥协，因为无法将数据以 OpenStep 格式写入文件，除非调用 Xcode 私有框架 &lt;code&gt;touch&lt;/code&gt; 下工程文件。所以需要用户用 Xcode 打开工程后随意修改下工程再复原即可。就是在这样一次次对功能的妥协下，使得方案的看似不可行变得可行。&lt;/p&gt;
&lt;p&gt;这个项目的需求一开始并不明确，是在摸索中一点点确立的。比如一开始根本没有想到过要把修改保存成 JSON 文件，之后想的是让用户手动创建和编写 JSON 配置文件，再之后想的是自动生成 JSON 配置文件。在制定 JSON 配置的内容规则上也是调整了一阵子，几经修改最后定稿。所以说，产品经理下次改需求的时候可以适当理解下，毕竟产品成型的确需要个过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摸着石头过河的感觉虽然忐忑，但是我更享受攻城略地般的快感。&lt;/strong&gt;当时在开发的过程中遇到了一个个难题，当时连自己也不知道能否搞定，很有可能半途而废。但最终还是通过制定策略和实现算法实现了，虽然算法都挺简单并不难，但是能有针对性地给出一些解决方案还是比较有成就感的。&lt;/p&gt;
&lt;p&gt;作为一款给自己量身打造的玩票工具，使用 Swift 来开发看起来是当今标配，理所当然。也是趁着玩票的机会温（chong）习（xue）下 Swift，毕竟平时一直用 OC 写 MRC 代码，生怕落后于这个时代。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper&quot;&gt;pbxprojHelper&lt;/a&gt; 可以帮你快速配置 Xcode 工程文件，省去麻烦的人工手动操作。项目开源，使用 Swift 开发，详细介绍请见&lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper/blob/master/Documentation/README_ZH.md&quot;&gt;使用说明&lt;/a&gt;。除了 Mac App 外还提供了命令行工具 &lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper/releases/download/1.1.3/pbxproj&quot;&gt;&lt;code&gt;pbxproj&lt;/code&gt;&lt;/a&gt;，它集成了 &lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper&quot;&gt;pbxprojHelper&lt;/a&gt; 的核心功能，同样简易实用。&lt;/p&gt;
&lt;p&gt;因为 &lt;a href=&quot;https://github.com/yulingtianxia/pbxprojHelper/blob/master/Documentation/README_ZH.md&quot;&gt;README_ZH&lt;/a&gt; 中对使用方法已经讲得很详细了，这里重点说的是产品方案和技术实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="http://yulingtianxia.com/tags/macOS/"/>
    
      <category term="Xcode" scheme="http://yulingtianxia.com/tags/Xcode/"/>
    
      <category term="Swift" scheme="http://yulingtianxia.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>优化 App 的启动时间</title>
    <link href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/"/>
    <id>http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/</id>
    <published>2016-10-30T05:11:10.000Z</published>
    <updated>2017-08-20T07:18:30.000Z</updated>
    
    <content type="html">&lt;p&gt;这是一篇 WWDC 2016 Session 406 的学习笔记，从原理到实践讲述了如何优化 App 的启动时间。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;App-运行理论&quot;&gt;&lt;a href=&quot;#App-运行理论&quot; class=&quot;headerlink&quot; title=&quot;App 运行理论&quot;&gt;&lt;/a&gt;App 运行理论&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main()&lt;/code&gt; 执行前发生的事&lt;/li&gt;
&lt;li&gt;Mach-O 格式&lt;/li&gt;
&lt;li&gt;虚拟内存基础&lt;/li&gt;
&lt;li&gt;Mach-O 二进制的加载&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;理论速成&quot;&gt;&lt;a href=&quot;#理论速成&quot; class=&quot;headerlink&quot; title=&quot;理论速成&quot;&gt;&lt;/a&gt;理论速成&lt;/h3&gt;&lt;h4 id=&quot;Mach-O-术语&quot;&gt;&lt;a href=&quot;#Mach-O-术语&quot; class=&quot;headerlink&quot; title=&quot;Mach-O 术语&quot;&gt;&lt;/a&gt;Mach-O 术语&lt;/h4&gt;&lt;p&gt;Mach-O 是针对不同运行时可执行文件的文件类型。 &lt;/p&gt;
&lt;p&gt;文件类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executable： 应用的主要二进制&lt;/li&gt;
&lt;li&gt;Dylib： 动态链接库（又称 DSO 或 DLL）&lt;/li&gt;
&lt;li&gt;Bundle： 不能被链接的 Dylib，只能在运行时使用 &lt;code&gt;dlopen()&lt;/code&gt; 加载，可当做 macOS 的插件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Image： executable，dylib 或 bundle&lt;br&gt;Framework： 包含 Dylib 以及资源文件和头文件的文件夹&lt;/p&gt;
&lt;h4 id=&quot;Mach-O-镜像文件&quot;&gt;&lt;a href=&quot;#Mach-O-镜像文件&quot; class=&quot;headerlink&quot; title=&quot;Mach-O 镜像文件&quot;&gt;&lt;/a&gt;Mach-O 镜像文件&lt;/h4&gt;&lt;p&gt;Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。&lt;/p&gt;
&lt;p&gt;segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。&lt;/p&gt;
&lt;p&gt;section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。&lt;/p&gt;
&lt;p&gt;几乎所有 Mach-O 都包含这三个段（segment）： &lt;code&gt;__TEXT&lt;/code&gt;,&lt;code&gt;__DATA&lt;/code&gt; 和 &lt;code&gt;__LINKEDIT&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__TEXT&lt;/code&gt; 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__DATA&lt;/code&gt; 包含全局变量，静态变量等。可读写（rw-）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__LINKEDIT&lt;/code&gt; 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Mach-O-Universal-文件&quot;&gt;&lt;a href=&quot;#Mach-O-Universal-文件&quot; class=&quot;headerlink&quot; title=&quot;Mach-O Universal 文件&quot;&gt;&lt;/a&gt;Mach-O Universal 文件&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fat_binary&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FAT 二进制&lt;/a&gt;文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。&lt;/p&gt;
&lt;p&gt;按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。&lt;/p&gt;
&lt;h4 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h4&gt;&lt;p&gt;虚拟内存就是一层间接寻址（indirection）。软件工程中有句格言就是任何问题都能通过添加一个间接层来解决。虚拟内存解决的是管理所有进程使用物理 RAM 的问题。通过添加间接层来让每个进程使用逻辑地址空间，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault；第二种情况就是多进程共享内存。&lt;/p&gt;
&lt;p&gt;对于文件可以不用一次性读入整个文件，可以使用分页映射（&lt;code&gt;mmap()&lt;/code&gt;）的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。&lt;/p&gt;
&lt;p&gt;也就是说 Mach-O 文件中的 &lt;code&gt;__TEXT&lt;/code&gt; 段可以映射到多个进程，并可以懒加载，且进程之间共享内存。&lt;code&gt;__DATA&lt;/code&gt; 段是可读写的。这里使用到了 Copy-On-Write 技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean/dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。&lt;/p&gt;
&lt;h4 id=&quot;Mach-O-镜像-加载&quot;&gt;&lt;a href=&quot;#Mach-O-镜像-加载&quot; class=&quot;headerlink&quot; title=&quot;Mach-O 镜像 加载&quot;&gt;&lt;/a&gt;Mach-O 镜像 加载&lt;/h4&gt;&lt;p&gt;所以在多个进程加载 Mach-O 镜像时 &lt;code&gt;__TEXT&lt;/code&gt; 和  &lt;code&gt;__LINKEDIT&lt;/code&gt; 因为只读，都是可以共享内存的。而 &lt;code&gt;__DATA&lt;/code&gt; 因为可读写，就会产生 dirty page。当 dyld 执行结束后，&lt;code&gt;__LINKEDIT&lt;/code&gt; 就没用了，对应的内存页会被回收。&lt;/p&gt;
&lt;h4 id=&quot;安全&quot;&gt;&lt;a href=&quot;#安全&quot; class=&quot;headerlink&quot; title=&quot;安全&quot;&gt;&lt;/a&gt;安全&lt;/h4&gt;&lt;p&gt;ASLR（Address Space Layout Randomization）：地址空间布局随机化，镜像会在随机的地址上加载。这其实是一二十年前的旧技术了。&lt;/p&gt;
&lt;p&gt;代码签名：可能我们认为 Xcode 会把整个文件都做加密 hash 并用做数字签名。其实为了在运行时验证 Mach-O 文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在 &lt;code&gt;__LINKEDIT&lt;/code&gt; 中。这使得文件每页的内容都能及时被校验确并保不被篡改。&lt;/p&gt;
&lt;h3 id=&quot;从-exec-到-main&quot;&gt;&lt;a href=&quot;#从-exec-到-main&quot; class=&quot;headerlink&quot; title=&quot;从 exec() 到 main()&quot;&gt;&lt;/a&gt;从 &lt;code&gt;exec()&lt;/code&gt; 到 &lt;code&gt;main()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;exec()&lt;/code&gt; 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 ASLR）。并将起始位置到 &lt;code&gt;0x000000&lt;/code&gt; 这段范围的进程权限都标记为不可读写不可执行。如果是 32 位进程，这个范围&lt;strong&gt;至少&lt;/strong&gt;是 4KB；对于 64 位进程则&lt;strong&gt;至少&lt;/strong&gt;是 4GB。NULL 指针引用和指针截断误差都是会被它捕获。&lt;/p&gt;
&lt;h3 id=&quot;dyld-加载-dylib-文件&quot;&gt;&lt;a href=&quot;#dyld-加载-dylib-文件&quot; class=&quot;headerlink&quot; title=&quot;dyld 加载 dylib 文件&quot;&gt;&lt;/a&gt;&lt;code&gt;dyld&lt;/code&gt; 加载 dylib 文件&lt;/h3&gt;&lt;p&gt;Unix 的前二十年很安逸，因为那时还没有发明动态链接库。有了动态链接库后，一个用于加载链接库的帮助程序被创建。在苹果的平台里是 &lt;code&gt;dyld&lt;/code&gt;，其他 Unix 系统也有 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Ld.so&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;ld.so&lt;/code&gt;&lt;/a&gt;。 当内核完成映射进程的工作后会将名字为 &lt;code&gt;dyld&lt;/code&gt; 的Mach-O 文件映射到进程中的随机地址，它将 PC 寄存器设为 &lt;code&gt;dyld&lt;/code&gt; 的地址并运行。&lt;code&gt;dyld&lt;/code&gt; 在应用进程中运行的工作是加载应用依赖的所有动态链接库，准备好运行所需的一切，它拥有的权限跟应用一样。&lt;/p&gt;
&lt;p&gt;下面的步骤构成了 &lt;code&gt;dyld&lt;/code&gt; 的时间线：&lt;/p&gt;
&lt;p&gt;Load dylibs -&amp;gt; Rebase -&amp;gt; Bind -&amp;gt; ObjC -&amp;gt; Initializers&lt;/p&gt;
&lt;h4 id=&quot;加载-Dylib&quot;&gt;&lt;a href=&quot;#加载-Dylib&quot; class=&quot;headerlink&quot; title=&quot;加载 Dylib&quot;&gt;&lt;/a&gt;加载 Dylib&lt;/h4&gt;&lt;p&gt;从主执行文件的 header 获取到需要加载的所依赖动态库列表，而 header 早就被内核映射过。然后它需要找到每个 dylib，然后打开文件读取文件起始位置，确保它是 Mach-O 文件。接着会找到代码签名并将其注册到内核。然后在 dylib 文件的每个 segment 上调用 &lt;code&gt;mmap()&lt;/code&gt;。应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以 &lt;code&gt;dyld&lt;/code&gt; 所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 100 到 400 个 dylib 文件，但大部分都是系统 dylib，它们会被预先计算和缓存起来，加载速度很快。&lt;/p&gt;
&lt;h4 id=&quot;Fix-ups&quot;&gt;&lt;a href=&quot;#Fix-ups&quot; class=&quot;headerlink&quot; title=&quot;Fix-ups&quot;&gt;&lt;/a&gt;Fix-ups&lt;/h4&gt;&lt;p&gt;在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，这就是 Fix-ups。代码签名使得我们不能修改指令，那样就不能让一个 dylib 的调用另一个 dylib。这时需要加很多间接层。&lt;/p&gt;
&lt;p&gt;现代 code-gen 被叫做动态 PIC（Position Independent Code），意味着代码可以被加载到间接的地址上。当调用发生时，code-gen 实际上会在 &lt;code&gt;__DATA&lt;/code&gt; 段中创建一个指向被调用者的指针，然后加载指针并跳转过去。&lt;/p&gt;
&lt;p&gt;所以 &lt;code&gt;dyld&lt;/code&gt; 做的事情就是修正（fix-up）指针和数据。Fix-up 有两种类型，rebasing 和 binding。&lt;/p&gt;
&lt;h4 id=&quot;Rebasing-和-Binding&quot;&gt;&lt;a href=&quot;#Rebasing-和-Binding&quot; class=&quot;headerlink&quot; title=&quot;Rebasing 和 Binding&quot;&gt;&lt;/a&gt;Rebasing 和 Binding&lt;/h4&gt;&lt;p&gt;Rebasing：在镜像内部调整指针的指向&lt;br&gt;Binding：将指针指向镜像外部的内容&lt;/p&gt;
&lt;p&gt;可以通过命令行查看 rebase 和 bind 等信息：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;xcrun&lt;/span&gt; dyldinfo -rebase -&lt;span class=&quot;keyword&quot;&gt;bind &lt;/span&gt;-lazy_bind myapp.app/myapp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过这个命令可以查看所有的 Fix-up。rebase，bind，weak_bind，lazy_bind 都存储在 &lt;code&gt;__LINKEDIT&lt;/code&gt; 段中，并可通过 &lt;code&gt;LC_DYLD_INFO_ONLY&lt;/code&gt; 查看各种信息的偏移量和大小。&lt;/p&gt;
&lt;p&gt;建议用 MachOView 查看更加方便直观。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;dyld&lt;/code&gt; 源码层面简要介绍下 Rebasing 和 Binding 的流程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ImageLoader&lt;/code&gt; 是一个用于加载可执行文件的基类，它负责链接镜像，但不关心具体文件格式，因为这些都交给子类去实现。每个可执行文件都会对应一个 &lt;code&gt;ImageLoader&lt;/code&gt; 实例。&lt;code&gt;ImageLoaderMachO&lt;/code&gt; 是用于加载 Mach-O 格式文件的 &lt;code&gt;ImageLoader&lt;/code&gt; 子类，而 &lt;code&gt;ImageLoaderMachOClassic&lt;/code&gt; 和 &lt;code&gt;ImageLoaderMachOCompressed&lt;/code&gt; 都继承于 &lt;code&gt;ImageLoaderMachO&lt;/code&gt;，分别用于加载那些 &lt;code&gt;__LINKEDIT&lt;/code&gt; 段为传统格式和压缩格式的 Mach-O 文件。&lt;/p&gt;
&lt;p&gt;因为 dylib 之间有依赖关系，所以 &lt;code&gt;ImageLoader&lt;/code&gt; 中的好多操作都是沿着依赖链递归操作的，Rebasing 和 Binding 也不例外，分别对应着 &lt;code&gt;recursiveRebase()&lt;/code&gt; 和 &lt;code&gt;recursiveBind()&lt;/code&gt; 这两个方法。因为是递归，所以会自底向上地分别调用 &lt;code&gt;doRebase()&lt;/code&gt; 和 &lt;code&gt;doBind()&lt;/code&gt; 方法，这样被依赖的 dylib 总是先于依赖它的 dylib 执行 Rebasing 和 Binding。传入 &lt;code&gt;doRebase()&lt;/code&gt; 和 &lt;code&gt;doBind()&lt;/code&gt; 的参数包含一个 &lt;code&gt;LinkContext&lt;/code&gt; 上下文，存储了可执行文件的一堆状态和相关的函数。&lt;/p&gt;
&lt;p&gt;在 Rebasing 和 Binding 前会判断是否已经 Prebinding。如果已经进行过预绑定（Prebinding），那就不需要 Rebasing 和 Binding 这些 Fix-up 流程了，因为已经在预先绑定的地址加载好了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ImageLoaderMachO&lt;/code&gt; 实例&lt;strong&gt;不使用预绑&lt;/strong&gt;定会有四个原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mach-O Header 中 &lt;code&gt;MH_PREBOUND&lt;/code&gt; 标志位为 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;镜像加载地址有偏移（这个后面会讲到）&lt;/li&gt;
&lt;li&gt;依赖的库有变化&lt;/li&gt;
&lt;li&gt;镜像使用 flat-namespace，预绑定的一部分会被忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkContext&lt;/code&gt; 的环境变量禁止了预绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;ImageLoaderMachO&lt;/code&gt; 中 &lt;code&gt;doRebase()&lt;/code&gt; 做的事情大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果使用预绑定，&lt;code&gt;fgImagesWithUsedPrebinding&lt;/code&gt; 计数加一，并 &lt;code&gt;return&lt;/code&gt;;否则进入第二步&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;MH_PREBOUND&lt;/code&gt; 标志位为 &lt;code&gt;1&lt;/code&gt;（也就是可以预绑定但没使用），且镜像在共享内存中，重置上下文中所有的 lazy pointer。（如果镜像在共享内存中，稍后会在 Binding 过程中绑定，所以无需重置）&lt;/li&gt;
&lt;li&gt;如果镜像加载地址偏移量为0，则无需 Rebasing，直接 &lt;code&gt;return&lt;/code&gt;；否则进入第四步&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;rebase()&lt;/code&gt; 方法，这才是真正做 Rebasing 工作的方法。如果开启 &lt;code&gt;TEXT_RELOC_SUPPORT&lt;/code&gt; 宏，会允许 &lt;code&gt;rebase()&lt;/code&gt; 方法对 &lt;code&gt;__TEXT&lt;/code&gt; 段做写操作来对其进行 Fix-up。所以其实 &lt;code&gt;__TEXT&lt;/code&gt; 只读属性并不是绝对的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;ImageLoaderMachOClassic&lt;/code&gt; 和 &lt;code&gt;ImageLoaderMachOCompressed&lt;/code&gt; 分别实现了自己的 &lt;code&gt;doRebase()&lt;/code&gt; 方法。实现逻辑大同小异，同样会判断是否使用预绑定，并在真正的 Binding 工作时判断 &lt;code&gt;TEXT_RELOC_SUPPORT&lt;/code&gt; 宏来决定是否对 &lt;code&gt;__TEXT&lt;/code&gt; 段做写操作。最后都会调用 &lt;code&gt;setupLazyPointerHandler&lt;/code&gt; 在镜像中设置 &lt;code&gt;dyld&lt;/code&gt; 的 entry point，放在最后调用是为了让主可执行文件设置好 &lt;code&gt;__dyld&lt;/code&gt; 或 &lt;code&gt;__program_vars&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;Rebasing&quot;&gt;&lt;a href=&quot;#Rebasing&quot; class=&quot;headerlink&quot; title=&quot;Rebasing&quot;&gt;&lt;/a&gt;Rebasing&lt;/h4&gt;&lt;p&gt;在过去，会把 dylib 加载到指定地址，所有指针和数据对于代码来说都是对的，&lt;code&gt;dyld&lt;/code&gt; 就无需做任何 fix-up 了。如今用了 ASLR 后会将 dylib 加载到新的随机地址(actual_address)，这个随机的地址跟代码和数据指向的旧地址(preferred_address)会有偏差，&lt;code&gt;dyld&lt;/code&gt; 需要修正这个偏差(slide)，做法就是将 dylib 内部的指针地址都加上这个偏移量，偏移量的计算方法如下：&lt;/p&gt;
&lt;p&gt;Slide = actual_address - preferred_address&lt;/p&gt;
&lt;p&gt;然后就是重复不断地对 &lt;code&gt;__DATA&lt;/code&gt; 段中需要 rebase 的指针加上这个偏移量。这就又涉及到 page fault 和 COW。这可能会产生 I/O 瓶颈，但因为 rebase 的顺序是按地址排列的，所以从内核的角度来看这是个有次序的任务，它会预先读入数据，减少 I/O 消耗。&lt;/p&gt;
&lt;h4 id=&quot;Binding&quot;&gt;&lt;a href=&quot;#Binding&quot; class=&quot;headerlink&quot; title=&quot;Binding&quot;&gt;&lt;/a&gt;Binding&lt;/h4&gt;&lt;p&gt;Binding 是处理那些指向 dylib 外部的指针，它们实际上被符号（symbol）名称绑定，也就是个字符串。之前提到 &lt;code&gt;__LINKEDIT&lt;/code&gt; 段中也存储了需要 bind 的指针，以及指针需要指向的符号。&lt;code&gt;dyld&lt;/code&gt; 需要找到 symbol 对应的实现，这需要很多计算，去符号表里查找。找到后会将内容存储到 &lt;code&gt;__DATA&lt;/code&gt; 段中的那个指针中。Binding 看起来计算量比 Rebasing 更大，但其实需要的 I/O 操作很少，因为之前 Rebasing 已经替 Binding 做过了。&lt;/p&gt;
&lt;h4 id=&quot;ObjC-Runtime&quot;&gt;&lt;a href=&quot;#ObjC-Runtime&quot; class=&quot;headerlink&quot; title=&quot;ObjC Runtime&quot;&gt;&lt;/a&gt;ObjC Runtime&lt;/h4&gt;&lt;p&gt;Objective-C 中有很多数据结构都是靠 Rebasing 和 Binding 来修正（fix-up）的，比如 &lt;code&gt;Class&lt;/code&gt; 中指向超类的指针和指向方法的指针。&lt;/p&gt;
&lt;p&gt;ObjC 是个动态语言，可以用类的名字来实例化一个类的对象。这意味着 ObjC Runtime 需要维护一张映射类名与类的全局表。当加载一个 dylib 时，其定义的所有的类都需要被注册到这个全局表中。&lt;/p&gt;
&lt;p&gt;C++ 中有个问题叫做易碎的基类（fragile base class）。ObjC 就没有这个问题，因为会在加载时通过 fix-up 动态类中改变实例变量的偏移量。&lt;/p&gt;
&lt;p&gt;在 ObjC 中可以通过定义类别（Category）的方式改变一个类的方法。有时你想要添加方法的类在另一个 dylib 中，而不在你的镜像中（也就是对系统或别人的类动刀），这时也需要做些 fix-up。&lt;/p&gt;
&lt;p&gt;ObjC 中的 selector 必须是唯一的。&lt;/p&gt;
&lt;h4 id=&quot;Initializers&quot;&gt;&lt;a href=&quot;#Initializers&quot; class=&quot;headerlink&quot; title=&quot;Initializers&quot;&gt;&lt;/a&gt;Initializers&lt;/h4&gt;&lt;p&gt;C++ 会为静态创建的对象生成初始化器。而在 ObjC 中有个叫 &lt;code&gt;+load&lt;/code&gt; 的方法，然而它被废弃了，现在建议使用 &lt;code&gt;+initialize&lt;/code&gt;。对比详见：&lt;a href=&quot;http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在有了主执行文件，一堆 dylib，其依赖关系构成了一张巨大的有向图，那么执行初始化器的顺序是什么？自顶向上！按照依赖关系，先加载叶子节点，然后逐步向上加载中间节点，直至最后加载根节点。这种加载顺序确保了安全性，加载某个 dylib 前，其所依赖的其余 dylib 文件肯定已经被预先加载。&lt;/p&gt;
&lt;p&gt;最后 &lt;code&gt;dyld&lt;/code&gt; 会调用 &lt;code&gt;main()&lt;/code&gt; 函数。&lt;code&gt;main()&lt;/code&gt; 会调用 &lt;code&gt;UIApplicationMain()&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;改善启动时间&quot;&gt;&lt;a href=&quot;#改善启动时间&quot; class=&quot;headerlink&quot; title=&quot;改善启动时间&quot;&gt;&lt;/a&gt;改善启动时间&lt;/h2&gt;&lt;p&gt;从点击 App 图标到加载 App 闪屏之间会有个动画，我们希望 App 启动速度比这个动画更快。虽然不同设备上 App 启动速度不一样，但启动时间最好控制在 400ms。需要注意的是启动时间一旦超过 20s，系统会认为发生了死循环并杀掉 App 进程。当然启动时间最好以 App 所支持的最低配置设备为准。直到 &lt;code&gt;applicationWillFinishLaunching&lt;/code&gt; 被调动，App 才启动结束。&lt;/p&gt;
&lt;h3 id=&quot;测量启动时间&quot;&gt;&lt;a href=&quot;#测量启动时间&quot; class=&quot;headerlink&quot; title=&quot;测量启动时间&quot;&gt;&lt;/a&gt;测量启动时间&lt;/h3&gt;&lt;p&gt;Warm launch: App 和数据已经在内存中&lt;br&gt;Cold launch: App 不在内核缓冲存储器中&lt;/p&gt;
&lt;p&gt;冷启动（Cold launch）耗时才是我们需要测量的重要数据，为了准确测量冷启动耗时，测量前需要重启设备。在 &lt;code&gt;main()&lt;/code&gt; 方法执行前测量是很难的，好在 &lt;code&gt;dyld&lt;/code&gt; 提供了内建的测量方法：在 Xcode 中 Edit scheme -&amp;gt; Run -&amp;gt; Auguments 将环境变量 &lt;code&gt;DYLD_PRINT_STATISTICS&lt;/code&gt; 设为 &lt;code&gt;1&lt;/code&gt;。控制台输出的内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Total pre-main &lt;span class=&quot;selector-tag&quot;&gt;time&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;228.41&lt;/span&gt; milliseconds (&lt;span class=&quot;number&quot;&gt;100.0%&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         dylib loading &lt;span class=&quot;selector-tag&quot;&gt;time&lt;/span&gt;:  &lt;span class=&quot;number&quot;&gt;82.35&lt;/span&gt; milliseconds (&lt;span class=&quot;number&quot;&gt;36.0%&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rebase/binding &lt;span class=&quot;selector-tag&quot;&gt;time&lt;/span&gt;:   &lt;span class=&quot;number&quot;&gt;6.12&lt;/span&gt; milliseconds (&lt;span class=&quot;number&quot;&gt;2.6%&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ObjC setup &lt;span class=&quot;selector-tag&quot;&gt;time&lt;/span&gt;:   &lt;span class=&quot;number&quot;&gt;7.82&lt;/span&gt; milliseconds (&lt;span class=&quot;number&quot;&gt;3.4%&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           initializer &lt;span class=&quot;selector-tag&quot;&gt;time&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;132.02&lt;/span&gt; milliseconds (&lt;span class=&quot;number&quot;&gt;57.8%&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           slowest intializers :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             libSystem&lt;span class=&quot;selector-class&quot;&gt;.B&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.dylib&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;122.07&lt;/span&gt; milliseconds (&lt;span class=&quot;number&quot;&gt;53.4%&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                CoreFoundation :   &lt;span class=&quot;number&quot;&gt;5.59&lt;/span&gt; milliseconds (&lt;span class=&quot;number&quot;&gt;2.4%&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;优化启动时间&quot;&gt;&lt;a href=&quot;#优化启动时间&quot; class=&quot;headerlink&quot; title=&quot;优化启动时间&quot;&gt;&lt;/a&gt;优化启动时间&lt;/h3&gt;&lt;p&gt;可以针对 App 启动前的每个步骤进行相应的优化工作。&lt;/p&gt;
&lt;h4 id=&quot;加载-Dylib-1&quot;&gt;&lt;a href=&quot;#加载-Dylib-1&quot; class=&quot;headerlink&quot; title=&quot;加载 Dylib&quot;&gt;&lt;/a&gt;加载 Dylib&lt;/h4&gt;&lt;p&gt;之前提到过加载系统的 dylib 很快，因为有优化。但加载内嵌（embedded）的 dylib 文件很占时间，所以尽可能把多个内嵌 dylib 合并成一个来加载，或者使用 static archive。使用 &lt;code&gt;dlopen()&lt;/code&gt; 来在运行时懒加载是不建议的，这么做可能会带来一些问题，并且总的开销更大。&lt;/p&gt;
&lt;h4 id=&quot;Rebase-Binding&quot;&gt;&lt;a href=&quot;#Rebase-Binding&quot; class=&quot;headerlink&quot; title=&quot;Rebase/Binding&quot;&gt;&lt;/a&gt;Rebase/Binding&lt;/h4&gt;&lt;p&gt;之前提过 Rebaing 消耗了大量时间在 I/O 上，而在之后的 Binding 就不怎么需要 I/O 了，而是将时间耗费在计算上。所以这两个步骤的耗时是混在一起的。&lt;/p&gt;
&lt;p&gt;之前说过可以从查看 &lt;code&gt;__DATA&lt;/code&gt; 段中需要修正（fix-up）的指针，所以减少指针数量才会减少这部分工作的耗时。对于 ObjC 来说就是减少 &lt;code&gt;Class&lt;/code&gt;,&lt;code&gt;selector&lt;/code&gt; 和 &lt;code&gt;category&lt;/code&gt; 这些元数据的数量。从编码原则和设计模式之类的理论都会鼓励大家多写精致短小的类和方法，并将每部分方法独立出一个类别，其实这会增加启动时间。对于 C++ 来说需要减少虚方法，因为虚方法会创建 vtable，这也会在 &lt;code&gt;__DATA&lt;/code&gt; 段中创建结构。虽然 C++ 虚方法对启动耗时的增加要比 ObjC 元数据要少，但依然不可忽视。最后推荐使用 Swift 结构体，它需要 fix-up 的内容较少。&lt;/p&gt;
&lt;h4 id=&quot;ObjC-Setup&quot;&gt;&lt;a href=&quot;#ObjC-Setup&quot; class=&quot;headerlink&quot; title=&quot;ObjC Setup&quot;&gt;&lt;/a&gt;ObjC Setup&lt;/h4&gt;&lt;p&gt;针对这步所能事情很少，几乎都靠 Rebasing 和 Binding 步骤中减少所需 fix-up 内容。因为前面的工作也会使得这步耗时减少。&lt;/p&gt;
&lt;h4 id=&quot;Initializer&quot;&gt;&lt;a href=&quot;#Initializer&quot; class=&quot;headerlink&quot; title=&quot;Initializer&quot;&gt;&lt;/a&gt;Initializer&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;显式初始化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;+initialize&lt;/code&gt; 来替代 &lt;code&gt;+load&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不要使用 &lt;code&gt;__atribute__((constructor))&lt;/code&gt; 将方法显式标记为初始化器，而是让初始化方法调用时才执行。比如使用 &lt;code&gt;dispatch_once()&lt;/code&gt;,&lt;code&gt;pthread_once()&lt;/code&gt; 或 &lt;code&gt;std::once()&lt;/code&gt;。也就是在第一次使用时才初始化，推迟了一部分工作耗时。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;隐式初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于带有&lt;a href=&quot;http://stackoverflow.com/questions/3899223/what-is-a-non-trivial-constructor-in-c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;复杂（non-trivial）构造器&lt;/a&gt;的 C++ 静态变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在调用的地方使用初始化器。&lt;/li&gt;
&lt;li&gt;只用简单值类型赋值（POD:Plain Old Data），这样静态链接器会预先计算 &lt;code&gt;__DATA&lt;/code&gt; 中的数据，无需再进行 fix-up 工作。&lt;/li&gt;
&lt;li&gt;使用编译器 warning 标志 &lt;code&gt;-Wglobal-constructors&lt;/code&gt; 来发现隐式初始化代码。&lt;/li&gt;
&lt;li&gt;使用 Swift 重写代码，因为 Swift 已经预先处理好了，强力推荐。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不要在初始化方法中调用 &lt;code&gt;dlopen()&lt;/code&gt;，对性能有影响。因为 &lt;code&gt;dyld&lt;/code&gt; 在 App 开始前运行，由于此时是单线程运行所以系统会取消加锁，但 &lt;code&gt;dlopen()&lt;/code&gt; 开启了多线程，系统不得不加锁，这就严重影响了性能，还可能会造成死锁以及产生未知的后果。所以也不要在初始化器中创建线程。&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/406/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/videos/play/wwdc2016/406/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇 WWDC 2016 Session 406 的学习笔记，从原理到实践讲述了如何优化 App 的启动时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Runtime" scheme="http://yulingtianxia.com/tags/Runtime/"/>
    
  </entry>
  
</feed>
